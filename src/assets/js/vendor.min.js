var module;
var define;
var globalThis;
let obj = {};
// Check if obj is an object before using Object.defineProperty
if (typeof obj === "object" && obj !== null) {
  Object.defineProperty(obj, "propertyName", {
    value: "propertyValue",
    configurable: true,
    writable: true,
  });
} else {
  console.error("Object.defineProperty called on a non-object");
}

!(function (t, e) {
  "object" == typeof exports && void 0 !== module
    ? (module.exports = e())
    : "function" == typeof define && define.amd
    ? define(e)
    : ((t =
        "undefined" != typeof globalThis ? globalThis : t || self).bootstrap =
        e());
})(this, function () {
  "use strict";
  const t = "transitionend",
    e = (t) => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let n = t.getAttribute("href");
        if (!n || (!n.includes("#") && !n.startsWith("."))) return null;
        n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`),
          (e = n && "#" !== n ? n.trim() : null);
      }
      return e;
    },
    n = (t) => {
      const n = e(t);
      return n && document.querySelector(n) ? n : null;
    },
    r = (t) => {
      const n = e(t);
      return n ? document.querySelector(n) : null;
    },
    s = (e) => {
      e.dispatchEvent(new Event(t));
    },
    i = (t) =>
      !(!t || "object" != typeof t) &&
      (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    a = (t) =>
      i(t)
        ? t.jquery
          ? t[0]
          : t
        : "string" == typeof t && t.length > 0
        ? document.querySelector(t)
        : null,
    o = (t) => {
      if (!i(t) || 0 === t.getClientRects().length) return !1;
      const e =
          "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        n = t.closest("details:not([open])");
      if (!n) return e;
      if (n !== t) {
        const e = t.closest("summary");
        if (e && e.parentNode !== n) return !1;
        if (null === e) return !1;
      }
      return e;
    },
    l = (t) =>
      !t ||
      t.nodeType !== Node.ELEMENT_NODE ||
      !!t.classList.contains("disabled") ||
      (void 0 !== t.disabled
        ? t.disabled
        : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    c = (t) => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        const e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null;
      }
      return t instanceof ShadowRoot
        ? t
        : t.parentNode
        ? c(t.parentNode)
        : null;
    },
    u = () => {},
    p = (t) => {
      t.offsetHeight;
    },
    d = () =>
      window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")
        ? window.jQuery
        : null,
    f = [],
    h = () => "rtl" === document.documentElement.dir,
    m = (t) => {
      var e;
      (e = () => {
        const e = d();
        if (e) {
          const n = t.NAME,
            r = e.fn[n];
          (e.fn[n] = t.jQueryInterface),
            (e.fn[n].Constructor = t),
            (e.fn[n].noConflict = () => ((e.fn[n] = r), t.jQueryInterface));
        }
      }),
        "loading" === document.readyState
          ? (f.length ||
              document.addEventListener("DOMContentLoaded", () => {
                for (const t of f) t();
              }),
            f.push(e))
          : e();
    },
    g = (t) => {
      "function" == typeof t && t();
    },
    v = (e, n, r = !0) => {
      if (!r) return void g(e);
      const i =
        ((t) => {
          if (!t) return 0;
          let { transitionDuration: e, transitionDelay: n } =
            window.getComputedStyle(t);
          const r = Number.parseFloat(e),
            s = Number.parseFloat(n);
          return r || s
            ? ((e = e.split(",")[0]),
              (n = n.split(",")[0]),
              1e3 * (Number.parseFloat(e) + Number.parseFloat(n)))
            : 0;
        })(n) + 5;
      let a = !1;
      const o = ({ target: r }) => {
        r === n && ((a = !0), n.removeEventListener(t, o), g(e));
      };
      n.addEventListener(t, o),
        setTimeout(() => {
          a || s(n);
        }, i);
    },
    y = (t, e, n, r) => {
      const s = t.length;
      let i = t.indexOf(e);
      return -1 === i
        ? !n && r
          ? t[s - 1]
          : t[0]
        : ((i += n ? 1 : -1),
          r && (i = (i + s) % s),
          t[Math.max(0, Math.min(i, s - 1))]);
    },
    b = /[^.]*(?=\..*)\.|.*/,
    _ = /\..*/,
    w = /::\d+$/,
    S = {};
  let C = 1;
  const x = { mouseenter: "mouseover", mouseleave: "mouseout" },
    k = new Set([
      "click",
      "dblclick",
      "mouseup",
      "mousedown",
      "contextmenu",
      "mousewheel",
      "DOMMouseScroll",
      "mouseover",
      "mouseout",
      "mousemove",
      "selectstart",
      "selectend",
      "keydown",
      "keypress",
      "keyup",
      "orientationchange",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointerleave",
      "pointercancel",
      "gesturestart",
      "gesturechange",
      "gestureend",
      "focus",
      "blur",
      "change",
      "reset",
      "select",
      "submit",
      "focusin",
      "focusout",
      "load",
      "unload",
      "beforeunload",
      "resize",
      "move",
      "DOMContentLoaded",
      "readystatechange",
      "error",
      "abort",
      "scroll",
    ]);
  function E(t, e) {
    return (e && `${e}::${C++}`) || t.uidEvent || C++;
  }
  function T(t) {
    const e = E(t);
    return (t.uidEvent = e), (S[e] = S[e] || {}), S[e];
  }
  function P(t, e, n = null) {
    return Object.values(t).find(
      (t) => t.callable === e && t.delegationSelector === n
    );
  }
  function M(t, e, n) {
    const r = "string" == typeof e,
      s = r ? n : e || n;
    let i = $(t);
    return k.has(i) || (i = t), [r, s, i];
  }
  function O(t, e, n, r, s) {
    if ("string" != typeof e || !t) return;
    let [i, a, o] = M(e, n, r);
    if (e in x) {
      const t = (t) =>
        function (e) {
          if (
            !e.relatedTarget ||
            (e.relatedTarget !== e.delegateTarget &&
              !e.delegateTarget.contains(e.relatedTarget))
          )
            return t.call(this, e);
        };
      a = t(a);
    }
    const l = T(t),
      c = l[o] || (l[o] = {}),
      u = P(c, a, i ? n : null);
    if (u) return void (u.oneOff = u.oneOff && s);
    const p = E(a, e.replace(b, "")),
      d = i
        ? (function (t, e, n) {
            return function r(s) {
              const i = t.querySelectorAll(e);
              for (let { target: a } = s; a && a !== this; a = a.parentNode)
                for (const o of i)
                  if (o === a)
                    return (
                      I(s, { delegateTarget: a }),
                      r.oneOff && D.off(t, s.type, e, n),
                      n.apply(a, [s])
                    );
            };
          })(t, n, a)
        : (function (t, e) {
            return function n(r) {
              return (
                I(r, { delegateTarget: t }),
                n.oneOff && D.off(t, r.type, e),
                e.apply(t, [r])
              );
            };
          })(t, a);
    (d.delegationSelector = i ? n : null),
      (d.callable = a),
      (d.oneOff = s),
      (d.uidEvent = p),
      (c[p] = d),
      t.addEventListener(o, d, i);
  }
  function A(t, e, n, r, s) {
    const i = P(e[n], r, s);
    i && (t.removeEventListener(n, i, Boolean(s)), delete e[n][i.uidEvent]);
  }
  function j(t, e, n, r) {
    const s = e[n] || {};
    for (const i of Object.keys(s))
      if (i.includes(r)) {
        const r = s[i];
        A(t, e, n, r.callable, r.delegationSelector);
      }
  }
  function $(t) {
    return (t = t.replace(_, "")), x[t] || t;
  }
  const D = {
    on(t, e, n, r) {
      O(t, e, n, r, !1);
    },
    one(t, e, n, r) {
      O(t, e, n, r, !0);
    },
    off(t, e, n, r) {
      if ("string" != typeof e || !t) return;
      const [s, i, a] = M(e, n, r),
        o = a !== e,
        l = T(t),
        c = l[a] || {},
        u = e.startsWith(".");
      if (void 0 === i) {
        if (u) for (const n of Object.keys(l)) j(t, l, n, e.slice(1));
        for (const n of Object.keys(c)) {
          const r = n.replace(w, "");
          if (!o || e.includes(r)) {
            const e = c[n];
            A(t, l, a, e.callable, e.delegationSelector);
          }
        }
      } else {
        if (!Object.keys(c).length) return;
        A(t, l, a, i, s ? n : null);
      }
    },
    trigger(t, e, n) {
      if ("string" != typeof e || !t) return null;
      const r = d();
      let s = null,
        i = !0,
        a = !0,
        o = !1;
      e !== $(e) &&
        r &&
        ((s = r.Event(e, n)),
        r(t).trigger(s),
        (i = !s.isPropagationStopped()),
        (a = !s.isImmediatePropagationStopped()),
        (o = s.isDefaultPrevented()));
      let l = new Event(e, { bubbles: i, cancelable: !0 });
      return (
        (l = I(l, n)),
        o && l.preventDefault(),
        a && t.dispatchEvent(l),
        l.defaultPrevented && s && s.preventDefault(),
        l
      );
    },
  };
  function I(t, e) {
    for (const [n, r] of Object.entries(e || {}))
      try {
        t[n] = r;
      } catch (e) {
        Object.defineProperty(t, n, { configurable: !0, get: () => r });
      }
    return t;
  }
  const L = new Map(),
    V = {
      set(t, e, n) {
        L.has(t) || L.set(t, new Map());
        const r = L.get(t);
        r.has(e) || 0 === r.size
          ? r.set(e, n)
          : console.error(
              `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
                Array.from(r.keys())[0]
              }.`
            );
      },
      get: (t, e) => (L.has(t) && L.get(t).get(e)) || null,
      remove(t, e) {
        if (!L.has(t)) return;
        const n = L.get(t);
        n.delete(e), 0 === n.size && L.delete(t);
      },
    };
  function N(t) {
    if ("true" === t) return !0;
    if ("false" === t) return !1;
    if (t === Number(t).toString()) return Number(t);
    if ("" === t || "null" === t) return null;
    if ("string" != typeof t) return t;
    try {
      return JSON.parse(decodeURIComponent(t));
    } catch (e) {
      return t;
    }
  }
  function H(t) {
    return t.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
  }
  const R = {
    setDataAttribute(t, e, n) {
      t.setAttribute(`data-bs-${H(e)}`, n);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${H(e)}`);
    },
    getDataAttributes(t) {
      if (!t) return {};
      const e = {},
        n = Object.keys(t.dataset).filter(
          (t) => t.startsWith("bs") && !t.startsWith("bsConfig")
        );
      for (const r of n) {
        let n = r.replace(/^bs/, "");
        (n = n.charAt(0).toLowerCase() + n.slice(1, n.length)),
          (e[n] = N(t.dataset[r]));
      }
      return e;
    },
    getDataAttribute: (t, e) => N(t.getAttribute(`data-bs-${H(e)}`)),
  };
  class z {
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error(
        'You have to implement the static method "NAME", for each component!'
      );
    }
    _getConfig(t) {
      return (
        (t = this._mergeConfigObj(t)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    _configAfterMerge(t) {
      return t;
    }
    _mergeConfigObj(t, e) {
      const n = i(e) ? R.getDataAttribute(e, "config") : {};
      return {
        ...this.constructor.Default,
        ...("object" == typeof n ? n : {}),
        ...(i(e) ? R.getDataAttributes(e) : {}),
        ...("object" == typeof t ? t : {}),
      };
    }
    _typeCheckConfig(t, e = this.constructor.DefaultType) {
      for (const r of Object.keys(e)) {
        const s = e[r],
          a = t[r],
          o = i(a)
            ? "element"
            : null == (n = a)
            ? `${n}`
            : Object.prototype.toString
                .call(n)
                .match(/\s([a-z]+)/i)[1]
                .toLowerCase();
        if (!new RegExp(s).test(o))
          throw new TypeError(
            `${this.constructor.NAME.toUpperCase()}: Option "${r}" provided type "${o}" but expected type "${s}".`
          );
      }
      var n;
    }
  }
  class q extends z {
    constructor(t, e) {
      super(),
        (t = a(t)) &&
          ((this._element = t),
          (this._config = this._getConfig(e)),
          V.set(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      V.remove(this._element, this.constructor.DATA_KEY),
        D.off(this._element, this.constructor.EVENT_KEY);
      for (const t of Object.getOwnPropertyNames(this)) this[t] = null;
    }
    _queueCallback(t, e, n = !0) {
      v(t, e, n);
    }
    _getConfig(t) {
      return (
        (t = this._mergeConfigObj(t, this._element)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    static getInstance(t) {
      return V.get(a(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return (
        this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
      );
    }
    static get VERSION() {
      return "5.2.2";
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(t) {
      return `${t}${this.EVENT_KEY}`;
    }
  }
  const B = (t, e = "hide") => {
    const n = `click.dismiss${t.EVENT_KEY}`,
      s = t.NAME;
    D.on(document, n, `[data-bs-dismiss="${s}"]`, function (n) {
      if ((["A", "AREA"].includes(this.tagName) && n.preventDefault(), l(this)))
        return;
      const i = r(this) || this.closest(`.${s}`);
      t.getOrCreateInstance(i)[e]();
    });
  };
  class F extends q {
    static get NAME() {
      return "alert";
    }
    close() {
      if (D.trigger(this._element, "close.bs.alert").defaultPrevented) return;
      this._element.classList.remove("show");
      const t = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, t);
    }
    _destroyElement() {
      this._element.remove(),
        D.trigger(this._element, "closed.bs.alert"),
        this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = F.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  B(F, "close"), m(F);
  const W = '[data-bs-toggle="button"]';
  class U extends q {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute(
        "aria-pressed",
        this._element.classList.toggle("active")
      );
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = U.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }
  }
  D.on(document, "click.bs.button.data-api", W, (t) => {
    t.preventDefault();
    const e = t.target.closest(W);
    U.getOrCreateInstance(e).toggle();
  }),
    m(U);
  const G = {
      find: (t, e = document.documentElement) =>
        [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) =>
        Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter((t) => t.matches(e)),
      parents(t, e) {
        const n = [];
        let r = t.parentNode.closest(e);
        for (; r; ) n.push(r), (r = r.parentNode.closest(e));
        return n;
      },
      prev(t, e) {
        let n = t.previousElementSibling;
        for (; n; ) {
          if (n.matches(e)) return [n];
          n = n.previousElementSibling;
        }
        return [];
      },
      next(t, e) {
        let n = t.nextElementSibling;
        for (; n; ) {
          if (n.matches(e)) return [n];
          n = n.nextElementSibling;
        }
        return [];
      },
      focusableChildren(t) {
        const e = [
          "a",
          "button",
          "input",
          "textarea",
          "select",
          "details",
          "[tabindex]",
          '[contenteditable="true"]',
        ]
          .map((t) => `${t}:not([tabindex^="-"])`)
          .join(",");
        return this.find(e, t).filter((t) => !l(t) && o(t));
      },
    },
    Y = { endCallback: null, leftCallback: null, rightCallback: null },
    X = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)",
    };
  class K extends z {
    constructor(t, e) {
      super(),
        (this._element = t),
        t &&
          K.isSupported() &&
          ((this._config = this._getConfig(e)),
          (this._deltaX = 0),
          (this._supportPointerEvents = Boolean(window.PointerEvent)),
          this._initEvents());
    }
    static get Default() {
      return Y;
    }
    static get DefaultType() {
      return X;
    }
    static get NAME() {
      return "swipe";
    }
    dispose() {
      D.off(this._element, ".bs.swipe");
    }
    _start(t) {
      this._supportPointerEvents
        ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
        : (this._deltaX = t.touches[0].clientX);
    }
    _end(t) {
      this._eventIsPointerPenTouch(t) &&
        (this._deltaX = t.clientX - this._deltaX),
        this._handleSwipe(),
        g(this._config.endCallback);
    }
    _move(t) {
      this._deltaX =
        t.touches && t.touches.length > 1
          ? 0
          : t.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const t = Math.abs(this._deltaX);
      if (t <= 40) return;
      const e = t / this._deltaX;
      (this._deltaX = 0),
        e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      this._supportPointerEvents
        ? (D.on(this._element, "pointerdown.bs.swipe", (t) => this._start(t)),
          D.on(this._element, "pointerup.bs.swipe", (t) => this._end(t)),
          this._element.classList.add("pointer-event"))
        : (D.on(this._element, "touchstart.bs.swipe", (t) => this._start(t)),
          D.on(this._element, "touchmove.bs.swipe", (t) => this._move(t)),
          D.on(this._element, "touchend.bs.swipe", (t) => this._end(t)));
    }
    _eventIsPointerPenTouch(t) {
      return (
        this._supportPointerEvents &&
        ("pen" === t.pointerType || "touch" === t.pointerType)
      );
    }
    static isSupported() {
      return (
        "ontouchstart" in document.documentElement ||
        navigator.maxTouchPoints > 0
      );
    }
  }
  const Q = "next",
    J = "prev",
    Z = "left",
    tt = "right",
    et = "slid.bs.carousel",
    nt = "carousel",
    rt = "active",
    st = { ArrowLeft: tt, ArrowRight: Z },
    it = {
      interval: 5e3,
      keyboard: !0,
      pause: "hover",
      ride: !1,
      touch: !0,
      wrap: !0,
    },
    at = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean",
    };
  class ot extends q {
    constructor(t, e) {
      super(t, e),
        (this._interval = null),
        (this._activeElement = null),
        (this._isSliding = !1),
        (this.touchTimeout = null),
        (this._swipeHelper = null),
        (this._indicatorsElement = G.findOne(
          ".carousel-indicators",
          this._element
        )),
        this._addEventListeners(),
        this._config.ride === nt && this.cycle();
    }
    static get Default() {
      return it;
    }
    static get DefaultType() {
      return at;
    }
    static get NAME() {
      return "carousel";
    }
    next() {
      this._slide(Q);
    }
    nextWhenVisible() {
      !document.hidden && o(this._element) && this.next();
    }
    prev() {
      this._slide(J);
    }
    pause() {
      this._isSliding && s(this._element), this._clearInterval();
    }
    cycle() {
      this._clearInterval(),
        this._updateInterval(),
        (this._interval = setInterval(
          () => this.nextWhenVisible(),
          this._config.interval
        ));
    }
    _maybeEnableCycle() {
      this._config.ride &&
        (this._isSliding
          ? D.one(this._element, et, () => this.cycle())
          : this.cycle());
    }
    to(t) {
      const e = this._getItems();
      if (t > e.length - 1 || t < 0) return;
      if (this._isSliding)
        return void D.one(this._element, et, () => this.to(t));
      const n = this._getItemIndex(this._getActive());
      if (n === t) return;
      const r = t > n ? Q : J;
      this._slide(r, e[t]);
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
    }
    _configAfterMerge(t) {
      return (t.defaultInterval = t.interval), t;
    }
    _addEventListeners() {
      this._config.keyboard &&
        D.on(this._element, "keydown.bs.carousel", (t) => this._keydown(t)),
        "hover" === this._config.pause &&
          (D.on(this._element, "mouseenter.bs.carousel", () => this.pause()),
          D.on(this._element, "mouseleave.bs.carousel", () =>
            this._maybeEnableCycle()
          )),
        this._config.touch && K.isSupported() && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      for (const t of G.find(".carousel-item img", this._element))
        D.on(t, "dragstart.bs.carousel", (t) => t.preventDefault());
      const t = {
        leftCallback: () => this._slide(this._directionToOrder(Z)),
        rightCallback: () => this._slide(this._directionToOrder(tt)),
        endCallback: () => {
          "hover" === this._config.pause &&
            (this.pause(),
            this.touchTimeout && clearTimeout(this.touchTimeout),
            (this.touchTimeout = setTimeout(
              () => this._maybeEnableCycle(),
              500 + this._config.interval
            )));
        },
      };
      this._swipeHelper = new K(this._element, t);
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      const e = st[t.key];
      e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
    }
    _getItemIndex(t) {
      return this._getItems().indexOf(t);
    }
    _setActiveIndicatorElement(t) {
      if (!this._indicatorsElement) return;
      const e = G.findOne(".active", this._indicatorsElement);
      e.classList.remove(rt), e.removeAttribute("aria-current");
      const n = G.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
      n && (n.classList.add(rt), n.setAttribute("aria-current", "true"));
    }
    _updateInterval() {
      const t = this._activeElement || this._getActive();
      if (!t) return;
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      this._config.interval = e || this._config.defaultInterval;
    }
    _slide(t, e = null) {
      if (this._isSliding) return;
      const n = this._getActive(),
        r = t === Q,
        s = e || y(this._getItems(), n, r, this._config.wrap);
      if (s === n) return;
      const i = this._getItemIndex(s),
        a = (e) =>
          D.trigger(this._element, e, {
            relatedTarget: s,
            direction: this._orderToDirection(t),
            from: this._getItemIndex(n),
            to: i,
          });
      if (a("slide.bs.carousel").defaultPrevented) return;
      if (!n || !s) return;
      const o = Boolean(this._interval);
      this.pause(),
        (this._isSliding = !0),
        this._setActiveIndicatorElement(i),
        (this._activeElement = s);
      const l = r ? "carousel-item-start" : "carousel-item-end",
        c = r ? "carousel-item-next" : "carousel-item-prev";
      s.classList.add(c),
        p(s),
        n.classList.add(l),
        s.classList.add(l),
        this._queueCallback(
          () => {
            s.classList.remove(l, c),
              s.classList.add(rt),
              n.classList.remove(rt, c, l),
              (this._isSliding = !1),
              a(et);
          },
          n,
          this._isAnimated()
        ),
        o && this.cycle();
    }
    _isAnimated() {
      return this._element.classList.contains("slide");
    }
    _getActive() {
      return G.findOne(".active.carousel-item", this._element);
    }
    _getItems() {
      return G.find(".carousel-item", this._element);
    }
    _clearInterval() {
      this._interval &&
        (clearInterval(this._interval), (this._interval = null));
    }
    _directionToOrder(t) {
      return h() ? (t === Z ? J : Q) : t === Z ? Q : J;
    }
    _orderToDirection(t) {
      return h() ? (t === J ? Z : tt) : t === J ? tt : Z;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = ot.getOrCreateInstance(this, t);
        if ("number" != typeof t) {
          if ("string" == typeof t) {
            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
              throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        } else e.to(t);
      });
    }
  }
  D.on(
    document,
    "click.bs.carousel.data-api",
    "[data-bs-slide], [data-bs-slide-to]",
    function (t) {
      const e = r(this);
      if (!e || !e.classList.contains(nt)) return;
      t.preventDefault();
      const n = ot.getOrCreateInstance(e),
        s = this.getAttribute("data-bs-slide-to");
      return s
        ? (n.to(s), void n._maybeEnableCycle())
        : "next" === R.getDataAttribute(this, "slide")
        ? (n.next(), void n._maybeEnableCycle())
        : (n.prev(), void n._maybeEnableCycle());
    }
  ),
    D.on(window, "load.bs.carousel.data-api", () => {
      const t = G.find('[data-bs-ride="carousel"]');
      for (const e of t) ot.getOrCreateInstance(e);
    }),
    m(ot);
  const lt = "show",
    ct = "collapse",
    ut = "collapsing",
    pt = '[data-bs-toggle="collapse"]',
    dt = { parent: null, toggle: !0 },
    ft = { parent: "(null|element)", toggle: "boolean" };
  class ht extends q {
    constructor(t, e) {
      super(t, e), (this._isTransitioning = !1), (this._triggerArray = []);
      const r = G.find(pt);
      for (const t of r) {
        const e = n(t),
          r = G.find(e).filter((t) => t === this._element);
        null !== e && r.length && this._triggerArray.push(t);
      }
      this._initializeChildren(),
        this._config.parent ||
          this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
        this._config.toggle && this.toggle();
    }
    static get Default() {
      return dt;
    }
    static get DefaultType() {
      return ft;
    }
    static get NAME() {
      return "collapse";
    }
    toggle() {
      this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t = [];
      if (
        (this._config.parent &&
          (t = this._getFirstLevelChildren(
            ".collapse.show, .collapse.collapsing"
          )
            .filter((t) => t !== this._element)
            .map((t) => ht.getOrCreateInstance(t, { toggle: !1 }))),
        t.length && t[0]._isTransitioning)
      )
        return;
      if (D.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
      for (const e of t) e.hide();
      const e = this._getDimension();
      this._element.classList.remove(ct),
        this._element.classList.add(ut),
        (this._element.style[e] = 0),
        this._addAriaAndCollapsedClass(this._triggerArray, !0),
        (this._isTransitioning = !0);
      const n = `scroll${e[0].toUpperCase() + e.slice(1)}`;
      this._queueCallback(
        () => {
          (this._isTransitioning = !1),
            this._element.classList.remove(ut),
            this._element.classList.add(ct, lt),
            (this._element.style[e] = ""),
            D.trigger(this._element, "shown.bs.collapse");
        },
        this._element,
        !0
      ),
        (this._element.style[e] = `${this._element[n]}px`);
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) return;
      if (D.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
      const t = this._getDimension();
      (this._element.style[t] = `${
        this._element.getBoundingClientRect()[t]
      }px`),
        p(this._element),
        this._element.classList.add(ut),
        this._element.classList.remove(ct, lt);
      for (const t of this._triggerArray) {
        const e = r(t);
        e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1);
      }
      (this._isTransitioning = !0),
        (this._element.style[t] = ""),
        this._queueCallback(
          () => {
            (this._isTransitioning = !1),
              this._element.classList.remove(ut),
              this._element.classList.add(ct),
              D.trigger(this._element, "hidden.bs.collapse");
          },
          this._element,
          !0
        );
    }
    _isShown(t = this._element) {
      return t.classList.contains(lt);
    }
    _configAfterMerge(t) {
      return (t.toggle = Boolean(t.toggle)), (t.parent = a(t.parent)), t;
    }
    _getDimension() {
      return this._element.classList.contains("collapse-horizontal")
        ? "width"
        : "height";
    }
    _initializeChildren() {
      if (!this._config.parent) return;
      const t = this._getFirstLevelChildren(pt);
      for (const e of t) {
        const t = r(e);
        t && this._addAriaAndCollapsedClass([e], this._isShown(t));
      }
    }
    _getFirstLevelChildren(t) {
      const e = G.find(":scope .collapse .collapse", this._config.parent);
      return G.find(t, this._config.parent).filter((t) => !e.includes(t));
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length)
        for (const n of t)
          n.classList.toggle("collapsed", !e),
            n.setAttribute("aria-expanded", e);
    }
    static jQueryInterface(t) {
      const e = {};
      return (
        "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1),
        this.each(function () {
          const n = ht.getOrCreateInstance(this, e);
          if ("string" == typeof t) {
            if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`);
            n[t]();
          }
        })
      );
    }
  }
  D.on(document, "click.bs.collapse.data-api", pt, function (t) {
    ("A" === t.target.tagName ||
      (t.delegateTarget && "A" === t.delegateTarget.tagName)) &&
      t.preventDefault();
    const e = n(this),
      r = G.find(e);
    for (const t of r) ht.getOrCreateInstance(t, { toggle: !1 }).toggle();
  }),
    m(ht);
  var mt = "top",
    gt = "bottom",
    vt = "right",
    yt = "left",
    bt = "auto",
    _t = [mt, gt, vt, yt],
    wt = "start",
    St = "end",
    Ct = "clippingParents",
    xt = "viewport",
    kt = "popper",
    Et = "reference",
    Tt = _t.reduce(function (t, e) {
      return t.concat([e + "-" + wt, e + "-" + St]);
    }, []),
    Pt = [].concat(_t, [bt]).reduce(function (t, e) {
      return t.concat([e, e + "-" + wt, e + "-" + St]);
    }, []),
    Mt = "beforeRead",
    Ot = "read",
    At = "afterRead",
    jt = "beforeMain",
    $t = "main",
    Dt = "afterMain",
    It = "beforeWrite",
    Lt = "write",
    Vt = "afterWrite",
    Nt = [Mt, Ot, At, jt, $t, Dt, It, Lt, Vt];
  function Ht(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function Rt(t) {
    if (null == t) return window;
    if ("[object Window]" !== t.toString()) {
      var e = t.ownerDocument;
      return (e && e.defaultView) || window;
    }
    return t;
  }
  function zt(t) {
    return t instanceof Rt(t).Element || t instanceof Element;
  }
  function qt(t) {
    return t instanceof Rt(t).HTMLElement || t instanceof HTMLElement;
  }
  function Bt(t) {
    return (
      "undefined" != typeof ShadowRoot &&
      (t instanceof Rt(t).ShadowRoot || t instanceof ShadowRoot)
    );
  }
  const Ft = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function (t) {
        var n = e.styles[t] || {},
          r = e.attributes[t] || {},
          s = e.elements[t];
        qt(s) &&
          Ht(s) &&
          (Object.assign(s.style, n),
          Object.keys(r).forEach(function (t) {
            var e = r[t];
            !1 === e
              ? s.removeAttribute(t)
              : s.setAttribute(t, !0 === e ? "" : e);
          }));
      });
    },
    effect: function (t) {
      var e = t.state,
        n = {
          popper: {
            position: e.options.strategy,
            left: "0",
            top: "0",
            margin: "0",
          },
          arrow: { position: "absolute" },
          reference: {},
        };
      return (
        Object.assign(e.elements.popper.style, n.popper),
        (e.styles = n),
        e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function () {
          Object.keys(e.elements).forEach(function (t) {
            var r = e.elements[t],
              s = e.attributes[t] || {},
              i = Object.keys(
                Object.prototype.hasOwnProperty.call(e.styles, t)
                  ? e.styles[t]
                  : n[t]
              ).reduce(function (t, e) {
                return (t[e] = ""), t;
              }, {});
            qt(r) &&
              Ht(r) &&
              (Object.assign(r.style, i),
              Object.keys(s).forEach(function (t) {
                r.removeAttribute(t);
              }));
          });
        }
      );
    },
    requires: ["computeStyles"],
  };
  function Wt(t) {
    return t.split("-")[0];
  }
  var Ut = Math.max,
    Gt = Math.min,
    Yt = Math.round;
  function Xt() {
    var t = navigator.userAgentData;
    return null != t && t.brands
      ? t.brands
          .map(function (t) {
            return t.brand + "/" + t.version;
          })
          .join(" ")
      : navigator.userAgent;
  }
  function Kt() {
    return !/^((?!chrome|android).)*safari/i.test(Xt());
  }
  function Qt(t, e, n) {
    void 0 === e && (e = !1), void 0 === n && (n = !1);
    var r = t.getBoundingClientRect(),
      s = 1,
      i = 1;
    e &&
      qt(t) &&
      ((s = (t.offsetWidth > 0 && Yt(r.width) / t.offsetWidth) || 1),
      (i = (t.offsetHeight > 0 && Yt(r.height) / t.offsetHeight) || 1));
    var a = (zt(t) ? Rt(t) : window).visualViewport,
      o = !Kt() && n,
      l = (r.left + (o && a ? a.offsetLeft : 0)) / s,
      c = (r.top + (o && a ? a.offsetTop : 0)) / i,
      u = r.width / s,
      p = r.height / i;
    return {
      width: u,
      height: p,
      top: c,
      right: l + u,
      bottom: c + p,
      left: l,
      x: l,
      y: c,
    };
  }
  function Jt(t) {
    var e = Qt(t),
      n = t.offsetWidth,
      r = t.offsetHeight;
    return (
      Math.abs(e.width - n) <= 1 && (n = e.width),
      Math.abs(e.height - r) <= 1 && (r = e.height),
      { x: t.offsetLeft, y: t.offsetTop, width: n, height: r }
    );
  }
  function Zt(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (n && Bt(n)) {
      var r = e;
      do {
        if (r && t.isSameNode(r)) return !0;
        r = r.parentNode || r.host;
      } while (r);
    }
    return !1;
  }
  function te(t) {
    return Rt(t).getComputedStyle(t);
  }
  function ee(t) {
    return ["table", "td", "th"].indexOf(Ht(t)) >= 0;
  }
  function ne(t) {
    return (
      (zt(t) ? t.ownerDocument : t.document) || window.document
    ).documentElement;
  }
  function re(t) {
    return "html" === Ht(t)
      ? t
      : t.assignedSlot || t.parentNode || (Bt(t) ? t.host : null) || ne(t);
  }
  function se(t) {
    return qt(t) && "fixed" !== te(t).position ? t.offsetParent : null;
  }
  function ie(t) {
    for (var e = Rt(t), n = se(t); n && ee(n) && "static" === te(n).position; )
      n = se(n);
    return n &&
      ("html" === Ht(n) || ("body" === Ht(n) && "static" === te(n).position))
      ? e
      : n ||
          (function (t) {
            var e = /firefox/i.test(Xt());
            if (/Trident/i.test(Xt()) && qt(t) && "fixed" === te(t).position)
              return null;
            var n = re(t);
            for (
              Bt(n) && (n = n.host);
              qt(n) && ["html", "body"].indexOf(Ht(n)) < 0;

            ) {
              var r = te(n);
              if (
                "none" !== r.transform ||
                "none" !== r.perspective ||
                "paint" === r.contain ||
                -1 !== ["transform", "perspective"].indexOf(r.willChange) ||
                (e && "filter" === r.willChange) ||
                (e && r.filter && "none" !== r.filter)
              )
                return n;
              n = n.parentNode;
            }
            return null;
          })(t) ||
          e;
  }
  function ae(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function oe(t, e, n) {
    return Ut(t, Gt(e, n));
  }
  function le(t) {
    return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t);
  }
  function ce(t, e) {
    return e.reduce(function (e, n) {
      return (e[n] = t), e;
    }, {});
  }
  const ue = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e,
        n = t.state,
        r = t.name,
        s = t.options,
        i = n.elements.arrow,
        a = n.modifiersData.popperOffsets,
        o = Wt(n.placement),
        l = ae(o),
        c = [yt, vt].indexOf(o) >= 0 ? "height" : "width";
      if (i && a) {
        var u = (function (t, e) {
            return le(
              "number" !=
                typeof (t =
                  "function" == typeof t
                    ? t(Object.assign({}, e.rects, { placement: e.placement }))
                    : t)
                ? t
                : ce(t, _t)
            );
          })(s.padding, n),
          p = Jt(i),
          d = "y" === l ? mt : yt,
          f = "y" === l ? gt : vt,
          h =
            n.rects.reference[c] +
            n.rects.reference[l] -
            a[l] -
            n.rects.popper[c],
          m = a[l] - n.rects.reference[l],
          g = ie(i),
          v = g ? ("y" === l ? g.clientHeight || 0 : g.clientWidth || 0) : 0,
          y = h / 2 - m / 2,
          b = u[d],
          _ = v - p[c] - u[f],
          w = v / 2 - p[c] / 2 + y,
          S = oe(b, w, _),
          C = l;
        n.modifiersData[r] = (((e = {})[C] = S), (e.centerOffset = S - w), e);
      }
    },
    effect: function (t) {
      var e = t.state,
        n = t.options.element,
        r = void 0 === n ? "[data-popper-arrow]" : n;
      null != r &&
        ("string" != typeof r || (r = e.elements.popper.querySelector(r))) &&
        Zt(e.elements.popper, r) &&
        (e.elements.arrow = r);
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
  };
  function pe(t) {
    return t.split("-")[1];
  }
  var de = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function fe(t) {
    var e,
      n = t.popper,
      r = t.popperRect,
      s = t.placement,
      i = t.variation,
      a = t.offsets,
      o = t.position,
      l = t.gpuAcceleration,
      c = t.adaptive,
      u = t.roundOffsets,
      p = t.isFixed,
      d = a.x,
      f = void 0 === d ? 0 : d,
      h = a.y,
      m = void 0 === h ? 0 : h,
      g = "function" == typeof u ? u({ x: f, y: m }) : { x: f, y: m };
    (f = g.x), (m = g.y);
    var v = Object.prototype.hasOwnProperty.call(a, "x"),
      y = Object.prototype.hasOwnProperty.call(a, "y"),
      b = yt,
      _ = mt,
      w = window;
    if (c) {
      var S = ie(n),
        C = "clientHeight",
        x = "clientWidth";
      S === Rt(n) &&
        "static" !== te((S = ne(n))).position &&
        "absolute" === o &&
        ((C = "scrollHeight"), (x = "scrollWidth")),
        (s === mt || ((s === yt || s === vt) && i === St)) &&
          ((_ = gt),
          (m -=
            (p && S === w && w.visualViewport
              ? w.visualViewport.height
              : S[C]) - r.height),
          (m *= l ? 1 : -1)),
        (s !== yt && ((s !== mt && s !== gt) || i !== St)) ||
          ((b = vt),
          (f -=
            (p && S === w && w.visualViewport ? w.visualViewport.width : S[x]) -
            r.width),
          (f *= l ? 1 : -1));
    }
    var k,
      E = Object.assign({ position: o }, c && de),
      T =
        !0 === u
          ? (function (t) {
              var e = t.x,
                n = t.y,
                r = window.devicePixelRatio || 1;
              return { x: Yt(e * r) / r || 0, y: Yt(n * r) / r || 0 };
            })({ x: f, y: m })
          : { x: f, y: m };
    return (
      (f = T.x),
      (m = T.y),
      l
        ? Object.assign(
            {},
            E,
            (((k = {})[_] = y ? "0" : ""),
            (k[b] = v ? "0" : ""),
            (k.transform =
              (w.devicePixelRatio || 1) <= 1
                ? "translate(" + f + "px, " + m + "px)"
                : "translate3d(" + f + "px, " + m + "px, 0)"),
            k)
          )
        : Object.assign(
            {},
            E,
            (((e = {})[_] = y ? m + "px" : ""),
            (e[b] = v ? f + "px" : ""),
            (e.transform = ""),
            e)
          )
    );
  }
  const he = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (t) {
      var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        s = void 0 === r || r,
        i = n.adaptive,
        a = void 0 === i || i,
        o = n.roundOffsets,
        l = void 0 === o || o,
        c = {
          placement: Wt(e.placement),
          variation: pe(e.placement),
          popper: e.elements.popper,
          popperRect: e.rects.popper,
          gpuAcceleration: s,
          isFixed: "fixed" === e.options.strategy,
        };
      null != e.modifiersData.popperOffsets &&
        (e.styles.popper = Object.assign(
          {},
          e.styles.popper,
          fe(
            Object.assign({}, c, {
              offsets: e.modifiersData.popperOffsets,
              position: e.options.strategy,
              adaptive: a,
              roundOffsets: l,
            })
          )
        )),
        null != e.modifiersData.arrow &&
          (e.styles.arrow = Object.assign(
            {},
            e.styles.arrow,
            fe(
              Object.assign({}, c, {
                offsets: e.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: l,
              })
            )
          )),
        (e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-placement": e.placement,
        }));
    },
    data: {},
  };
  var me = { passive: !0 };
  const ge = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (t) {
      var e = t.state,
        n = t.instance,
        r = t.options,
        s = r.scroll,
        i = void 0 === s || s,
        a = r.resize,
        o = void 0 === a || a,
        l = Rt(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return (
        i &&
          c.forEach(function (t) {
            t.addEventListener("scroll", n.update, me);
          }),
        o && l.addEventListener("resize", n.update, me),
        function () {
          i &&
            c.forEach(function (t) {
              t.removeEventListener("scroll", n.update, me);
            }),
            o && l.removeEventListener("resize", n.update, me);
        }
      );
    },
    data: {},
  };
  var ve = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function ye(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return ve[t];
    });
  }
  var be = { start: "end", end: "start" };
  function _e(t) {
    return t.replace(/start|end/g, function (t) {
      return be[t];
    });
  }
  function we(t) {
    var e = Rt(t);
    return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
  }
  function Se(t) {
    return Qt(ne(t)).left + we(t).scrollLeft;
  }
  function Ce(t) {
    var e = te(t),
      n = e.overflow,
      r = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + s + r);
  }
  function xe(t) {
    return ["html", "body", "#document"].indexOf(Ht(t)) >= 0
      ? t.ownerDocument.body
      : qt(t) && Ce(t)
      ? t
      : xe(re(t));
  }
  function ke(t, e) {
    var n;
    void 0 === e && (e = []);
    var r = xe(t),
      s = r === (null == (n = t.ownerDocument) ? void 0 : n.body),
      i = Rt(r),
      a = s ? [i].concat(i.visualViewport || [], Ce(r) ? r : []) : r,
      o = e.concat(a);
    return s ? o : o.concat(ke(re(a)));
  }
  function Ee(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height,
    });
  }
  function Te(t, e, n) {
    return e === xt
      ? Ee(
          (function (t, e) {
            var n = Rt(t),
              r = ne(t),
              s = n.visualViewport,
              i = r.clientWidth,
              a = r.clientHeight,
              o = 0,
              l = 0;
            if (s) {
              (i = s.width), (a = s.height);
              var c = Kt();
              (c || (!c && "fixed" === e)) &&
                ((o = s.offsetLeft), (l = s.offsetTop));
            }
            return { width: i, height: a, x: o + Se(t), y: l };
          })(t, n)
        )
      : zt(e)
      ? (function (t, e) {
          var n = Qt(t, !1, "fixed" === e);
          return (
            (n.top = n.top + t.clientTop),
            (n.left = n.left + t.clientLeft),
            (n.bottom = n.top + t.clientHeight),
            (n.right = n.left + t.clientWidth),
            (n.width = t.clientWidth),
            (n.height = t.clientHeight),
            (n.x = n.left),
            (n.y = n.top),
            n
          );
        })(e, n)
      : Ee(
          (function (t) {
            var e,
              n = ne(t),
              r = we(t),
              s = null == (e = t.ownerDocument) ? void 0 : e.body,
              i = Ut(
                n.scrollWidth,
                n.clientWidth,
                s ? s.scrollWidth : 0,
                s ? s.clientWidth : 0
              ),
              a = Ut(
                n.scrollHeight,
                n.clientHeight,
                s ? s.scrollHeight : 0,
                s ? s.clientHeight : 0
              ),
              o = -r.scrollLeft + Se(t),
              l = -r.scrollTop;
            return (
              "rtl" === te(s || n).direction &&
                (o += Ut(n.clientWidth, s ? s.clientWidth : 0) - i),
              { width: i, height: a, x: o, y: l }
            );
          })(ne(t))
        );
  }
  function Pe(t) {
    var e,
      n = t.reference,
      r = t.element,
      s = t.placement,
      i = s ? Wt(s) : null,
      a = s ? pe(s) : null,
      o = n.x + n.width / 2 - r.width / 2,
      l = n.y + n.height / 2 - r.height / 2;
    switch (i) {
      case mt:
        e = { x: o, y: n.y - r.height };
        break;
      case gt:
        e = { x: o, y: n.y + n.height };
        break;
      case vt:
        e = { x: n.x + n.width, y: l };
        break;
      case yt:
        e = { x: n.x - r.width, y: l };
        break;
      default:
        e = { x: n.x, y: n.y };
    }
    var c = i ? ae(i) : null;
    if (null != c) {
      var u = "y" === c ? "height" : "width";
      switch (a) {
        case wt:
          e[c] = e[c] - (n[u] / 2 - r[u] / 2);
          break;
        case St:
          e[c] = e[c] + (n[u] / 2 - r[u] / 2);
      }
    }
    return e;
  }
  function Me(t, e) {
    void 0 === e && (e = {});
    var n = e,
      r = n.placement,
      s = void 0 === r ? t.placement : r,
      i = n.strategy,
      a = void 0 === i ? t.strategy : i,
      o = n.boundary,
      l = void 0 === o ? Ct : o,
      c = n.rootBoundary,
      u = void 0 === c ? xt : c,
      p = n.elementContext,
      d = void 0 === p ? kt : p,
      f = n.altBoundary,
      h = void 0 !== f && f,
      m = n.padding,
      g = void 0 === m ? 0 : m,
      v = le("number" != typeof g ? g : ce(g, _t)),
      y = d === kt ? Et : kt,
      b = t.rects.popper,
      _ = t.elements[h ? y : d],
      w = (function (t, e, n, r) {
        var s =
            "clippingParents" === e
              ? (function (t) {
                  var e = ke(re(t)),
                    n =
                      ["absolute", "fixed"].indexOf(te(t).position) >= 0 &&
                      qt(t)
                        ? ie(t)
                        : t;
                  return zt(n)
                    ? e.filter(function (t) {
                        return zt(t) && Zt(t, n) && "body" !== Ht(t);
                      })
                    : [];
                })(t)
              : [].concat(e),
          i = [].concat(s, [n]),
          a = i[0],
          o = i.reduce(function (e, n) {
            var s = Te(t, n, r);
            return (
              (e.top = Ut(s.top, e.top)),
              (e.right = Gt(s.right, e.right)),
              (e.bottom = Gt(s.bottom, e.bottom)),
              (e.left = Ut(s.left, e.left)),
              e
            );
          }, Te(t, a, r));
        return (
          (o.width = o.right - o.left),
          (o.height = o.bottom - o.top),
          (o.x = o.left),
          (o.y = o.top),
          o
        );
      })(zt(_) ? _ : _.contextElement || ne(t.elements.popper), l, u, a),
      S = Qt(t.elements.reference),
      C = Pe({ reference: S, element: b, strategy: "absolute", placement: s }),
      x = Ee(Object.assign({}, b, C)),
      k = d === kt ? x : S,
      E = {
        top: w.top - k.top + v.top,
        bottom: k.bottom - w.bottom + v.bottom,
        left: w.left - k.left + v.left,
        right: k.right - w.right + v.right,
      },
      T = t.modifiersData.offset;
    if (d === kt && T) {
      var P = T[s];
      Object.keys(E).forEach(function (t) {
        var e = [vt, gt].indexOf(t) >= 0 ? 1 : -1,
          n = [mt, gt].indexOf(t) >= 0 ? "y" : "x";
        E[t] += P[n] * e;
      });
    }
    return E;
  }
  const Oe = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e = t.state,
        n = t.options,
        r = t.name;
      if (!e.modifiersData[r]._skip) {
        for (
          var s = n.mainAxis,
            i = void 0 === s || s,
            a = n.altAxis,
            o = void 0 === a || a,
            l = n.fallbackPlacements,
            c = n.padding,
            u = n.boundary,
            p = n.rootBoundary,
            d = n.altBoundary,
            f = n.flipVariations,
            h = void 0 === f || f,
            m = n.allowedAutoPlacements,
            g = e.options.placement,
            v = Wt(g),
            y =
              l ||
              (v !== g && h
                ? (function (t) {
                    if (Wt(t) === bt) return [];
                    var e = ye(t);
                    return [_e(t), e, _e(e)];
                  })(g)
                : [ye(g)]),
            b = [g].concat(y).reduce(function (t, n) {
              return t.concat(
                Wt(n) === bt
                  ? (function (t, e) {
                      void 0 === e && (e = {});
                      var n = e,
                        r = n.placement,
                        s = n.boundary,
                        i = n.rootBoundary,
                        a = n.padding,
                        o = n.flipVariations,
                        l = n.allowedAutoPlacements,
                        c = void 0 === l ? Pt : l,
                        u = pe(r),
                        p = u
                          ? o
                            ? Tt
                            : Tt.filter(function (t) {
                                return pe(t) === u;
                              })
                          : _t,
                        d = p.filter(function (t) {
                          return c.indexOf(t) >= 0;
                        });
                      0 === d.length && (d = p);
                      var f = d.reduce(function (e, n) {
                        return (
                          (e[n] = Me(t, {
                            placement: n,
                            boundary: s,
                            rootBoundary: i,
                            padding: a,
                          })[Wt(n)]),
                          e
                        );
                      }, {});
                      return Object.keys(f).sort(function (t, e) {
                        return f[t] - f[e];
                      });
                    })(e, {
                      placement: n,
                      boundary: u,
                      rootBoundary: p,
                      padding: c,
                      flipVariations: h,
                      allowedAutoPlacements: m,
                    })
                  : n
              );
            }, []),
            _ = e.rects.reference,
            w = e.rects.popper,
            S = new Map(),
            C = !0,
            x = b[0],
            k = 0;
          k < b.length;
          k++
        ) {
          var E = b[k],
            T = Wt(E),
            P = pe(E) === wt,
            M = [mt, gt].indexOf(T) >= 0,
            O = M ? "width" : "height",
            A = Me(e, {
              placement: E,
              boundary: u,
              rootBoundary: p,
              altBoundary: d,
              padding: c,
            }),
            j = M ? (P ? vt : yt) : P ? gt : mt;
          _[O] > w[O] && (j = ye(j));
          var $ = ye(j),
            D = [];
          if (
            (i && D.push(A[T] <= 0),
            o && D.push(A[j] <= 0, A[$] <= 0),
            D.every(function (t) {
              return t;
            }))
          ) {
            (x = E), (C = !1);
            break;
          }
          S.set(E, D);
        }
        if (C)
          for (
            var I = function (t) {
                var e = b.find(function (e) {
                  var n = S.get(e);
                  if (n)
                    return n.slice(0, t).every(function (t) {
                      return t;
                    });
                });
                if (e) return (x = e), "break";
              },
              L = h ? 3 : 1;
            L > 0 && "break" !== I(L);
            L--
          );
        e.placement !== x &&
          ((e.modifiersData[r]._skip = !0), (e.placement = x), (e.reset = !0));
      }
    },
    requiresIfExists: ["offset"],
    data: { _skip: !1 },
  };
  function Ae(t, e, n) {
    return (
      void 0 === n && (n = { x: 0, y: 0 }),
      {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x,
      }
    );
  }
  function je(t) {
    return [mt, vt, gt, yt].some(function (e) {
      return t[e] >= 0;
    });
  }
  const $e = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (t) {
        var e = t.state,
          n = t.name,
          r = e.rects.reference,
          s = e.rects.popper,
          i = e.modifiersData.preventOverflow,
          a = Me(e, { elementContext: "reference" }),
          o = Me(e, { altBoundary: !0 }),
          l = Ae(a, r),
          c = Ae(o, s, i),
          u = je(l),
          p = je(c);
        (e.modifiersData[n] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: u,
          hasPopperEscaped: p,
        }),
          (e.attributes.popper = Object.assign({}, e.attributes.popper, {
            "data-popper-reference-hidden": u,
            "data-popper-escaped": p,
          }));
      },
    },
    De = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (t) {
        var e = t.state,
          n = t.options,
          r = t.name,
          s = n.offset,
          i = void 0 === s ? [0, 0] : s,
          a = Pt.reduce(function (t, n) {
            return (
              (t[n] = (function (t, e, n) {
                var r = Wt(t),
                  s = [yt, mt].indexOf(r) >= 0 ? -1 : 1,
                  i =
                    "function" == typeof n
                      ? n(Object.assign({}, e, { placement: t }))
                      : n,
                  a = i[0],
                  o = i[1];
                return (
                  (a = a || 0),
                  (o = (o || 0) * s),
                  [yt, vt].indexOf(r) >= 0 ? { x: o, y: a } : { x: a, y: o }
                );
              })(n, e.rects, i)),
              t
            );
          }, {}),
          o = a[e.placement],
          l = o.x,
          c = o.y;
        null != e.modifiersData.popperOffsets &&
          ((e.modifiersData.popperOffsets.x += l),
          (e.modifiersData.popperOffsets.y += c)),
          (e.modifiersData[r] = a);
      },
    },
    Ie = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (t) {
        var e = t.state,
          n = t.name;
        e.modifiersData[n] = Pe({
          reference: e.rects.reference,
          element: e.rects.popper,
          strategy: "absolute",
          placement: e.placement,
        });
      },
      data: {},
    },
    Le = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e = t.state,
          n = t.options,
          r = t.name,
          s = n.mainAxis,
          i = void 0 === s || s,
          a = n.altAxis,
          o = void 0 !== a && a,
          l = n.boundary,
          c = n.rootBoundary,
          u = n.altBoundary,
          p = n.padding,
          d = n.tether,
          f = void 0 === d || d,
          h = n.tetherOffset,
          m = void 0 === h ? 0 : h,
          g = Me(e, {
            boundary: l,
            rootBoundary: c,
            padding: p,
            altBoundary: u,
          }),
          v = Wt(e.placement),
          y = pe(e.placement),
          b = !y,
          _ = ae(v),
          w = "x" === _ ? "y" : "x",
          S = e.modifiersData.popperOffsets,
          C = e.rects.reference,
          x = e.rects.popper,
          k =
            "function" == typeof m
              ? m(Object.assign({}, e.rects, { placement: e.placement }))
              : m,
          E =
            "number" == typeof k
              ? { mainAxis: k, altAxis: k }
              : Object.assign({ mainAxis: 0, altAxis: 0 }, k),
          T = e.modifiersData.offset
            ? e.modifiersData.offset[e.placement]
            : null,
          P = { x: 0, y: 0 };
        if (S) {
          if (i) {
            var M,
              O = "y" === _ ? mt : yt,
              A = "y" === _ ? gt : vt,
              j = "y" === _ ? "height" : "width",
              $ = S[_],
              D = $ + g[O],
              I = $ - g[A],
              L = f ? -x[j] / 2 : 0,
              V = y === wt ? C[j] : x[j],
              N = y === wt ? -x[j] : -C[j],
              H = e.elements.arrow,
              R = f && H ? Jt(H) : { width: 0, height: 0 },
              z = e.modifiersData["arrow#persistent"]
                ? e.modifiersData["arrow#persistent"].padding
                : { top: 0, right: 0, bottom: 0, left: 0 },
              q = z[O],
              B = z[A],
              F = oe(0, C[j], R[j]),
              W = b
                ? C[j] / 2 - L - F - q - E.mainAxis
                : V - F - q - E.mainAxis,
              U = b
                ? -C[j] / 2 + L + F + B + E.mainAxis
                : N + F + B + E.mainAxis,
              G = e.elements.arrow && ie(e.elements.arrow),
              Y = G ? ("y" === _ ? G.clientTop || 0 : G.clientLeft || 0) : 0,
              X = null != (M = null == T ? void 0 : T[_]) ? M : 0,
              K = $ + U - X,
              Q = oe(f ? Gt(D, $ + W - X - Y) : D, $, f ? Ut(I, K) : I);
            (S[_] = Q), (P[_] = Q - $);
          }
          if (o) {
            var J,
              Z = "x" === _ ? mt : yt,
              tt = "x" === _ ? gt : vt,
              et = S[w],
              nt = "y" === w ? "height" : "width",
              rt = et + g[Z],
              st = et - g[tt],
              it = -1 !== [mt, yt].indexOf(v),
              at = null != (J = null == T ? void 0 : T[w]) ? J : 0,
              ot = it ? rt : et - C[nt] - x[nt] - at + E.altAxis,
              lt = it ? et + C[nt] + x[nt] - at - E.altAxis : st,
              ct =
                f && it
                  ? (function (t, e, n) {
                      var r = oe(t, e, n);
                      return r > n ? n : r;
                    })(ot, et, lt)
                  : oe(f ? ot : rt, et, f ? lt : st);
            (S[w] = ct), (P[w] = ct - et);
          }
          e.modifiersData[r] = P;
        }
      },
      requiresIfExists: ["offset"],
    };
  function Ve(t, e, n) {
    void 0 === n && (n = !1);
    var r,
      s,
      i = qt(e),
      a =
        qt(e) &&
        (function (t) {
          var e = t.getBoundingClientRect(),
            n = Yt(e.width) / t.offsetWidth || 1,
            r = Yt(e.height) / t.offsetHeight || 1;
          return 1 !== n || 1 !== r;
        })(e),
      o = ne(e),
      l = Qt(t, a, n),
      c = { scrollLeft: 0, scrollTop: 0 },
      u = { x: 0, y: 0 };
    return (
      (i || (!i && !n)) &&
        (("body" !== Ht(e) || Ce(o)) &&
          (c =
            (r = e) !== Rt(r) && qt(r)
              ? { scrollLeft: (s = r).scrollLeft, scrollTop: s.scrollTop }
              : we(r)),
        qt(e)
          ? (((u = Qt(e, !0)).x += e.clientLeft), (u.y += e.clientTop))
          : o && (u.x = Se(o))),
      {
        x: l.left + c.scrollLeft - u.x,
        y: l.top + c.scrollTop - u.y,
        width: l.width,
        height: l.height,
      }
    );
  }
  function Ne(t) {
    var e = new Map(),
      n = new Set(),
      r = [];
    function s(t) {
      n.add(t.name),
        []
          .concat(t.requires || [], t.requiresIfExists || [])
          .forEach(function (t) {
            if (!n.has(t)) {
              var r = e.get(t);
              r && s(r);
            }
          }),
        r.push(t);
    }
    return (
      t.forEach(function (t) {
        e.set(t.name, t);
      }),
      t.forEach(function (t) {
        n.has(t.name) || s(t);
      }),
      r
    );
  }
  var He = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function Re() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return !e.some(function (t) {
      return !(t && "function" == typeof t.getBoundingClientRect);
    });
  }
  function ze(t) {
    void 0 === t && (t = {});
    var e = t,
      n = e.defaultModifiers,
      r = void 0 === n ? [] : n,
      s = e.defaultOptions,
      i = void 0 === s ? He : s;
    return function (t, e, n) {
      void 0 === n && (n = i);
      var s,
        a,
        o = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, He, i),
          modifiersData: {},
          elements: { reference: t, popper: e },
          attributes: {},
          styles: {},
        },
        l = [],
        c = !1,
        u = {
          state: o,
          setOptions: function (n) {
            var s = "function" == typeof n ? n(o.options) : n;
            p(),
              (o.options = Object.assign({}, i, o.options, s)),
              (o.scrollParents = {
                reference: zt(t)
                  ? ke(t)
                  : t.contextElement
                  ? ke(t.contextElement)
                  : [],
                popper: ke(e),
              });
            var a,
              c,
              d = (function (t) {
                var e = Ne(t);
                return Nt.reduce(function (t, n) {
                  return t.concat(
                    e.filter(function (t) {
                      return t.phase === n;
                    })
                  );
                }, []);
              })(
                ((a = [].concat(r, o.options.modifiers)),
                (c = a.reduce(function (t, e) {
                  var n = t[e.name];
                  return (
                    (t[e.name] = n
                      ? Object.assign({}, n, e, {
                          options: Object.assign({}, n.options, e.options),
                          data: Object.assign({}, n.data, e.data),
                        })
                      : e),
                    t
                  );
                }, {})),
                Object.keys(c).map(function (t) {
                  return c[t];
                }))
              );
            return (
              (o.orderedModifiers = d.filter(function (t) {
                return t.enabled;
              })),
              o.orderedModifiers.forEach(function (t) {
                var e = t.name,
                  n = t.options,
                  r = void 0 === n ? {} : n,
                  s = t.effect;
                if ("function" == typeof s) {
                  var i = s({ state: o, name: e, instance: u, options: r });
                  l.push(i || function () {});
                }
              }),
              u.update()
            );
          },
          forceUpdate: function () {
            if (!c) {
              var t = o.elements,
                e = t.reference,
                n = t.popper;
              if (Re(e, n)) {
                (o.rects = {
                  reference: Ve(e, ie(n), "fixed" === o.options.strategy),
                  popper: Jt(n),
                }),
                  (o.reset = !1),
                  (o.placement = o.options.placement),
                  o.orderedModifiers.forEach(function (t) {
                    return (o.modifiersData[t.name] = Object.assign(
                      {},
                      t.data
                    ));
                  });
                for (var r = 0; r < o.orderedModifiers.length; r++)
                  if (!0 !== o.reset) {
                    var s = o.orderedModifiers[r],
                      i = s.fn,
                      a = s.options,
                      l = void 0 === a ? {} : a,
                      p = s.name;
                    "function" == typeof i &&
                      (o =
                        i({ state: o, options: l, name: p, instance: u }) || o);
                  } else (o.reset = !1), (r = -1);
              }
            }
          },
          update:
            ((s = function () {
              return new Promise(function (t) {
                u.forceUpdate(), t(o);
              });
            }),
            function () {
              return (
                a ||
                  (a = new Promise(function (t) {
                    Promise.resolve().then(function () {
                      (a = void 0), t(s());
                    });
                  })),
                a
              );
            }),
          destroy: function () {
            p(), (c = !0);
          },
        };
      if (!Re(t, e)) return u;
      function p() {
        l.forEach(function (t) {
          return t();
        }),
          (l = []);
      }
      return (
        u.setOptions(n).then(function (t) {
          !c && n.onFirstUpdate && n.onFirstUpdate(t);
        }),
        u
      );
    };
  }
  var qe = ze(),
    Be = ze({ defaultModifiers: [ge, Ie, he, Ft] }),
    Fe = ze({ defaultModifiers: [ge, Ie, he, Ft, De, Oe, Le, ue, $e] });
  const We = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          popperGenerator: ze,
          detectOverflow: Me,
          createPopperBase: qe,
          createPopper: Fe,
          createPopperLite: Be,
          top: mt,
          bottom: gt,
          right: vt,
          left: yt,
          auto: bt,
          basePlacements: _t,
          start: wt,
          end: St,
          clippingParents: Ct,
          viewport: xt,
          popper: kt,
          reference: Et,
          variationPlacements: Tt,
          placements: Pt,
          beforeRead: Mt,
          read: Ot,
          afterRead: At,
          beforeMain: jt,
          main: $t,
          afterMain: Dt,
          beforeWrite: It,
          write: Lt,
          afterWrite: Vt,
          modifierPhases: Nt,
          applyStyles: Ft,
          arrow: ue,
          computeStyles: he,
          eventListeners: ge,
          flip: Oe,
          hide: $e,
          offset: De,
          popperOffsets: Ie,
          preventOverflow: Le,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    Ue = "dropdown",
    Ge = "ArrowUp",
    Ye = "ArrowDown",
    Xe = "click.bs.dropdown.data-api",
    Ke = "keydown.bs.dropdown.data-api",
    Qe = "show",
    Je = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    Ze = `${Je}.show`,
    tn = ".dropdown-menu",
    en = h() ? "top-end" : "top-start",
    nn = h() ? "top-start" : "top-end",
    rn = h() ? "bottom-end" : "bottom-start",
    sn = h() ? "bottom-start" : "bottom-end",
    an = h() ? "left-start" : "right-start",
    on = h() ? "right-start" : "left-start",
    ln = {
      autoClose: !0,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle",
    },
    cn = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)",
    };
  class un extends q {
    constructor(t, e) {
      super(t, e),
        (this._popper = null),
        (this._parent = this._element.parentNode),
        (this._menu =
          G.next(this._element, tn)[0] ||
          G.prev(this._element, tn)[0] ||
          G.findOne(tn, this._parent)),
        (this._inNavbar = this._detectNavbar());
    }
    static get Default() {
      return ln;
    }
    static get DefaultType() {
      return cn;
    }
    static get NAME() {
      return Ue;
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (l(this._element) || this._isShown()) return;
      const t = { relatedTarget: this._element };
      if (!D.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
        if (
          (this._createPopper(),
          "ontouchstart" in document.documentElement &&
            !this._parent.closest(".navbar-nav"))
        )
          for (const t of [].concat(...document.body.children))
            D.on(t, "mouseover", u);
        this._element.focus(),
          this._element.setAttribute("aria-expanded", !0),
          this._menu.classList.add(Qe),
          this._element.classList.add(Qe),
          D.trigger(this._element, "shown.bs.dropdown", t);
      }
    }
    hide() {
      if (l(this._element) || !this._isShown()) return;
      const t = { relatedTarget: this._element };
      this._completeHide(t);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      (this._inNavbar = this._detectNavbar()),
        this._popper && this._popper.update();
    }
    _completeHide(t) {
      if (!D.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement)
          for (const t of [].concat(...document.body.children))
            D.off(t, "mouseover", u);
        this._popper && this._popper.destroy(),
          this._menu.classList.remove(Qe),
          this._element.classList.remove(Qe),
          this._element.setAttribute("aria-expanded", "false"),
          R.removeDataAttribute(this._menu, "popper"),
          D.trigger(this._element, "hidden.bs.dropdown", t);
      }
    }
    _getConfig(t) {
      if (
        "object" == typeof (t = super._getConfig(t)).reference &&
        !i(t.reference) &&
        "function" != typeof t.reference.getBoundingClientRect
      )
        throw new TypeError(
          `${Ue.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
        );
      return t;
    }
    _createPopper() {
      if (void 0 === We)
        throw new TypeError(
          "Bootstrap's dropdowns require Popper (https://popper.js.org)"
        );
      let t = this._element;
      "parent" === this._config.reference
        ? (t = this._parent)
        : i(this._config.reference)
        ? (t = a(this._config.reference))
        : "object" == typeof this._config.reference &&
          (t = this._config.reference);
      const e = this._getPopperConfig();
      this._popper = Fe(t, this._menu, e);
    }
    _isShown() {
      return this._menu.classList.contains(Qe);
    }
    _getPlacement() {
      const t = this._parent;
      if (t.classList.contains("dropend")) return an;
      if (t.classList.contains("dropstart")) return on;
      if (t.classList.contains("dropup-center")) return "top";
      if (t.classList.contains("dropdown-center")) return "bottom";
      const e =
        "end" ===
        getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? (e ? nn : en) : e ? sn : rn;
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }
    _getOffset() {
      const { offset: t } = this._config;
      return "string" == typeof t
        ? t.split(",").map((t) => Number.parseInt(t, 10))
        : "function" == typeof t
        ? (e) => t(e, this._element)
        : t;
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [
          {
            name: "preventOverflow",
            options: { boundary: this._config.boundary },
          },
          { name: "offset", options: { offset: this._getOffset() } },
        ],
      };
      return (
        (this._inNavbar || "static" === this._config.display) &&
          (R.setDataAttribute(this._menu, "popper", "static"),
          (t.modifiers = [{ name: "applyStyles", enabled: !1 }])),
        {
          ...t,
          ...("function" == typeof this._config.popperConfig
            ? this._config.popperConfig(t)
            : this._config.popperConfig),
        }
      );
    }
    _selectMenuItem({ key: t, target: e }) {
      const n = G.find(
        ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
        this._menu
      ).filter((t) => o(t));
      n.length && y(n, e, t === Ye, !n.includes(e)).focus();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = un.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
    static clearMenus(t) {
      if (2 === t.button || ("keyup" === t.type && "Tab" !== t.key)) return;
      const e = G.find(Ze);
      for (const n of e) {
        const e = un.getInstance(n);
        if (!e || !1 === e._config.autoClose) continue;
        const r = t.composedPath(),
          s = r.includes(e._menu);
        if (
          r.includes(e._element) ||
          ("inside" === e._config.autoClose && !s) ||
          ("outside" === e._config.autoClose && s)
        )
          continue;
        if (
          e._menu.contains(t.target) &&
          (("keyup" === t.type && "Tab" === t.key) ||
            /input|select|option|textarea|form/i.test(t.target.tagName))
        )
          continue;
        const i = { relatedTarget: e._element };
        "click" === t.type && (i.clickEvent = t), e._completeHide(i);
      }
    }
    static dataApiKeydownHandler(t) {
      const e = /input|textarea/i.test(t.target.tagName),
        n = "Escape" === t.key,
        r = [Ge, Ye].includes(t.key);
      if (!r && !n) return;
      if (e && !n) return;
      t.preventDefault();
      const s = this.matches(Je)
          ? this
          : G.prev(this, Je)[0] ||
            G.next(this, Je)[0] ||
            G.findOne(Je, t.delegateTarget.parentNode),
        i = un.getOrCreateInstance(s);
      if (r) return t.stopPropagation(), i.show(), void i._selectMenuItem(t);
      i._isShown() && (t.stopPropagation(), i.hide(), s.focus());
    }
  }
  D.on(document, Ke, Je, un.dataApiKeydownHandler),
    D.on(document, Ke, tn, un.dataApiKeydownHandler),
    D.on(document, Xe, un.clearMenus),
    D.on(document, "keyup.bs.dropdown.data-api", un.clearMenus),
    D.on(document, Xe, Je, function (t) {
      t.preventDefault(), un.getOrCreateInstance(this).toggle();
    }),
    m(un);
  const pn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    dn = ".sticky-top",
    fn = "padding-right",
    hn = "margin-right";
  class mn {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      const t = this.getWidth();
      this._disableOverFlow(),
        this._setElementAttributes(this._element, fn, (e) => e + t),
        this._setElementAttributes(pn, fn, (e) => e + t),
        this._setElementAttributes(dn, hn, (e) => e - t);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"),
        this._resetElementAttributes(this._element, fn),
        this._resetElementAttributes(pn, fn),
        this._resetElementAttributes(dn, hn);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"),
        (this._element.style.overflow = "hidden");
    }
    _setElementAttributes(t, e, n) {
      const r = this.getWidth();
      this._applyManipulationCallback(t, (t) => {
        if (t !== this._element && window.innerWidth > t.clientWidth + r)
          return;
        this._saveInitialAttribute(t, e);
        const s = window.getComputedStyle(t).getPropertyValue(e);
        t.style.setProperty(e, `${n(Number.parseFloat(s))}px`);
      });
    }
    _saveInitialAttribute(t, e) {
      const n = t.style.getPropertyValue(e);
      n && R.setDataAttribute(t, e, n);
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, (t) => {
        const n = R.getDataAttribute(t, e);
        null !== n
          ? (R.removeDataAttribute(t, e), t.style.setProperty(e, n))
          : t.style.removeProperty(e);
      });
    }
    _applyManipulationCallback(t, e) {
      if (i(t)) e(t);
      else for (const n of G.find(t, this._element)) e(n);
    }
  }
  const gn = "show",
    vn = "mousedown.bs.backdrop",
    yn = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: !1,
      isVisible: !0,
      rootElement: "body",
    },
    bn = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)",
    };
  class _n extends z {
    constructor(t) {
      super(),
        (this._config = this._getConfig(t)),
        (this._isAppended = !1),
        (this._element = null);
    }
    static get Default() {
      return yn;
    }
    static get DefaultType() {
      return bn;
    }
    static get NAME() {
      return "backdrop";
    }
    show(t) {
      if (!this._config.isVisible) return void g(t);
      this._append();
      const e = this._getElement();
      this._config.isAnimated && p(e),
        e.classList.add(gn),
        this._emulateAnimation(() => {
          g(t);
        });
    }
    hide(t) {
      this._config.isVisible
        ? (this._getElement().classList.remove(gn),
          this._emulateAnimation(() => {
            this.dispose(), g(t);
          }))
        : g(t);
    }
    dispose() {
      this._isAppended &&
        (D.off(this._element, vn),
        this._element.remove(),
        (this._isAppended = !1));
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        (t.className = this._config.className),
          this._config.isAnimated && t.classList.add("fade"),
          (this._element = t);
      }
      return this._element;
    }
    _configAfterMerge(t) {
      return (t.rootElement = a(t.rootElement)), t;
    }
    _append() {
      if (this._isAppended) return;
      const t = this._getElement();
      this._config.rootElement.append(t),
        D.on(t, vn, () => {
          g(this._config.clickCallback);
        }),
        (this._isAppended = !0);
    }
    _emulateAnimation(t) {
      v(t, this._getElement(), this._config.isAnimated);
    }
  }
  const wn = ".bs.focustrap",
    Sn = "backward",
    Cn = { autofocus: !0, trapElement: null },
    xn = { autofocus: "boolean", trapElement: "element" };
  class kn extends z {
    constructor(t) {
      super(),
        (this._config = this._getConfig(t)),
        (this._isActive = !1),
        (this._lastTabNavDirection = null);
    }
    static get Default() {
      return Cn;
    }
    static get DefaultType() {
      return xn;
    }
    static get NAME() {
      return "focustrap";
    }
    activate() {
      this._isActive ||
        (this._config.autofocus && this._config.trapElement.focus(),
        D.off(document, wn),
        D.on(document, "focusin.bs.focustrap", (t) => this._handleFocusin(t)),
        D.on(document, "keydown.tab.bs.focustrap", (t) =>
          this._handleKeydown(t)
        ),
        (this._isActive = !0));
    }
    deactivate() {
      this._isActive && ((this._isActive = !1), D.off(document, wn));
    }
    _handleFocusin(t) {
      const { trapElement: e } = this._config;
      if (t.target === document || t.target === e || e.contains(t.target))
        return;
      const n = G.focusableChildren(e);
      0 === n.length
        ? e.focus()
        : this._lastTabNavDirection === Sn
        ? n[n.length - 1].focus()
        : n[0].focus();
    }
    _handleKeydown(t) {
      "Tab" === t.key &&
        (this._lastTabNavDirection = t.shiftKey ? Sn : "forward");
    }
  }
  const En = "hidden.bs.modal",
    Tn = "show.bs.modal",
    Pn = "modal-open",
    Mn = "show",
    On = "modal-static",
    An = { backdrop: !0, focus: !0, keyboard: !0 },
    jn = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean",
    };
  class $n extends q {
    constructor(t, e) {
      super(t, e),
        (this._dialog = G.findOne(".modal-dialog", this._element)),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        (this._isShown = !1),
        (this._isTransitioning = !1),
        (this._scrollBar = new mn()),
        this._addEventListeners();
    }
    static get Default() {
      return An;
    }
    static get DefaultType() {
      return jn;
    }
    static get NAME() {
      return "modal";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown ||
        this._isTransitioning ||
        D.trigger(this._element, Tn, { relatedTarget: t }).defaultPrevented ||
        ((this._isShown = !0),
        (this._isTransitioning = !0),
        this._scrollBar.hide(),
        document.body.classList.add(Pn),
        this._adjustDialog(),
        this._backdrop.show(() => this._showElement(t)));
    }
    hide() {
      this._isShown &&
        !this._isTransitioning &&
        (D.trigger(this._element, "hide.bs.modal").defaultPrevented ||
          ((this._isShown = !1),
          (this._isTransitioning = !0),
          this._focustrap.deactivate(),
          this._element.classList.remove(Mn),
          this._queueCallback(
            () => this._hideModal(),
            this._element,
            this._isAnimated()
          )));
    }
    dispose() {
      for (const t of [window, this._dialog]) D.off(t, ".bs.modal");
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new _n({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated(),
      });
    }
    _initializeFocusTrap() {
      return new kn({ trapElement: this._element });
    }
    _showElement(t) {
      document.body.contains(this._element) ||
        document.body.append(this._element),
        (this._element.style.display = "block"),
        this._element.removeAttribute("aria-hidden"),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        (this._element.scrollTop = 0);
      const e = G.findOne(".modal-body", this._dialog);
      e && (e.scrollTop = 0),
        p(this._element),
        this._element.classList.add(Mn),
        this._queueCallback(
          () => {
            this._config.focus && this._focustrap.activate(),
              (this._isTransitioning = !1),
              D.trigger(this._element, "shown.bs.modal", { relatedTarget: t });
          },
          this._dialog,
          this._isAnimated()
        );
    }
    _addEventListeners() {
      D.on(this._element, "keydown.dismiss.bs.modal", (t) => {
        if ("Escape" === t.key)
          return this._config.keyboard
            ? (t.preventDefault(), void this.hide())
            : void this._triggerBackdropTransition();
      }),
        D.on(window, "resize.bs.modal", () => {
          this._isShown && !this._isTransitioning && this._adjustDialog();
        }),
        D.on(this._element, "mousedown.dismiss.bs.modal", (t) => {
          D.one(this._element, "click.dismiss.bs.modal", (e) => {
            this._element === t.target &&
              this._element === e.target &&
              ("static" !== this._config.backdrop
                ? this._config.backdrop && this.hide()
                : this._triggerBackdropTransition());
          });
        });
    }
    _hideModal() {
      (this._element.style.display = "none"),
        this._element.setAttribute("aria-hidden", !0),
        this._element.removeAttribute("aria-modal"),
        this._element.removeAttribute("role"),
        (this._isTransitioning = !1),
        this._backdrop.hide(() => {
          document.body.classList.remove(Pn),
            this._resetAdjustments(),
            this._scrollBar.reset(),
            D.trigger(this._element, En);
        });
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (D.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented)
        return;
      const t =
          this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._element.style.overflowY;
      "hidden" === e ||
        this._element.classList.contains(On) ||
        (t || (this._element.style.overflowY = "hidden"),
        this._element.classList.add(On),
        this._queueCallback(() => {
          this._element.classList.remove(On),
            this._queueCallback(() => {
              this._element.style.overflowY = e;
            }, this._dialog);
        }, this._dialog),
        this._element.focus());
    }
    _adjustDialog() {
      const t =
          this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        n = e > 0;
      if (n && !t) {
        const t = h() ? "paddingLeft" : "paddingRight";
        this._element.style[t] = `${e}px`;
      }
      if (!n && t) {
        const t = h() ? "paddingRight" : "paddingLeft";
        this._element.style[t] = `${e}px`;
      }
    }
    _resetAdjustments() {
      (this._element.style.paddingLeft = ""),
        (this._element.style.paddingRight = "");
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        const n = $n.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === n[t]) throw new TypeError(`No method named "${t}"`);
          n[t](e);
        }
      });
    }
  }
  D.on(
    document,
    "click.bs.modal.data-api",
    '[data-bs-toggle="modal"]',
    function (t) {
      const e = r(this);
      ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
        D.one(e, Tn, (t) => {
          t.defaultPrevented ||
            D.one(e, En, () => {
              o(this) && this.focus();
            });
        });
      const n = G.findOne(".modal.show");
      n && $n.getInstance(n).hide(), $n.getOrCreateInstance(e).toggle(this);
    }
  ),
    B($n),
    m($n);
  const Dn = "show",
    In = "showing",
    Ln = "hiding",
    Vn = ".offcanvas.show",
    Nn = "hidePrevented.bs.offcanvas",
    Hn = "hidden.bs.offcanvas",
    Rn = { backdrop: !0, keyboard: !0, scroll: !1 },
    zn = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean",
    };
  class qn extends q {
    constructor(t, e) {
      super(t, e),
        (this._isShown = !1),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        this._addEventListeners();
    }
    static get Default() {
      return Rn;
    }
    static get DefaultType() {
      return zn;
    }
    static get NAME() {
      return "offcanvas";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown ||
        D.trigger(this._element, "show.bs.offcanvas", { relatedTarget: t })
          .defaultPrevented ||
        ((this._isShown = !0),
        this._backdrop.show(),
        this._config.scroll || new mn().hide(),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        this._element.classList.add(In),
        this._queueCallback(
          () => {
            (this._config.scroll && !this._config.backdrop) ||
              this._focustrap.activate(),
              this._element.classList.add(Dn),
              this._element.classList.remove(In),
              D.trigger(this._element, "shown.bs.offcanvas", {
                relatedTarget: t,
              });
          },
          this._element,
          !0
        ));
    }
    hide() {
      this._isShown &&
        (D.trigger(this._element, "hide.bs.offcanvas").defaultPrevented ||
          (this._focustrap.deactivate(),
          this._element.blur(),
          (this._isShown = !1),
          this._element.classList.add(Ln),
          this._backdrop.hide(),
          this._queueCallback(
            () => {
              this._element.classList.remove(Dn, Ln),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || new mn().reset(),
                D.trigger(this._element, Hn);
            },
            this._element,
            !0
          )));
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    _initializeBackDrop() {
      const t = Boolean(this._config.backdrop);
      return new _n({
        className: "offcanvas-backdrop",
        isVisible: t,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: t
          ? () => {
              "static" !== this._config.backdrop
                ? this.hide()
                : D.trigger(this._element, Nn);
            }
          : null,
      });
    }
    _initializeFocusTrap() {
      return new kn({ trapElement: this._element });
    }
    _addEventListeners() {
      D.on(this._element, "keydown.dismiss.bs.offcanvas", (t) => {
        "Escape" === t.key &&
          (this._config.keyboard ? this.hide() : D.trigger(this._element, Nn));
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = qn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  D.on(
    document,
    "click.bs.offcanvas.data-api",
    '[data-bs-toggle="offcanvas"]',
    function (t) {
      const e = r(this);
      if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)))
        return;
      D.one(e, Hn, () => {
        o(this) && this.focus();
      });
      const n = G.findOne(Vn);
      n && n !== e && qn.getInstance(n).hide(),
        qn.getOrCreateInstance(e).toggle(this);
    }
  ),
    D.on(window, "load.bs.offcanvas.data-api", () => {
      for (const t of G.find(Vn)) qn.getOrCreateInstance(t).show();
    }),
    D.on(window, "resize.bs.offcanvas", () => {
      for (const t of G.find("[aria-modal][class*=show][class*=offcanvas-]"))
        "fixed" !== getComputedStyle(t).position &&
          qn.getOrCreateInstance(t).hide();
    }),
    B(qn),
    m(qn);
  const Bn = new Set([
      "background",
      "cite",
      "href",
      "itemtype",
      "longdesc",
      "poster",
      "src",
      "xlink:href",
    ]),
    Fn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    Wn =
      /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    Un = (t, e) => {
      const n = t.nodeName.toLowerCase();
      return e.includes(n)
        ? !Bn.has(n) || Boolean(Fn.test(t.nodeValue) || Wn.test(t.nodeValue))
        : e.filter((t) => t instanceof RegExp).some((t) => t.test(n));
    },
    Gn = {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: [],
    },
    Yn = {
      allowList: Gn,
      content: {},
      extraClass: "",
      html: !1,
      sanitize: !0,
      sanitizeFn: null,
      template: "<div></div>",
    },
    Xn = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string",
    },
    Kn = {
      entry: "(string|element|function|null)",
      selector: "(string|element)",
    };
  class Qn extends z {
    constructor(t) {
      super(), (this._config = this._getConfig(t));
    }
    static get Default() {
      return Yn;
    }
    static get DefaultType() {
      return Xn;
    }
    static get NAME() {
      return "TemplateFactory";
    }
    getContent() {
      return Object.values(this._config.content)
        .map((t) => this._resolvePossibleFunction(t))
        .filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(t) {
      return (
        this._checkContent(t),
        (this._config.content = { ...this._config.content, ...t }),
        this
      );
    }
    toHtml() {
      const t = document.createElement("div");
      t.innerHTML = this._maybeSanitize(this._config.template);
      for (const [e, n] of Object.entries(this._config.content))
        this._setContent(t, n, e);
      const e = t.children[0],
        n = this._resolvePossibleFunction(this._config.extraClass);
      return n && e.classList.add(...n.split(" ")), e;
    }
    _typeCheckConfig(t) {
      super._typeCheckConfig(t), this._checkContent(t.content);
    }
    _checkContent(t) {
      for (const [e, n] of Object.entries(t))
        super._typeCheckConfig({ selector: e, entry: n }, Kn);
    }
    _setContent(t, e, n) {
      const r = G.findOne(n, t);
      r &&
        ((e = this._resolvePossibleFunction(e)) && i(e)
          ? this._putElementInTemplate(a(e), r)
          : this._config.html
          ? (r.innerHTML = this._maybeSanitize(e))
          : (r.textContent = e)
        ).remove();
    }
    _maybeSanitize(t) {
      return this._config.sanitize
        ? (function (t, e, n) {
            if (!t.length) return t;
            if (n && "function" == typeof n) return n(t);
            const r = new window.DOMParser().parseFromString(t, "text/html"),
              s = [].concat(...r.body.querySelectorAll("*"));
            for (const t of s) {
              const n = t.nodeName.toLowerCase();
              if (!Object.keys(e).includes(n)) {
                t.remove();
                continue;
              }
              const r = [].concat(...t.attributes),
                s = [].concat(e["*"] || [], e[n] || []);
              for (const e of r) Un(e, s) || t.removeAttribute(e.nodeName);
            }
            return r.body.innerHTML;
          })(t, this._config.allowList, this._config.sanitizeFn)
        : t;
    }
    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t(this) : t;
    }
    _putElementInTemplate(t, e) {
      if (this._config.html) return (e.innerHTML = ""), void e.append(t);
      e.textContent = t.textContent;
    }
  }
  const Jn = new Set(["sanitize", "allowList", "sanitizeFn"]),
    Zn = "fade",
    tr = "show",
    er = ".modal",
    nr = "hide.bs.modal",
    rr = "hover",
    sr = "focus",
    ir = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: h() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: h() ? "right" : "left",
    },
    ar = {
      allowList: Gn,
      animation: !0,
      boundary: "clippingParents",
      container: !1,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: !1,
      offset: [0, 0],
      placement: "top",
      popperConfig: null,
      sanitize: !0,
      sanitizeFn: null,
      selector: !1,
      template:
        '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus",
    },
    or = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
    };
  class lr extends q {
    constructor(t, e) {
      if (void 0 === We)
        throw new TypeError(
          "Bootstrap's tooltips require Popper (https://popper.js.org)"
        );
      super(t, e),
        (this._isEnabled = !0),
        (this._timeout = 0),
        (this._isHovered = null),
        (this._activeTrigger = {}),
        (this._popper = null),
        (this._templateFactory = null),
        (this._newContent = null),
        (this.tip = null),
        this._setListeners(),
        this._config.selector || this._fixTitle();
    }
    static get Default() {
      return ar;
    }
    static get DefaultType() {
      return or;
    }
    static get NAME() {
      return "tooltip";
    }
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      this._isEnabled &&
        ((this._activeTrigger.click = !this._activeTrigger.click),
        this._isShown() ? this._leave() : this._enter());
    }
    dispose() {
      clearTimeout(this._timeout),
        D.off(this._element.closest(er), nr, this._hideModalHandler),
        this.tip && this.tip.remove(),
        this._element.getAttribute("data-bs-original-title") &&
          this._element.setAttribute(
            "title",
            this._element.getAttribute("data-bs-original-title")
          ),
        this._disposePopper(),
        super.dispose();
    }
    show() {
      if ("none" === this._element.style.display)
        throw new Error("Please use show on visible elements");
      if (!this._isWithContent() || !this._isEnabled) return;
      const t = D.trigger(this._element, this.constructor.eventName("show")),
        e = (
          c(this._element) || this._element.ownerDocument.documentElement
        ).contains(this._element);
      if (t.defaultPrevented || !e) return;
      this.tip && (this.tip.remove(), (this.tip = null));
      const n = this._getTipElement();
      this._element.setAttribute("aria-describedby", n.getAttribute("id"));
      const { container: r } = this._config;
      if (
        (this._element.ownerDocument.documentElement.contains(this.tip) ||
          (r.append(n),
          D.trigger(this._element, this.constructor.eventName("inserted"))),
        this._popper
          ? this._popper.update()
          : (this._popper = this._createPopper(n)),
        n.classList.add(tr),
        "ontouchstart" in document.documentElement)
      )
        for (const t of [].concat(...document.body.children))
          D.on(t, "mouseover", u);
      this._queueCallback(
        () => {
          D.trigger(this._element, this.constructor.eventName("shown")),
            !1 === this._isHovered && this._leave(),
            (this._isHovered = !1);
        },
        this.tip,
        this._isAnimated()
      );
    }
    hide() {
      if (!this._isShown()) return;
      if (
        D.trigger(this._element, this.constructor.eventName("hide"))
          .defaultPrevented
      )
        return;
      const t = this._getTipElement();
      if ((t.classList.remove(tr), "ontouchstart" in document.documentElement))
        for (const t of [].concat(...document.body.children))
          D.off(t, "mouseover", u);
      (this._activeTrigger.click = !1),
        (this._activeTrigger.focus = !1),
        (this._activeTrigger.hover = !1),
        (this._isHovered = null),
        this._queueCallback(
          () => {
            this._isWithActiveTrigger() ||
              (this._isHovered || t.remove(),
              this._element.removeAttribute("aria-describedby"),
              D.trigger(this._element, this.constructor.eventName("hidden")),
              this._disposePopper());
          },
          this.tip,
          this._isAnimated()
        );
    }
    update() {
      this._popper && this._popper.update();
    }
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      return (
        this.tip ||
          (this.tip = this._createTipElement(
            this._newContent || this._getContentForTemplate()
          )),
        this.tip
      );
    }
    _createTipElement(t) {
      const e = this._getTemplateFactory(t).toHtml();
      if (!e) return null;
      e.classList.remove(Zn, tr),
        e.classList.add(`bs-${this.constructor.NAME}-auto`);
      const n = ((t) => {
        do {
          t += Math.floor(1e6 * Math.random());
        } while (document.getElementById(t));
        return t;
      })(this.constructor.NAME).toString();
      return (
        e.setAttribute("id", n), this._isAnimated() && e.classList.add(Zn), e
      );
    }
    setContent(t) {
      (this._newContent = t),
        this._isShown() && (this._disposePopper(), this.show());
    }
    _getTemplateFactory(t) {
      return (
        this._templateFactory
          ? this._templateFactory.changeContent(t)
          : (this._templateFactory = new Qn({
              ...this._config,
              content: t,
              extraClass: this._resolvePossibleFunction(
                this._config.customClass
              ),
            })),
        this._templateFactory
      );
    }
    _getContentForTemplate() {
      return { ".tooltip-inner": this._getTitle() };
    }
    _getTitle() {
      return (
        this._resolvePossibleFunction(this._config.title) ||
        this._element.getAttribute("data-bs-original-title")
      );
    }
    _initializeOnDelegatedTarget(t) {
      return this.constructor.getOrCreateInstance(
        t.delegateTarget,
        this._getDelegateConfig()
      );
    }
    _isAnimated() {
      return (
        this._config.animation || (this.tip && this.tip.classList.contains(Zn))
      );
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(tr);
    }
    _createPopper(t) {
      const e =
          "function" == typeof this._config.placement
            ? this._config.placement.call(this, t, this._element)
            : this._config.placement,
        n = ir[e.toUpperCase()];
      return Fe(this._element, t, this._getPopperConfig(n));
    }
    _getOffset() {
      const { offset: t } = this._config;
      return "string" == typeof t
        ? t.split(",").map((t) => Number.parseInt(t, 10))
        : "function" == typeof t
        ? (e) => t(e, this._element)
        : t;
    }
    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t.call(this._element) : t;
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [
          {
            name: "flip",
            options: { fallbackPlacements: this._config.fallbackPlacements },
          },
          { name: "offset", options: { offset: this._getOffset() } },
          {
            name: "preventOverflow",
            options: { boundary: this._config.boundary },
          },
          {
            name: "arrow",
            options: { element: `.${this.constructor.NAME}-arrow` },
          },
          {
            name: "preSetPlacement",
            enabled: !0,
            phase: "beforeMain",
            fn: (t) => {
              this._getTipElement().setAttribute(
                "data-popper-placement",
                t.state.placement
              );
            },
          },
        ],
      };
      return {
        ...e,
        ...("function" == typeof this._config.popperConfig
          ? this._config.popperConfig(e)
          : this._config.popperConfig),
      };
    }
    _setListeners() {
      const t = this._config.trigger.split(" ");
      for (const e of t)
        if ("click" === e)
          D.on(
            this._element,
            this.constructor.eventName("click"),
            this._config.selector,
            (t) => {
              this._initializeOnDelegatedTarget(t).toggle();
            }
          );
        else if ("manual" !== e) {
          const t =
              e === rr
                ? this.constructor.eventName("mouseenter")
                : this.constructor.eventName("focusin"),
            n =
              e === rr
                ? this.constructor.eventName("mouseleave")
                : this.constructor.eventName("focusout");
          D.on(this._element, t, this._config.selector, (t) => {
            const e = this._initializeOnDelegatedTarget(t);
            (e._activeTrigger["focusin" === t.type ? sr : rr] = !0), e._enter();
          }),
            D.on(this._element, n, this._config.selector, (t) => {
              const e = this._initializeOnDelegatedTarget(t);
              (e._activeTrigger["focusout" === t.type ? sr : rr] =
                e._element.contains(t.relatedTarget)),
                e._leave();
            });
        }
      (this._hideModalHandler = () => {
        this._element && this.hide();
      }),
        D.on(this._element.closest(er), nr, this._hideModalHandler);
    }
    _fixTitle() {
      const t = this._element.getAttribute("title");
      t &&
        (this._element.getAttribute("aria-label") ||
          this._element.textContent.trim() ||
          this._element.setAttribute("aria-label", t),
        this._element.setAttribute("data-bs-original-title", t),
        this._element.removeAttribute("title"));
    }
    _enter() {
      this._isShown() || this._isHovered
        ? (this._isHovered = !0)
        : ((this._isHovered = !0),
          this._setTimeout(() => {
            this._isHovered && this.show();
          }, this._config.delay.show));
    }
    _leave() {
      this._isWithActiveTrigger() ||
        ((this._isHovered = !1),
        this._setTimeout(() => {
          this._isHovered || this.hide();
        }, this._config.delay.hide));
    }
    _setTimeout(t, e) {
      clearTimeout(this._timeout), (this._timeout = setTimeout(t, e));
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0);
    }
    _getConfig(t) {
      const e = R.getDataAttributes(this._element);
      for (const t of Object.keys(e)) Jn.has(t) && delete e[t];
      return (
        (t = { ...e, ...("object" == typeof t && t ? t : {}) }),
        (t = this._mergeConfigObj(t)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    _configAfterMerge(t) {
      return (
        (t.container = !1 === t.container ? document.body : a(t.container)),
        "number" == typeof t.delay &&
          (t.delay = { show: t.delay, hide: t.delay }),
        "number" == typeof t.title && (t.title = t.title.toString()),
        "number" == typeof t.content && (t.content = t.content.toString()),
        t
      );
    }
    _getDelegateConfig() {
      const t = {};
      for (const e in this._config)
        this.constructor.Default[e] !== this._config[e] &&
          (t[e] = this._config[e]);
      return (t.selector = !1), (t.trigger = "manual"), t;
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), (this._popper = null));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = lr.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(lr);
  const cr = {
      ...lr.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template:
        '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click",
    },
    ur = { ...lr.DefaultType, content: "(null|string|element|function)" };
  class pr extends lr {
    static get Default() {
      return cr;
    }
    static get DefaultType() {
      return ur;
    }
    static get NAME() {
      return "popover";
    }
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    _getContentForTemplate() {
      return {
        ".popover-header": this._getTitle(),
        ".popover-body": this._getContent(),
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = pr.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(pr);
  const dr = "click.bs.scrollspy",
    fr = "active",
    hr = "[href]",
    mr = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: !1,
      target: null,
      threshold: [0.1, 0.5, 1],
    },
    gr = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array",
    };
  class vr extends q {
    constructor(t, e) {
      super(t, e),
        (this._targetLinks = new Map()),
        (this._observableSections = new Map()),
        (this._rootElement =
          "visible" === getComputedStyle(this._element).overflowY
            ? null
            : this._element),
        (this._activeTarget = null),
        (this._observer = null),
        (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }),
        this.refresh();
    }
    static get Default() {
      return mr;
    }
    static get DefaultType() {
      return gr;
    }
    static get NAME() {
      return "scrollspy";
    }
    refresh() {
      this._initializeTargetsAndObservables(),
        this._maybeEnableSmoothScroll(),
        this._observer
          ? this._observer.disconnect()
          : (this._observer = this._getNewObserver());
      for (const t of this._observableSections.values())
        this._observer.observe(t);
    }
    dispose() {
      this._observer.disconnect(), super.dispose();
    }
    _configAfterMerge(t) {
      return (
        (t.target = a(t.target) || document.body),
        (t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin),
        "string" == typeof t.threshold &&
          (t.threshold = t.threshold
            .split(",")
            .map((t) => Number.parseFloat(t))),
        t
      );
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll &&
        (D.off(this._config.target, dr),
        D.on(this._config.target, dr, hr, (t) => {
          const e = this._observableSections.get(t.target.hash);
          if (e) {
            t.preventDefault();
            const n = this._rootElement || window,
              r = e.offsetTop - this._element.offsetTop;
            if (n.scrollTo)
              return void n.scrollTo({ top: r, behavior: "smooth" });
            n.scrollTop = r;
          }
        }));
    }
    _getNewObserver() {
      const t = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin,
      };
      return new IntersectionObserver((t) => this._observerCallback(t), t);
    }
    _observerCallback(t) {
      const e = (t) => this._targetLinks.get(`#${t.target.id}`),
        n = (t) => {
          (this._previousScrollData.visibleEntryTop = t.target.offsetTop),
            this._process(e(t));
        },
        r = (this._rootElement || document.documentElement).scrollTop,
        s = r >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = r;
      for (const i of t) {
        if (!i.isIntersecting) {
          (this._activeTarget = null), this._clearActiveClass(e(i));
          continue;
        }
        const t =
          i.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (s && t) {
          if ((n(i), !r)) return;
        } else s || t || n(i);
      }
    }
    _initializeTargetsAndObservables() {
      (this._targetLinks = new Map()), (this._observableSections = new Map());
      const t = G.find(hr, this._config.target);
      for (const e of t) {
        if (!e.hash || l(e)) continue;
        const t = G.findOne(e.hash, this._element);
        o(t) &&
          (this._targetLinks.set(e.hash, e),
          this._observableSections.set(e.hash, t));
      }
    }
    _process(t) {
      this._activeTarget !== t &&
        (this._clearActiveClass(this._config.target),
        (this._activeTarget = t),
        t.classList.add(fr),
        this._activateParents(t),
        D.trigger(this._element, "activate.bs.scrollspy", {
          relatedTarget: t,
        }));
    }
    _activateParents(t) {
      if (t.classList.contains("dropdown-item"))
        G.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(fr);
      else
        for (const e of G.parents(t, ".nav, .list-group"))
          for (const t of G.prev(
            e,
            ".nav-link, .nav-item > .nav-link, .list-group-item"
          ))
            t.classList.add(fr);
    }
    _clearActiveClass(t) {
      t.classList.remove(fr);
      const e = G.find("[href].active", t);
      for (const t of e) t.classList.remove(fr);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = vr.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  D.on(window, "load.bs.scrollspy.data-api", () => {
    for (const t of G.find('[data-bs-spy="scroll"]')) vr.getOrCreateInstance(t);
  }),
    m(vr);
  const yr = "ArrowLeft",
    br = "ArrowRight",
    _r = "ArrowUp",
    wr = "ArrowDown",
    Sr = "active",
    Cr = "fade",
    xr = "show",
    kr =
      '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    Er = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${kr}`;
  class Tr extends q {
    constructor(t) {
      super(t),
        (this._parent = this._element.closest(
          '.list-group, .nav, [role="tablist"]'
        )),
        this._parent &&
          (this._setInitialAttributes(this._parent, this._getChildren()),
          D.on(this._element, "keydown.bs.tab", (t) => this._keydown(t)));
    }
    static get NAME() {
      return "tab";
    }
    show() {
      const t = this._element;
      if (this._elemIsActive(t)) return;
      const e = this._getActiveElem(),
        n = e ? D.trigger(e, "hide.bs.tab", { relatedTarget: t }) : null;
      D.trigger(t, "show.bs.tab", { relatedTarget: e }).defaultPrevented ||
        (n && n.defaultPrevented) ||
        (this._deactivate(e, t), this._activate(t, e));
    }
    _activate(t, e) {
      t &&
        (t.classList.add(Sr),
        this._activate(r(t)),
        this._queueCallback(
          () => {
            "tab" === t.getAttribute("role")
              ? (t.removeAttribute("tabindex"),
                t.setAttribute("aria-selected", !0),
                this._toggleDropDown(t, !0),
                D.trigger(t, "shown.bs.tab", { relatedTarget: e }))
              : t.classList.add(xr);
          },
          t,
          t.classList.contains(Cr)
        ));
    }
    _deactivate(t, e) {
      t &&
        (t.classList.remove(Sr),
        t.blur(),
        this._deactivate(r(t)),
        this._queueCallback(
          () => {
            "tab" === t.getAttribute("role")
              ? (t.setAttribute("aria-selected", !1),
                t.setAttribute("tabindex", "-1"),
                this._toggleDropDown(t, !1),
                D.trigger(t, "hidden.bs.tab", { relatedTarget: e }))
              : t.classList.remove(xr);
          },
          t,
          t.classList.contains(Cr)
        ));
    }
    _keydown(t) {
      if (![yr, br, _r, wr].includes(t.key)) return;
      t.stopPropagation(), t.preventDefault();
      const e = [br, wr].includes(t.key),
        n = y(
          this._getChildren().filter((t) => !l(t)),
          t.target,
          e,
          !0
        );
      n && (n.focus({ preventScroll: !0 }), Tr.getOrCreateInstance(n).show());
    }
    _getChildren() {
      return G.find(Er, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((t) => this._elemIsActive(t)) || null;
    }
    _setInitialAttributes(t, e) {
      this._setAttributeIfNotExists(t, "role", "tablist");
      for (const t of e) this._setInitialAttributesOnChild(t);
    }
    _setInitialAttributesOnChild(t) {
      t = this._getInnerElement(t);
      const e = this._elemIsActive(t),
        n = this._getOuterElement(t);
      t.setAttribute("aria-selected", e),
        n !== t && this._setAttributeIfNotExists(n, "role", "presentation"),
        e || t.setAttribute("tabindex", "-1"),
        this._setAttributeIfNotExists(t, "role", "tab"),
        this._setInitialAttributesOnTargetPanel(t);
    }
    _setInitialAttributesOnTargetPanel(t) {
      const e = r(t);
      e &&
        (this._setAttributeIfNotExists(e, "role", "tabpanel"),
        t.id &&
          this._setAttributeIfNotExists(e, "aria-labelledby", `#${t.id}`));
    }
    _toggleDropDown(t, e) {
      const n = this._getOuterElement(t);
      if (!n.classList.contains("dropdown")) return;
      const r = (t, r) => {
        const s = G.findOne(t, n);
        s && s.classList.toggle(r, e);
      };
      r(".dropdown-toggle", Sr),
        r(".dropdown-menu", xr),
        n.setAttribute("aria-expanded", e);
    }
    _setAttributeIfNotExists(t, e, n) {
      t.hasAttribute(e) || t.setAttribute(e, n);
    }
    _elemIsActive(t) {
      return t.classList.contains(Sr);
    }
    _getInnerElement(t) {
      return t.matches(Er) ? t : G.findOne(Er, t);
    }
    _getOuterElement(t) {
      return t.closest(".nav-item, .list-group-item") || t;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Tr.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  D.on(document, "click.bs.tab", kr, function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
      l(this) || Tr.getOrCreateInstance(this).show();
  }),
    D.on(window, "load.bs.tab", () => {
      for (const t of G.find(
        '.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'
      ))
        Tr.getOrCreateInstance(t);
    }),
    m(Tr);
  const Pr = "hide",
    Mr = "show",
    Or = "showing",
    Ar = { animation: "boolean", autohide: "boolean", delay: "number" },
    jr = { animation: !0, autohide: !0, delay: 5e3 };
  class $r extends q {
    constructor(t, e) {
      super(t, e),
        (this._timeout = null),
        (this._hasMouseInteraction = !1),
        (this._hasKeyboardInteraction = !1),
        this._setListeners();
    }
    static get Default() {
      return jr;
    }
    static get DefaultType() {
      return Ar;
    }
    static get NAME() {
      return "toast";
    }
    show() {
      D.trigger(this._element, "show.bs.toast").defaultPrevented ||
        (this._clearTimeout(),
        this._config.animation && this._element.classList.add("fade"),
        this._element.classList.remove(Pr),
        p(this._element),
        this._element.classList.add(Mr, Or),
        this._queueCallback(
          () => {
            this._element.classList.remove(Or),
              D.trigger(this._element, "shown.bs.toast"),
              this._maybeScheduleHide();
          },
          this._element,
          this._config.animation
        ));
    }
    hide() {
      this.isShown() &&
        (D.trigger(this._element, "hide.bs.toast").defaultPrevented ||
          (this._element.classList.add(Or),
          this._queueCallback(
            () => {
              this._element.classList.add(Pr),
                this._element.classList.remove(Or, Mr),
                D.trigger(this._element, "hidden.bs.toast");
            },
            this._element,
            this._config.animation
          )));
    }
    dispose() {
      this._clearTimeout(),
        this.isShown() && this._element.classList.remove(Mr),
        super.dispose();
    }
    isShown() {
      return this._element.classList.contains(Mr);
    }
    _maybeScheduleHide() {
      this._config.autohide &&
        (this._hasMouseInteraction ||
          this._hasKeyboardInteraction ||
          (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) return void this._clearTimeout();
      const n = t.relatedTarget;
      this._element === n ||
        this._element.contains(n) ||
        this._maybeScheduleHide();
    }
    _setListeners() {
      D.on(this._element, "mouseover.bs.toast", (t) =>
        this._onInteraction(t, !0)
      ),
        D.on(this._element, "mouseout.bs.toast", (t) =>
          this._onInteraction(t, !1)
        ),
        D.on(this._element, "focusin.bs.toast", (t) =>
          this._onInteraction(t, !0)
        ),
        D.on(this._element, "focusout.bs.toast", (t) =>
          this._onInteraction(t, !1)
        );
    }
    _clearTimeout() {
      clearTimeout(this._timeout), (this._timeout = null);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = $r.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  return (
    B($r),
    m($r),
    {
      Alert: F,
      Button: U,
      Carousel: ot,
      Collapse: ht,
      Dropdown: un,
      Modal: $n,
      Offcanvas: qn,
      Popover: pr,
      ScrollSpy: vr,
      Tab: Tr,
      Toast: $r,
      Tooltip: lr,
    }
  );
}),
  function (t, e) {
    "object" == typeof exports && "object" == typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define([], e)
      : "object" == typeof exports
      ? (exports.HSHeader = e())
      : (t.HSHeader = e());
  },
  (function (t, e) {
    "object" == typeof exports && void 0 !== module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define(e)
      : ((t =
          "undefined" != typeof globalThis ? globalThis : t || self).Swiper =
          e());
  })(this, function () {
    "use strict";
    function t(t) {
      return (
        null !== t &&
        "object" == typeof t &&
        "constructor" in t &&
        t.constructor === Object
      );
    }
    function e(n, r) {
      void 0 === n && (n = {}),
        void 0 === r && (r = {}),
        Object.keys(r).forEach((s) => {
          void 0 === n[s]
            ? (n[s] = r[s])
            : t(r[s]) &&
              t(n[s]) &&
              Object.keys(r[s]).length > 0 &&
              e(n[s], r[s]);
        });
    }
    const n = {
      body: {},
      addEventListener() {},
      removeEventListener() {},
      activeElement: { blur() {}, nodeName: "" },
      querySelector: () => null,
      querySelectorAll: () => [],
      getElementById: () => null,
      createEvent: () => ({ initEvent() {} }),
      createElement: () => ({
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {},
        getElementsByTagName: () => [],
      }),
      createElementNS: () => ({}),
      importNode: () => null,
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: "",
      },
    };
    function r() {
      const t = "undefined" != typeof document ? document : {};
      return e(t, n), t;
    }
    const s = {
      document: n,
      navigator: { userAgent: "" },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: "",
      },
      history: { replaceState() {}, pushState() {}, go() {}, back() {} },
      CustomEvent: function () {
        return this;
      },
      addEventListener() {},
      removeEventListener() {},
      getComputedStyle: () => ({ getPropertyValue: () => "" }),
      Image() {},
      Date() {},
      screen: {},
      setTimeout() {},
      clearTimeout() {},
      matchMedia: () => ({}),
      requestAnimationFrame: (t) =>
        "undefined" == typeof setTimeout ? (t(), null) : setTimeout(t, 0),
      cancelAnimationFrame(t) {
        "undefined" != typeof setTimeout && clearTimeout(t);
      },
    };
    function i() {
      const t = "undefined" != typeof window ? window : {};
      return e(t, s), t;
    }
    class a extends Array {
      constructor(t) {
        "number" == typeof t
          ? super(t)
          : (super(...(t || [])),
            (function (t) {
              const e = t.__proto__;
              Object.defineProperty(t, "__proto__", {
                get: () => e,
                set(t) {
                  e.__proto__ = t;
                },
              });
            })(this));
      }
    }
    function o(t) {
      void 0 === t && (t = []);
      const e = [];
      return (
        t.forEach((t) => {
          Array.isArray(t) ? e.push(...o(t)) : e.push(t);
        }),
        e
      );
    }
    function l(t, e) {
      return Array.prototype.filter.call(t, e);
    }
    function c(t, e) {
      const n = i(),
        s = r();
      let o = [];
      if (!e && t instanceof a) return t;
      if (!t) return new a(o);
      if ("string" == typeof t) {
        const n = t.trim();
        if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) {
          let t = "div";
          0 === n.indexOf("<li") && (t = "ul"),
            0 === n.indexOf("<tr") && (t = "tbody"),
            (0 !== n.indexOf("<td") && 0 !== n.indexOf("<th")) || (t = "tr"),
            0 === n.indexOf("<tbody") && (t = "table"),
            0 === n.indexOf("<option") && (t = "select");
          const e = s.createElement(t);
          e.innerHTML = n;
          for (let t = 0; t < e.childNodes.length; t += 1)
            o.push(e.childNodes[t]);
        } else
          o = (function (t, e) {
            if ("string" != typeof t) return [t];
            const n = [],
              r = e.querySelectorAll(t);
            for (let t = 0; t < r.length; t += 1) n.push(r[t]);
            return n;
          })(t.trim(), e || s);
      } else if (t.nodeType || t === n || t === s) o.push(t);
      else if (Array.isArray(t)) {
        if (t instanceof a) return t;
        o = t;
      }
      return new a(
        (function (t) {
          const e = [];
          for (let n = 0; n < t.length; n += 1)
            -1 === e.indexOf(t[n]) && e.push(t[n]);
          return e;
        })(o)
      );
    }
    c.fn = a.prototype;
    const u = {
      addClass: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        const r = o(e.map((t) => t.split(" ")));
        return (
          this.forEach((t) => {
            t.classList.add(...r);
          }),
          this
        );
      },
      removeClass: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        const r = o(e.map((t) => t.split(" ")));
        return (
          this.forEach((t) => {
            t.classList.remove(...r);
          }),
          this
        );
      },
      hasClass: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        const r = o(e.map((t) => t.split(" ")));
        return (
          l(this, (t) => r.filter((e) => t.classList.contains(e)).length > 0)
            .length > 0
        );
      },
      toggleClass: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        const r = o(e.map((t) => t.split(" ")));
        this.forEach((t) => {
          r.forEach((e) => {
            t.classList.toggle(e);
          });
        });
      },
      attr: function (t, e) {
        if (1 === arguments.length && "string" == typeof t)
          return this[0] ? this[0].getAttribute(t) : void 0;
        for (let n = 0; n < this.length; n += 1)
          if (2 === arguments.length) this[n].setAttribute(t, e);
          else
            for (const e in t)
              (this[n][e] = t[e]), this[n].setAttribute(e, t[e]);
        return this;
      },
      removeAttr: function (t) {
        for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
        return this;
      },
      transform: function (t) {
        for (let e = 0; e < this.length; e += 1) this[e].style.transform = t;
        return this;
      },
      transition: function (t) {
        for (let e = 0; e < this.length; e += 1)
          this[e].style.transitionDuration =
            "string" != typeof t ? `${t}ms` : t;
        return this;
      },
      on: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        let [r, s, i, a] = e;
        function o(t) {
          const e = t.target;
          if (!e) return;
          const n = t.target.dom7EventData || [];
          if ((n.indexOf(t) < 0 && n.unshift(t), c(e).is(s))) i.apply(e, n);
          else {
            const t = c(e).parents();
            for (let e = 0; e < t.length; e += 1)
              c(t[e]).is(s) && i.apply(t[e], n);
          }
        }
        function l(t) {
          const e = (t && t.target && t.target.dom7EventData) || [];
          e.indexOf(t) < 0 && e.unshift(t), i.apply(this, e);
        }
        "function" == typeof e[1] && (([r, i, a] = e), (s = void 0)),
          a || (a = !1);
        const u = r.split(" ");
        let p;
        for (let t = 0; t < this.length; t += 1) {
          const e = this[t];
          if (s)
            for (p = 0; p < u.length; p += 1) {
              const t = u[p];
              e.dom7LiveListeners || (e.dom7LiveListeners = {}),
                e.dom7LiveListeners[t] || (e.dom7LiveListeners[t] = []),
                e.dom7LiveListeners[t].push({ listener: i, proxyListener: o }),
                e.addEventListener(t, o, a);
            }
          else
            for (p = 0; p < u.length; p += 1) {
              const t = u[p];
              e.dom7Listeners || (e.dom7Listeners = {}),
                e.dom7Listeners[t] || (e.dom7Listeners[t] = []),
                e.dom7Listeners[t].push({ listener: i, proxyListener: l }),
                e.addEventListener(t, l, a);
            }
        }
        return this;
      },
      off: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        let [r, s, i, a] = e;
        "function" == typeof e[1] && (([r, i, a] = e), (s = void 0)),
          a || (a = !1);
        const o = r.split(" ");
        for (let t = 0; t < o.length; t += 1) {
          const e = o[t];
          for (let t = 0; t < this.length; t += 1) {
            const n = this[t];
            let r;
            if (
              (!s && n.dom7Listeners
                ? (r = n.dom7Listeners[e])
                : s && n.dom7LiveListeners && (r = n.dom7LiveListeners[e]),
              r && r.length)
            )
              for (let t = r.length - 1; t >= 0; t -= 1) {
                const s = r[t];
                (i && s.listener === i) ||
                (i &&
                  s.listener &&
                  s.listener.dom7proxy &&
                  s.listener.dom7proxy === i)
                  ? (n.removeEventListener(e, s.proxyListener, a),
                    r.splice(t, 1))
                  : i ||
                    (n.removeEventListener(e, s.proxyListener, a),
                    r.splice(t, 1));
              }
          }
        }
        return this;
      },
      trigger: function () {
        const t = i();
        for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
          n[r] = arguments[r];
        const s = n[0].split(" "),
          a = n[1];
        for (let e = 0; e < s.length; e += 1) {
          const r = s[e];
          for (let e = 0; e < this.length; e += 1) {
            const s = this[e];
            if (t.CustomEvent) {
              const e = new t.CustomEvent(r, {
                detail: a,
                bubbles: !0,
                cancelable: !0,
              });
              (s.dom7EventData = n.filter((t, e) => e > 0)),
                s.dispatchEvent(e),
                (s.dom7EventData = []),
                delete s.dom7EventData;
            }
          }
        }
        return this;
      },
      transitionEnd: function (t) {
        const e = this;
        return (
          t &&
            e.on("transitionend", function n(r) {
              r.target === this && (t.call(this, r), e.off("transitionend", n));
            }),
          this
        );
      },
      outerWidth: function (t) {
        if (this.length > 0) {
          if (t) {
            const t = this.styles();
            return (
              this[0].offsetWidth +
              parseFloat(t.getPropertyValue("margin-right")) +
              parseFloat(t.getPropertyValue("margin-left"))
            );
          }
          return this[0].offsetWidth;
        }
        return null;
      },
      outerHeight: function (t) {
        if (this.length > 0) {
          if (t) {
            const t = this.styles();
            return (
              this[0].offsetHeight +
              parseFloat(t.getPropertyValue("margin-top")) +
              parseFloat(t.getPropertyValue("margin-bottom"))
            );
          }
          return this[0].offsetHeight;
        }
        return null;
      },
      styles: function () {
        const t = i();
        return this[0] ? t.getComputedStyle(this[0], null) : {};
      },
      offset: function () {
        if (this.length > 0) {
          const t = i(),
            e = r(),
            n = this[0],
            s = n.getBoundingClientRect(),
            a = e.body,
            o = n.clientTop || a.clientTop || 0,
            l = n.clientLeft || a.clientLeft || 0,
            c = n === t ? t.scrollY : n.scrollTop,
            u = n === t ? t.scrollX : n.scrollLeft;
          return { top: s.top + c - o, left: s.left + u - l };
        }
        return null;
      },
      css: function (t, e) {
        const n = i();
        let r;
        if (1 === arguments.length) {
          if ("string" != typeof t) {
            for (r = 0; r < this.length; r += 1)
              for (const e in t) this[r].style[e] = t[e];
            return this;
          }
          if (this[0])
            return n.getComputedStyle(this[0], null).getPropertyValue(t);
        }
        if (2 === arguments.length && "string" == typeof t) {
          for (r = 0; r < this.length; r += 1) this[r].style[t] = e;
          return this;
        }
        return this;
      },
      each: function (t) {
        return t
          ? (this.forEach((e, n) => {
              t.apply(e, [e, n]);
            }),
            this)
          : this;
      },
      html: function (t) {
        if (void 0 === t) return this[0] ? this[0].innerHTML : null;
        for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t;
        return this;
      },
      text: function (t) {
        if (void 0 === t) return this[0] ? this[0].textContent.trim() : null;
        for (let e = 0; e < this.length; e += 1) this[e].textContent = t;
        return this;
      },
      is: function (t) {
        const e = i(),
          n = r(),
          s = this[0];
        let o, l;
        if (!s || void 0 === t) return !1;
        if ("string" == typeof t) {
          if (s.matches) return s.matches(t);
          if (s.webkitMatchesSelector) return s.webkitMatchesSelector(t);
          if (s.msMatchesSelector) return s.msMatchesSelector(t);
          for (o = c(t), l = 0; l < o.length; l += 1) if (o[l] === s) return !0;
          return !1;
        }
        if (t === n) return s === n;
        if (t === e) return s === e;
        if (t.nodeType || t instanceof a) {
          for (o = t.nodeType ? [t] : t, l = 0; l < o.length; l += 1)
            if (o[l] === s) return !0;
          return !1;
        }
        return !1;
      },
      index: function () {
        let t,
          e = this[0];
        if (e) {
          for (t = 0; null !== (e = e.previousSibling); )
            1 === e.nodeType && (t += 1);
          return t;
        }
      },
      eq: function (t) {
        if (void 0 === t) return this;
        const e = this.length;
        if (t > e - 1) return c([]);
        if (t < 0) {
          const n = e + t;
          return c(n < 0 ? [] : [this[n]]);
        }
        return c([this[t]]);
      },
      append: function () {
        let t;
        const e = r();
        for (let n = 0; n < arguments.length; n += 1) {
          t = n < 0 || arguments.length <= n ? void 0 : arguments[n];
          for (let n = 0; n < this.length; n += 1)
            if ("string" == typeof t) {
              const r = e.createElement("div");
              for (r.innerHTML = t; r.firstChild; )
                this[n].appendChild(r.firstChild);
            } else if (t instanceof a)
              for (let e = 0; e < t.length; e += 1) this[n].appendChild(t[e]);
            else this[n].appendChild(t);
        }
        return this;
      },
      prepend: function (t) {
        const e = r();
        let n, s;
        for (n = 0; n < this.length; n += 1)
          if ("string" == typeof t) {
            const r = e.createElement("div");
            for (r.innerHTML = t, s = r.childNodes.length - 1; s >= 0; s -= 1)
              this[n].insertBefore(r.childNodes[s], this[n].childNodes[0]);
          } else if (t instanceof a)
            for (s = 0; s < t.length; s += 1)
              this[n].insertBefore(t[s], this[n].childNodes[0]);
          else this[n].insertBefore(t, this[n].childNodes[0]);
        return this;
      },
      next: function (t) {
        return this.length > 0
          ? t
            ? this[0].nextElementSibling && c(this[0].nextElementSibling).is(t)
              ? c([this[0].nextElementSibling])
              : c([])
            : this[0].nextElementSibling
            ? c([this[0].nextElementSibling])
            : c([])
          : c([]);
      },
      nextAll: function (t) {
        const e = [];
        let n = this[0];
        if (!n) return c([]);
        for (; n.nextElementSibling; ) {
          const r = n.nextElementSibling;
          t ? c(r).is(t) && e.push(r) : e.push(r), (n = r);
        }
        return c(e);
      },
      prev: function (t) {
        if (this.length > 0) {
          const e = this[0];
          return t
            ? e.previousElementSibling && c(e.previousElementSibling).is(t)
              ? c([e.previousElementSibling])
              : c([])
            : e.previousElementSibling
            ? c([e.previousElementSibling])
            : c([]);
        }
        return c([]);
      },
      prevAll: function (t) {
        const e = [];
        let n = this[0];
        if (!n) return c([]);
        for (; n.previousElementSibling; ) {
          const r = n.previousElementSibling;
          t ? c(r).is(t) && e.push(r) : e.push(r), (n = r);
        }
        return c(e);
      },
      parent: function (t) {
        const e = [];
        for (let n = 0; n < this.length; n += 1)
          null !== this[n].parentNode &&
            (t
              ? c(this[n].parentNode).is(t) && e.push(this[n].parentNode)
              : e.push(this[n].parentNode));
        return c(e);
      },
      parents: function (t) {
        const e = [];
        for (let n = 0; n < this.length; n += 1) {
          let r = this[n].parentNode;
          for (; r; )
            t ? c(r).is(t) && e.push(r) : e.push(r), (r = r.parentNode);
        }
        return c(e);
      },
      closest: function (t) {
        let e = this;
        return void 0 === t ? c([]) : (e.is(t) || (e = e.parents(t).eq(0)), e);
      },
      find: function (t) {
        const e = [];
        for (let n = 0; n < this.length; n += 1) {
          const r = this[n].querySelectorAll(t);
          for (let t = 0; t < r.length; t += 1) e.push(r[t]);
        }
        return c(e);
      },
      children: function (t) {
        const e = [];
        for (let n = 0; n < this.length; n += 1) {
          const r = this[n].children;
          for (let n = 0; n < r.length; n += 1)
            (t && !c(r[n]).is(t)) || e.push(r[n]);
        }
        return c(e);
      },
      filter: function (t) {
        return c(l(this, t));
      },
      remove: function () {
        for (let t = 0; t < this.length; t += 1)
          this[t].parentNode && this[t].parentNode.removeChild(this[t]);
        return this;
      },
    };
    function p(t, e) {
      return void 0 === e && (e = 0), setTimeout(t, e);
    }
    function d() {
      return Date.now();
    }
    function f(t, e) {
      void 0 === e && (e = "x");
      const n = i();
      let r, s, a;
      const o = (function (t) {
        const e = i();
        let n;
        return (
          e.getComputedStyle && (n = e.getComputedStyle(t, null)),
          !n && t.currentStyle && (n = t.currentStyle),
          n || (n = t.style),
          n
        );
      })(t);
      return (
        n.WebKitCSSMatrix
          ? ((s = o.transform || o.webkitTransform),
            s.split(",").length > 6 &&
              (s = s
                .split(", ")
                .map((t) => t.replace(",", "."))
                .join(", ")),
            (a = new n.WebKitCSSMatrix("none" === s ? "" : s)))
          : ((a =
              o.MozTransform ||
              o.OTransform ||
              o.MsTransform ||
              o.msTransform ||
              o.transform ||
              o
                .getPropertyValue("transform")
                .replace("translate(", "matrix(1, 0, 0, 1,")),
            (r = a.toString().split(","))),
        "x" === e &&
          (s = n.WebKitCSSMatrix
            ? a.m41
            : 16 === r.length
            ? parseFloat(r[12])
            : parseFloat(r[4])),
        "y" === e &&
          (s = n.WebKitCSSMatrix
            ? a.m42
            : 16 === r.length
            ? parseFloat(r[13])
            : parseFloat(r[5])),
        s || 0
      );
    }
    function h(t) {
      return (
        "object" == typeof t &&
        null !== t &&
        t.constructor &&
        "Object" === Object.prototype.toString.call(t).slice(8, -1)
      );
    }
    function m(t) {
      return "undefined" != typeof window && void 0 !== window.HTMLElement
        ? t instanceof HTMLElement
        : t && (1 === t.nodeType || 11 === t.nodeType);
    }
    function g() {
      const t = Object(arguments.length <= 0 ? void 0 : arguments[0]),
        e = ["__proto__", "constructor", "prototype"];
      for (let n = 1; n < arguments.length; n += 1) {
        const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
        if (null != r && !m(r)) {
          const n = Object.keys(Object(r)).filter((t) => e.indexOf(t) < 0);
          for (let e = 0, s = n.length; e < s; e += 1) {
            const s = n[e],
              i = Object.getOwnPropertyDescriptor(r, s);
            void 0 !== i &&
              i.enumerable &&
              (h(t[s]) && h(r[s])
                ? r[s].__swiper__
                  ? (t[s] = r[s])
                  : g(t[s], r[s])
                : !h(t[s]) && h(r[s])
                ? ((t[s] = {}), r[s].__swiper__ ? (t[s] = r[s]) : g(t[s], r[s]))
                : (t[s] = r[s]));
          }
        }
      }
      return t;
    }
    function v(t, e, n) {
      t.style.setProperty(e, n);
    }
    function y(t) {
      let { swiper: e, targetPosition: n, side: r } = t;
      const s = i(),
        a = -e.translate;
      let o,
        l = null;
      const c = e.params.speed;
      (e.wrapperEl.style.scrollSnapType = "none"),
        s.cancelAnimationFrame(e.cssModeFrameID);
      const u = n > a ? "next" : "prev",
        p = (t, e) => ("next" === u && t >= e) || ("prev" === u && t <= e),
        d = () => {
          (o = new Date().getTime()), null === l && (l = o);
          const t = Math.max(Math.min((o - l) / c, 1), 0),
            i = 0.5 - Math.cos(t * Math.PI) / 2;
          let u = a + i * (n - a);
          if ((p(u, n) && (u = n), e.wrapperEl.scrollTo({ [r]: u }), p(u, n)))
            return (
              (e.wrapperEl.style.overflow = "hidden"),
              (e.wrapperEl.style.scrollSnapType = ""),
              setTimeout(() => {
                (e.wrapperEl.style.overflow = ""),
                  e.wrapperEl.scrollTo({ [r]: u });
              }),
              void s.cancelAnimationFrame(e.cssModeFrameID)
            );
          e.cssModeFrameID = s.requestAnimationFrame(d);
        };
      d();
    }
    let b, _, w;
    function S() {
      return (
        b ||
          (b = (function () {
            const t = i(),
              e = r();
            return {
              smoothScroll:
                e.documentElement &&
                "scrollBehavior" in e.documentElement.style,
              touch: !!(
                "ontouchstart" in t ||
                (t.DocumentTouch && e instanceof t.DocumentTouch)
              ),
              passiveListener: (function () {
                let e = !1;
                try {
                  const n = Object.defineProperty({}, "passive", {
                    get() {
                      e = !0;
                      return undefined;
                    },
                  });
                  t.addEventListener("testPassiveListener", null, n);
                } catch (t) {
                  console.log(t);
                }
                return e;
              })(),
              gestures: "ongesturestart" in t,
            };
          })()),
        b
      );
    }
    function C(t) {
      return (
        void 0 === t && (t = {}),
        _ ||
          (_ = (function (t) {
            let { userAgent: e } = void 0 === t ? {} : t;
            const n = S(),
              r = i(),
              s = r.navigator.platform,
              a = e || r.navigator.userAgent,
              o = { ios: !1, android: !1 },
              l = r.screen.width,
              c = r.screen.height,
              u = a.match(/(Android);?[\s/]+([\d.]+)?/);
            let p = a.match(/(iPad).*OS\s([\d_]+)/);
            const d = a.match(/(iPod)(.*OS\s([\d_]+))?/),
              f = !p && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
              h = "Win32" === s;
            let m = "MacIntel" === s;
            return (
              !p &&
                m &&
                n.touch &&
                [
                  "1024x1366",
                  "1366x1024",
                  "834x1194",
                  "1194x834",
                  "834x1112",
                  "1112x834",
                  "768x1024",
                  "1024x768",
                  "820x1180",
                  "1180x820",
                  "810x1080",
                  "1080x810",
                ].indexOf(`${l}x${c}`) >= 0 &&
                ((p = a.match(/(Version)\/([\d.]+)/)),
                p || (p = [0, 1, "13_0_0"]),
                (m = !1)),
              u && !h && ((o.os = "android"), (o.android = !0)),
              (p || f || d) && ((o.os = "ios"), (o.ios = !0)),
              o
            );
          })(t)),
        _
      );
    }
    function x() {
      return (
        w ||
          (w = (function () {
            const t = i();
            return {
              isSafari: (function () {
                const e = t.navigator.userAgent.toLowerCase();
                return (
                  e.indexOf("safari") >= 0 &&
                  e.indexOf("chrome") < 0 &&
                  e.indexOf("android") < 0
                );
              })(),
              isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                t.navigator.userAgent
              ),
            };
          })()),
        w
      );
    }
    Object.keys(u).forEach((t) => {
      Object.defineProperty(c.fn, t, { value: u[t], writable: !0 });
    });
    var k = {
        on(t, e, n) {
          const r = this;
          if (!r.eventsListeners || r.destroyed) return r;
          if ("function" != typeof e) return r;
          const s = n ? "unshift" : "push";
          return (
            t.split(" ").forEach((t) => {
              r.eventsListeners[t] || (r.eventsListeners[t] = []),
                r.eventsListeners[t][s](e);
            }),
            r
          );
        },
        once(t, e, n) {
          const r = this;
          if (!r.eventsListeners || r.destroyed) return r;
          if ("function" != typeof e) return r;
          function s() {
            r.off(t, s), s.__emitterProxy && delete s.__emitterProxy;
            for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
              i[a] = arguments[a];
            e.apply(r, i);
          }
          return (s.__emitterProxy = e), r.on(t, s, n);
        },
        onAny(t, e) {
          const n = this;
          if (!n.eventsListeners || n.destroyed) return n;
          if ("function" != typeof t) return n;
          const r = e ? "unshift" : "push";
          return (
            n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n
          );
        },
        offAny(t) {
          const e = this;
          if (!e.eventsListeners || e.destroyed) return e;
          if (!e.eventsAnyListeners) return e;
          const n = e.eventsAnyListeners.indexOf(t);
          return n >= 0 && e.eventsAnyListeners.splice(n, 1), e;
        },
        off(t, e) {
          const n = this;
          return !n.eventsListeners || n.destroyed
            ? n
            : n.eventsListeners
            ? (t.split(" ").forEach((t) => {
                void 0 === e
                  ? (n.eventsListeners[t] = [])
                  : n.eventsListeners[t] &&
                    n.eventsListeners[t].forEach((r, s) => {
                      (r === e ||
                        (r.__emitterProxy && r.__emitterProxy === e)) &&
                        n.eventsListeners[t].splice(s, 1);
                    });
              }),
              n)
            : n;
        },
        emit() {
          const t = this;
          if (!t.eventsListeners || t.destroyed) return t;
          if (!t.eventsListeners) return t;
          let e, n, r;
          for (var s = arguments.length, i = new Array(s), a = 0; a < s; a++)
            i[a] = arguments[a];
          return (
            "string" == typeof i[0] || Array.isArray(i[0])
              ? ((e = i[0]), (n = i.slice(1, i.length)), (r = t))
              : ((e = i[0].events), (n = i[0].data), (r = i[0].context || t)),
            n.unshift(r),
            (Array.isArray(e) ? e : e.split(" ")).forEach((e) => {
              t.eventsAnyListeners &&
                t.eventsAnyListeners.length &&
                t.eventsAnyListeners.forEach((t) => {
                  t.apply(r, [e, ...n]);
                }),
                t.eventsListeners &&
                  t.eventsListeners[e] &&
                  t.eventsListeners[e].forEach((t) => {
                    t.apply(r, n);
                  });
            }),
            t
          );
        },
      },
      E = {
        updateSize: function () {
          const t = this;
          let e, n;
          const r = t.$el;
          (e =
            void 0 !== t.params.width && null !== t.params.width
              ? t.params.width
              : r[0].clientWidth),
            (n =
              void 0 !== t.params.height && null !== t.params.height
                ? t.params.height
                : r[0].clientHeight),
            (0 === e && t.isHorizontal()) ||
              (0 === n && t.isVertical()) ||
              ((e =
                e -
                parseInt(r.css("padding-left") || 0, 10) -
                parseInt(r.css("padding-right") || 0, 10)),
              (n =
                n -
                parseInt(r.css("padding-top") || 0, 10) -
                parseInt(r.css("padding-bottom") || 0, 10)),
              Number.isNaN(e) && (e = 0),
              Number.isNaN(n) && (n = 0),
              Object.assign(t, {
                width: e,
                height: n,
                size: t.isHorizontal() ? e : n,
              }));
        },
        updateSlides: function () {
          const t = this;
          function e(e) {
            return t.isHorizontal()
              ? e
              : {
                  width: "height",
                  "margin-top": "margin-left",
                  "margin-bottom ": "margin-right",
                  "margin-left": "margin-top",
                  "margin-right": "margin-bottom",
                  "padding-left": "padding-top",
                  "padding-right": "padding-bottom",
                  marginRight: "marginBottom",
                }[e];
          }
          function n(t, n) {
            return parseFloat(t.getPropertyValue(e(n)) || 0);
          }
          const r = t.params,
            { $wrapperEl: s, size: i, rtlTranslate: a, wrongRTL: o } = t,
            l = t.virtual && r.virtual.enabled,
            c = l ? t.virtual.slides.length : t.slides.length,
            u = s.children(`.${t.params.slideClass}`),
            p = l ? t.virtual.slides.length : u.length;
          let d = [];
          const f = [],
            h = [];
          let m = r.slidesOffsetBefore;
          "function" == typeof m && (m = r.slidesOffsetBefore.call(t));
          let g = r.slidesOffsetAfter;
          "function" == typeof g && (g = r.slidesOffsetAfter.call(t));
          const y = t.snapGrid.length,
            b = t.slidesGrid.length;
          let _ = r.spaceBetween,
            w = -m,
            S = 0,
            C = 0;
          if (void 0 === i) return;
          "string" == typeof _ &&
            _.indexOf("%") >= 0 &&
            (_ = (parseFloat(_.replace("%", "")) / 100) * i),
            (t.virtualSize = -_),
            a
              ? u.css({ marginLeft: "", marginBottom: "", marginTop: "" })
              : u.css({ marginRight: "", marginBottom: "", marginTop: "" }),
            r.centeredSlides &&
              r.cssMode &&
              (v(t.wrapperEl, "--swiper-centered-offset-before", ""),
              v(t.wrapperEl, "--swiper-centered-offset-after", ""));
          const x = r.grid && r.grid.rows > 1 && t.grid;
          let k;
          x && t.grid.initSlides(p);
          const E =
            "auto" === r.slidesPerView &&
            r.breakpoints &&
            Object.keys(r.breakpoints).filter(
              (t) => void 0 !== r.breakpoints[t].slidesPerView
            ).length > 0;
          for (let s = 0; s < p; s += 1) {
            k = 0;
            const a = u.eq(s);
            if (
              (x && t.grid.updateSlide(s, a, p, e), "none" !== a.css("display"))
            ) {
              if ("auto" === r.slidesPerView) {
                E && (u[s].style[e("width")] = "");
                const i = getComputedStyle(a[0]),
                  o = a[0].style.transform,
                  l = a[0].style.webkitTransform;
                if (
                  (o && (a[0].style.transform = "none"),
                  l && (a[0].style.webkitTransform = "none"),
                  r.roundLengths)
                )
                  k = t.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0);
                else {
                  const t = n(i, "width"),
                    e = n(i, "padding-left"),
                    r = n(i, "padding-right"),
                    s = n(i, "margin-left"),
                    o = n(i, "margin-right"),
                    l = i.getPropertyValue("box-sizing");
                  if (l && "border-box" === l) k = t + s + o;
                  else {
                    const { clientWidth: n, offsetWidth: i } = a[0];
                    k = t + e + r + s + o + (i - n);
                  }
                }
                o && (a[0].style.transform = o),
                  l && (a[0].style.webkitTransform = l),
                  r.roundLengths && (k = Math.floor(k));
              } else
                (k = (i - (r.slidesPerView - 1) * _) / r.slidesPerView),
                  r.roundLengths && (k = Math.floor(k)),
                  u[s] && (u[s].style[e("width")] = `${k}px`);
              u[s] && (u[s].swiperSlideSize = k),
                h.push(k),
                r.centeredSlides
                  ? ((w = w + k / 2 + S / 2 + _),
                    0 === S && 0 !== s && (w = w - i / 2 - _),
                    0 === s && (w = w - i / 2 - _),
                    Math.abs(w) < 0.001 && (w = 0),
                    r.roundLengths && (w = Math.floor(w)),
                    C % r.slidesPerGroup == 0 && d.push(w),
                    f.push(w))
                  : (r.roundLengths && (w = Math.floor(w)),
                    (C - Math.min(t.params.slidesPerGroupSkip, C)) %
                      t.params.slidesPerGroup ==
                      0 && d.push(w),
                    f.push(w),
                    (w = w + k + _)),
                (t.virtualSize += k + _),
                (S = k),
                (C += 1);
            }
          }
          if (
            ((t.virtualSize = Math.max(t.virtualSize, i) + g),
            a &&
              o &&
              ("slide" === r.effect || "coverflow" === r.effect) &&
              s.css({ width: `${t.virtualSize + r.spaceBetween}px` }),
            r.setWrapperSize &&
              s.css({ [e("width")]: `${t.virtualSize + r.spaceBetween}px` }),
            x && t.grid.updateWrapperSize(k, d, e),
            !r.centeredSlides)
          ) {
            const e = [];
            for (let n = 0; n < d.length; n += 1) {
              let s = d[n];
              r.roundLengths && (s = Math.floor(s)),
                d[n] <= t.virtualSize - i && e.push(s);
            }
            (d = e),
              Math.floor(t.virtualSize - i) - Math.floor(d[d.length - 1]) > 1 &&
                d.push(t.virtualSize - i);
          }
          if ((0 === d.length && (d = [0]), 0 !== r.spaceBetween)) {
            const n = t.isHorizontal() && a ? "marginLeft" : e("marginRight");
            u.filter((t, e) => !r.cssMode || e !== u.length - 1).css({
              [n]: `${_}px`,
            });
          }
          if (r.centeredSlides && r.centeredSlidesBounds) {
            let t = 0;
            h.forEach((e) => {
              t += e + (r.spaceBetween ? r.spaceBetween : 0);
            }),
              (t -= r.spaceBetween);
            const e = t - i;
            d = d.map((t) => (t < 0 ? -m : t > e ? e + g : t));
          }
          if (r.centerInsufficientSlides) {
            let t = 0;
            if (
              (h.forEach((e) => {
                t += e + (r.spaceBetween ? r.spaceBetween : 0);
              }),
              (t -= r.spaceBetween),
              t < i)
            ) {
              const e = (i - t) / 2;
              d.forEach((t, n) => {
                d[n] = t - e;
              }),
                f.forEach((t, n) => {
                  f[n] = t + e;
                });
            }
          }
          if (
            (Object.assign(t, {
              slides: u,
              snapGrid: d,
              slidesGrid: f,
              slidesSizesGrid: h,
            }),
            r.centeredSlides && r.cssMode && !r.centeredSlidesBounds)
          ) {
            v(t.wrapperEl, "--swiper-centered-offset-before", -d[0] + "px"),
              v(
                t.wrapperEl,
                "--swiper-centered-offset-after",
                t.size / 2 - h[h.length - 1] / 2 + "px"
              );
            const e = -t.snapGrid[0],
              n = -t.slidesGrid[0];
            (t.snapGrid = t.snapGrid.map((t) => t + e)),
              (t.slidesGrid = t.slidesGrid.map((t) => t + n));
          }
          if (
            (p !== c && t.emit("slidesLengthChange"),
            d.length !== y &&
              (t.params.watchOverflow && t.checkOverflow(),
              t.emit("snapGridLengthChange")),
            f.length !== b && t.emit("slidesGridLengthChange"),
            r.watchSlidesProgress && t.updateSlidesOffset(),
            !(l || r.cssMode || ("slide" !== r.effect && "fade" !== r.effect)))
          ) {
            const e = `${r.containerModifierClass}backface-hidden`,
              n = t.$el.hasClass(e);
            p <= r.maxBackfaceHiddenSlides
              ? n || t.$el.addClass(e)
              : n && t.$el.removeClass(e);
          }
        },
        updateAutoHeight: function (t) {
          const e = this,
            n = [],
            r = e.virtual && e.params.virtual.enabled;
          let s,
            i = 0;
          "number" == typeof t
            ? e.setTransition(t)
            : !0 === t && e.setTransition(e.params.speed);
          const a = (t) =>
            r
              ? e.slides.filter(
                  (e) =>
                    parseInt(e.getAttribute("data-swiper-slide-index"), 10) ===
                    t
                )[0]
              : e.slides.eq(t)[0];
          if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
            if (e.params.centeredSlides)
              (e.visibleSlides || c([])).each((t) => {
                n.push(t);
              });
            else
              for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
                const t = e.activeIndex + s;
                if (t > e.slides.length && !r) break;
                n.push(a(t));
              }
          else n.push(a(e.activeIndex));
          for (s = 0; s < n.length; s += 1)
            if (void 0 !== n[s]) {
              const t = n[s].offsetHeight;
              i = t > i ? t : i;
            }
          (i || 0 === i) && e.$wrapperEl.css("height", `${i}px`);
        },
        updateSlidesOffset: function () {
          const t = this,
            e = t.slides;
          for (let n = 0; n < e.length; n += 1)
            e[n].swiperSlideOffset = t.isHorizontal()
              ? e[n].offsetLeft
              : e[n].offsetTop;
        },
        updateSlidesProgress: function (t) {
          void 0 === t && (t = (this && this.translate) || 0);
          const e = this,
            n = e.params,
            { slides: r, rtlTranslate: s, snapGrid: i } = e;
          if (0 === r.length) return;
          void 0 === r[0].swiperSlideOffset && e.updateSlidesOffset();
          let a = -t;
          s && (a = t),
            r.removeClass(n.slideVisibleClass),
            (e.visibleSlidesIndexes = []),
            (e.visibleSlides = []);
          for (let t = 0; t < r.length; t += 1) {
            const o = r[t];
            let l = o.swiperSlideOffset;
            n.cssMode && n.centeredSlides && (l -= r[0].swiperSlideOffset);
            const c =
                (a + (n.centeredSlides ? e.minTranslate() : 0) - l) /
                (o.swiperSlideSize + n.spaceBetween),
              u =
                (a - i[0] + (n.centeredSlides ? e.minTranslate() : 0) - l) /
                (o.swiperSlideSize + n.spaceBetween),
              p = -(a - l),
              d = p + e.slidesSizesGrid[t];
            ((p >= 0 && p < e.size - 1) ||
              (d > 1 && d <= e.size) ||
              (p <= 0 && d >= e.size)) &&
              (e.visibleSlides.push(o),
              e.visibleSlidesIndexes.push(t),
              r.eq(t).addClass(n.slideVisibleClass)),
              (o.progress = s ? -c : c),
              (o.originalProgress = s ? -u : u);
          }
          e.visibleSlides = c(e.visibleSlides);
        },
        updateProgress: function (t) {
          const e = this;
          if (void 0 === t) {
            const n = e.rtlTranslate ? -1 : 1;
            t = (e && e.translate && e.translate * n) || 0;
          }
          const n = e.params,
            r = e.maxTranslate() - e.minTranslate();
          let { progress: s, isBeginning: i, isEnd: a } = e;
          const o = i,
            l = a;
          0 === r
            ? ((s = 0), (i = !0), (a = !0))
            : ((s = (t - e.minTranslate()) / r), (i = s <= 0), (a = s >= 1)),
            Object.assign(e, { progress: s, isBeginning: i, isEnd: a }),
            (n.watchSlidesProgress || (n.centeredSlides && n.autoHeight)) &&
              e.updateSlidesProgress(t),
            i && !o && e.emit("reachBeginning toEdge"),
            a && !l && e.emit("reachEnd toEdge"),
            ((o && !i) || (l && !a)) && e.emit("fromEdge"),
            e.emit("progress", s);
        },
        updateSlidesClasses: function () {
          const t = this,
            {
              slides: e,
              params: n,
              $wrapperEl: r,
              activeIndex: s,
              realIndex: i,
            } = t,
            a = t.virtual && n.virtual.enabled;
          let o;
          e.removeClass(
            `${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`
          ),
            (o = a
              ? t.$wrapperEl.find(
                  `.${n.slideClass}[data-swiper-slide-index="${s}"]`
                )
              : e.eq(s)),
            o.addClass(n.slideActiveClass),
            n.loop &&
              (o.hasClass(n.slideDuplicateClass)
                ? r
                    .children(
                      `.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${i}"]`
                    )
                    .addClass(n.slideDuplicateActiveClass)
                : r
                    .children(
                      `.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${i}"]`
                    )
                    .addClass(n.slideDuplicateActiveClass));
          let l = o
            .nextAll(`.${n.slideClass}`)
            .eq(0)
            .addClass(n.slideNextClass);
          n.loop &&
            0 === l.length &&
            ((l = e.eq(0)), l.addClass(n.slideNextClass));
          let c = o
            .prevAll(`.${n.slideClass}`)
            .eq(0)
            .addClass(n.slidePrevClass);
          n.loop &&
            0 === c.length &&
            ((c = e.eq(-1)), c.addClass(n.slidePrevClass)),
            n.loop &&
              (l.hasClass(n.slideDuplicateClass)
                ? r
                    .children(
                      `.${n.slideClass}:not(.${
                        n.slideDuplicateClass
                      })[data-swiper-slide-index="${l.attr(
                        "data-swiper-slide-index"
                      )}"]`
                    )
                    .addClass(n.slideDuplicateNextClass)
                : r
                    .children(
                      `.${n.slideClass}.${
                        n.slideDuplicateClass
                      }[data-swiper-slide-index="${l.attr(
                        "data-swiper-slide-index"
                      )}"]`
                    )
                    .addClass(n.slideDuplicateNextClass),
              c.hasClass(n.slideDuplicateClass)
                ? r
                    .children(
                      `.${n.slideClass}:not(.${
                        n.slideDuplicateClass
                      })[data-swiper-slide-index="${c.attr(
                        "data-swiper-slide-index"
                      )}"]`
                    )
                    .addClass(n.slideDuplicatePrevClass)
                : r
                    .children(
                      `.${n.slideClass}.${
                        n.slideDuplicateClass
                      }[data-swiper-slide-index="${c.attr(
                        "data-swiper-slide-index"
                      )}"]`
                    )
                    .addClass(n.slideDuplicatePrevClass)),
            t.emitSlidesClasses();
        },
        updateActiveIndex: function (t) {
          const e = this,
            n = e.rtlTranslate ? e.translate : -e.translate,
            {
              slidesGrid: r,
              snapGrid: s,
              params: i,
              activeIndex: a,
              realIndex: o,
              snapIndex: l,
            } = e;
          let c,
            u = t;
          if (void 0 === u) {
            for (let t = 0; t < r.length; t += 1)
              void 0 !== r[t + 1]
                ? n >= r[t] && n < r[t + 1] - (r[t + 1] - r[t]) / 2
                  ? (u = t)
                  : n >= r[t] && n < r[t + 1] && (u = t + 1)
                : n >= r[t] && (u = t);
            i.normalizeSlideIndex && (u < 0 || void 0 === u) && (u = 0);
          }
          if (s.indexOf(n) >= 0) c = s.indexOf(n);
          else {
            const t = Math.min(i.slidesPerGroupSkip, u);
            c = t + Math.floor((u - t) / i.slidesPerGroup);
          }
          if ((c >= s.length && (c = s.length - 1), u === a))
            return void (
              c !== l && ((e.snapIndex = c), e.emit("snapIndexChange"))
            );
          const p = parseInt(
            e.slides.eq(u).attr("data-swiper-slide-index") || u,
            10
          );
          Object.assign(e, {
            snapIndex: c,
            realIndex: p,
            previousIndex: a,
            activeIndex: u,
          }),
            e.emit("activeIndexChange"),
            e.emit("snapIndexChange"),
            o !== p && e.emit("realIndexChange"),
            (e.initialized || e.params.runCallbacksOnInit) &&
              e.emit("slideChange");
        },
        updateClickedSlide: function (t) {
          const e = this,
            n = e.params,
            r = c(t).closest(`.${n.slideClass}`)[0];
          let s,
            i = !1;
          if (r)
            for (let t = 0; t < e.slides.length; t += 1)
              if (e.slides[t] === r) {
                (i = !0), (s = t);
                break;
              }
          if (!r || !i)
            return (e.clickedSlide = void 0), void (e.clickedIndex = void 0);
          (e.clickedSlide = r),
            e.virtual && e.params.virtual.enabled
              ? (e.clickedIndex = parseInt(
                  c(r).attr("data-swiper-slide-index"),
                  10
                ))
              : (e.clickedIndex = s),
            n.slideToClickedSlide &&
              void 0 !== e.clickedIndex &&
              e.clickedIndex !== e.activeIndex &&
              e.slideToClickedSlide();
        },
      },
      T = {
        getTranslate: function (t) {
          void 0 === t && (t = this.isHorizontal() ? "x" : "y");
          const {
            params: e,
            rtlTranslate: n,
            translate: r,
            $wrapperEl: s,
          } = this;
          if (e.virtualTranslate) return n ? -r : r;
          if (e.cssMode) return r;
          let i = f(s[0], t);
          return n && (i = -i), i || 0;
        },
        setTranslate: function (t, e) {
          const n = this,
            {
              rtlTranslate: r,
              params: s,
              $wrapperEl: i,
              wrapperEl: a,
              progress: o,
            } = n;
          let l,
            c = 0,
            u = 0;
          n.isHorizontal() ? (c = r ? -t : t) : (u = t),
            s.roundLengths && ((c = Math.floor(c)), (u = Math.floor(u))),
            s.cssMode
              ? (a[n.isHorizontal() ? "scrollLeft" : "scrollTop"] =
                  n.isHorizontal() ? -c : -u)
              : s.virtualTranslate ||
                i.transform(`translate3d(${c}px, ${u}px, 0px)`),
            (n.previousTranslate = n.translate),
            (n.translate = n.isHorizontal() ? c : u);
          const p = n.maxTranslate() - n.minTranslate();
          (l = 0 === p ? 0 : (t - n.minTranslate()) / p),
            l !== o && n.updateProgress(t),
            n.emit("setTranslate", n.translate, e);
        },
        minTranslate: function () {
          return -this.snapGrid[0];
        },
        maxTranslate: function () {
          return -this.snapGrid[this.snapGrid.length - 1];
        },
        translateTo: function (t, e, n, r, s) {
          void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === n && (n = !0),
            void 0 === r && (r = !0);
          const i = this,
            { params: a, wrapperEl: o } = i;
          if (i.animating && a.preventInteractionOnTransition) return !1;
          const l = i.minTranslate(),
            c = i.maxTranslate();
          let u;
          if (
            ((u = r && t > l ? l : r && t < c ? c : t),
            i.updateProgress(u),
            a.cssMode)
          ) {
            const t = i.isHorizontal();
            if (0 === e) o[t ? "scrollLeft" : "scrollTop"] = -u;
            else {
              if (!i.support.smoothScroll)
                return (
                  y({
                    swiper: i,
                    targetPosition: -u,
                    side: t ? "left" : "top",
                  }),
                  !0
                );
              o.scrollTo({ [t ? "left" : "top"]: -u, behavior: "smooth" });
            }
            return !0;
          }
          return (
            0 === e
              ? (i.setTransition(0),
                i.setTranslate(u),
                n &&
                  (i.emit("beforeTransitionStart", e, s),
                  i.emit("transitionEnd")))
              : (i.setTransition(e),
                i.setTranslate(u),
                n &&
                  (i.emit("beforeTransitionStart", e, s),
                  i.emit("transitionStart")),
                i.animating ||
                  ((i.animating = !0),
                  i.onTranslateToWrapperTransitionEnd ||
                    (i.onTranslateToWrapperTransitionEnd = function (t) {
                      i &&
                        !i.destroyed &&
                        t.target === this &&
                        (i.$wrapperEl[0].removeEventListener(
                          "transitionend",
                          i.onTranslateToWrapperTransitionEnd
                        ),
                        i.$wrapperEl[0].removeEventListener(
                          "webkitTransitionEnd",
                          i.onTranslateToWrapperTransitionEnd
                        ),
                        (i.onTranslateToWrapperTransitionEnd = null),
                        delete i.onTranslateToWrapperTransitionEnd,
                        n && i.emit("transitionEnd"));
                    }),
                  i.$wrapperEl[0].addEventListener(
                    "transitionend",
                    i.onTranslateToWrapperTransitionEnd
                  ),
                  i.$wrapperEl[0].addEventListener(
                    "webkitTransitionEnd",
                    i.onTranslateToWrapperTransitionEnd
                  ))),
            !0
          );
        },
      };
    function P(t) {
      let { swiper: e, runCallbacks: n, direction: r, step: s } = t;
      const { activeIndex: i, previousIndex: a } = e;
      let o = r;
      if (
        (o || (o = i > a ? "next" : i < a ? "prev" : "reset"),
        e.emit(`transition${s}`),
        n && i !== a)
      ) {
        if ("reset" === o) return void e.emit(`slideResetTransition${s}`);
        e.emit(`slideChangeTransition${s}`),
          "next" === o
            ? e.emit(`slideNextTransition${s}`)
            : e.emit(`slidePrevTransition${s}`);
      }
    }
    var M = {
        slideTo: function (t, e, n, r, s) {
          if (
            (void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === n && (n = !0),
            "number" != typeof t && "string" != typeof t)
          )
            throw new Error(
              `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`
            );
          if ("string" == typeof t) {
            const e = parseInt(t, 10);
            if (!isFinite(e))
              throw new Error(
                `The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`
              );
            t = e;
          }
          const i = this;
          let a = t;
          a < 0 && (a = 0);
          const {
            params: o,
            snapGrid: l,
            slidesGrid: c,
            previousIndex: u,
            activeIndex: p,
            rtlTranslate: d,
            wrapperEl: f,
            enabled: h,
          } = i;
          if (
            (i.animating && o.preventInteractionOnTransition) ||
            (!h && !r && !s)
          )
            return !1;
          const m = Math.min(i.params.slidesPerGroupSkip, a);
          let g = m + Math.floor((a - m) / i.params.slidesPerGroup);
          g >= l.length && (g = l.length - 1);
          const v = -l[g];
          if (o.normalizeSlideIndex)
            for (let t = 0; t < c.length; t += 1) {
              const e = -Math.floor(100 * v),
                n = Math.floor(100 * c[t]),
                r = Math.floor(100 * c[t + 1]);
              void 0 !== c[t + 1]
                ? e >= n && e < r - (r - n) / 2
                  ? (a = t)
                  : e >= n && e < r && (a = t + 1)
                : e >= n && (a = t);
            }
          if (i.initialized && a !== p) {
            if (!i.allowSlideNext && v < i.translate && v < i.minTranslate())
              return !1;
            if (
              !i.allowSlidePrev &&
              v > i.translate &&
              v > i.maxTranslate() &&
              (p || 0) !== a
            )
              return !1;
          }
          let b;
          if (
            (a !== (u || 0) && n && i.emit("beforeSlideChangeStart"),
            i.updateProgress(v),
            (b = a > p ? "next" : a < p ? "prev" : "reset"),
            (d && -v === i.translate) || (!d && v === i.translate))
          )
            return (
              i.updateActiveIndex(a),
              o.autoHeight && i.updateAutoHeight(),
              i.updateSlidesClasses(),
              "slide" !== o.effect && i.setTranslate(v),
              "reset" !== b && (i.transitionStart(n, b), i.transitionEnd(n, b)),
              !1
            );
          if (o.cssMode) {
            const t = i.isHorizontal(),
              n = d ? v : -v;
            if (0 === e) {
              const e = i.virtual && i.params.virtual.enabled;
              e &&
                ((i.wrapperEl.style.scrollSnapType = "none"),
                (i._immediateVirtual = !0)),
                (f[t ? "scrollLeft" : "scrollTop"] = n),
                e &&
                  requestAnimationFrame(() => {
                    (i.wrapperEl.style.scrollSnapType = ""),
                      (i._swiperImmediateVirtual = !1);
                  });
            } else {
              if (!i.support.smoothScroll)
                return (
                  y({ swiper: i, targetPosition: n, side: t ? "left" : "top" }),
                  !0
                );
              f.scrollTo({ [t ? "left" : "top"]: n, behavior: "smooth" });
            }
            return !0;
          }
          return (
            i.setTransition(e),
            i.setTranslate(v),
            i.updateActiveIndex(a),
            i.updateSlidesClasses(),
            i.emit("beforeTransitionStart", e, r),
            i.transitionStart(n, b),
            0 === e
              ? i.transitionEnd(n, b)
              : i.animating ||
                ((i.animating = !0),
                i.onSlideToWrapperTransitionEnd ||
                  (i.onSlideToWrapperTransitionEnd = function (t) {
                    i &&
                      !i.destroyed &&
                      t.target === this &&
                      (i.$wrapperEl[0].removeEventListener(
                        "transitionend",
                        i.onSlideToWrapperTransitionEnd
                      ),
                      i.$wrapperEl[0].removeEventListener(
                        "webkitTransitionEnd",
                        i.onSlideToWrapperTransitionEnd
                      ),
                      (i.onSlideToWrapperTransitionEnd = null),
                      delete i.onSlideToWrapperTransitionEnd,
                      i.transitionEnd(n, b));
                  }),
                i.$wrapperEl[0].addEventListener(
                  "transitionend",
                  i.onSlideToWrapperTransitionEnd
                ),
                i.$wrapperEl[0].addEventListener(
                  "webkitTransitionEnd",
                  i.onSlideToWrapperTransitionEnd
                )),
            !0
          );
        },
        slideToLoop: function (t, e, n, r) {
          if (
            (void 0 === t && (t = 0),
            void 0 === e && (e = this.params.speed),
            void 0 === n && (n = !0),
            "string" == typeof t)
          ) {
            const e = parseInt(t, 10);
            if (!isFinite(e))
              throw new Error(
                `The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`
              );
            t = e;
          }
          const s = this;
          let i = t;
          return s.params.loop && (i += s.loopedSlides), s.slideTo(i, e, n, r);
        },
        slideNext: function (t, e, n) {
          void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
          const r = this,
            { animating: s, enabled: i, params: a } = r;
          if (!i) return r;
          let o = a.slidesPerGroup;
          "auto" === a.slidesPerView &&
            1 === a.slidesPerGroup &&
            a.slidesPerGroupAuto &&
            (o = Math.max(r.slidesPerViewDynamic("current", !0), 1));
          const l = r.activeIndex < a.slidesPerGroupSkip ? 1 : o;
          if (a.loop) {
            if (s && a.loopPreventsSlide) return !1;
            r.loopFix(), (r._clientLeft = r.$wrapperEl[0].clientLeft);
          }
          return a.rewind && r.isEnd
            ? r.slideTo(0, t, e, n)
            : r.slideTo(r.activeIndex + l, t, e, n);
        },
        slidePrev: function (t, e, n) {
          void 0 === t && (t = this.params.speed), void 0 === e && (e = !0);
          const r = this,
            {
              params: s,
              animating: i,
              snapGrid: a,
              slidesGrid: o,
              rtlTranslate: l,
              enabled: c,
            } = r;
          if (!c) return r;
          if (s.loop) {
            if (i && s.loopPreventsSlide) return !1;
            r.loopFix(), (r._clientLeft = r.$wrapperEl[0].clientLeft);
          }
          function u(t) {
            return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t);
          }
          const p = u(l ? r.translate : -r.translate),
            d = a.map((t) => u(t));
          let f = a[d.indexOf(p) - 1];
          if (void 0 === f && s.cssMode) {
            let t;
            a.forEach((e, n) => {
              p >= e && (t = n);
            }),
              void 0 !== t && (f = a[t > 0 ? t - 1 : t]);
          }
          let h = 0;
          if (
            (void 0 !== f &&
              ((h = o.indexOf(f)),
              h < 0 && (h = r.activeIndex - 1),
              "auto" === s.slidesPerView &&
                1 === s.slidesPerGroup &&
                s.slidesPerGroupAuto &&
                ((h = h - r.slidesPerViewDynamic("previous", !0) + 1),
                (h = Math.max(h, 0)))),
            s.rewind && r.isBeginning)
          ) {
            const s =
              r.params.virtual && r.params.virtual.enabled && r.virtual
                ? r.virtual.slides.length - 1
                : r.slides.length - 1;
            return r.slideTo(s, t, e, n);
          }
          return r.slideTo(h, t, e, n);
        },
        slideReset: function (t, e, n) {
          return (
            void 0 === t && (t = this.params.speed),
            void 0 === e && (e = !0),
            this.slideTo(this.activeIndex, t, e, n)
          );
        },
        slideToClosest: function (t, e, n, r) {
          void 0 === t && (t = this.params.speed),
            void 0 === e && (e = !0),
            void 0 === r && (r = 0.5);
          const s = this;
          let i = s.activeIndex;
          const a = Math.min(s.params.slidesPerGroupSkip, i),
            o = a + Math.floor((i - a) / s.params.slidesPerGroup),
            l = s.rtlTranslate ? s.translate : -s.translate;
          if (l >= s.snapGrid[o]) {
            const t = s.snapGrid[o];
            l - t > (s.snapGrid[o + 1] - t) * r &&
              (i += s.params.slidesPerGroup);
          } else {
            const t = s.snapGrid[o - 1];
            l - t <= (s.snapGrid[o] - t) * r && (i -= s.params.slidesPerGroup);
          }
          return (
            (i = Math.max(i, 0)),
            (i = Math.min(i, s.slidesGrid.length - 1)),
            s.slideTo(i, t, e, n)
          );
        },
        slideToClickedSlide: function () {
          const t = this,
            { params: e, $wrapperEl: n } = t,
            r =
              "auto" === e.slidesPerView
                ? t.slidesPerViewDynamic()
                : e.slidesPerView;
          let s,
            i = t.clickedIndex;
          if (e.loop) {
            if (t.animating) return;
            (s = parseInt(
              c(t.clickedSlide).attr("data-swiper-slide-index"),
              10
            )),
              e.centeredSlides
                ? i < t.loopedSlides - r / 2 ||
                  i > t.slides.length - t.loopedSlides + r / 2
                  ? (t.loopFix(),
                    (i = n
                      .children(
                        `.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`
                      )
                      .eq(0)
                      .index()),
                    p(() => {
                      t.slideTo(i);
                    }))
                  : t.slideTo(i)
                : i > t.slides.length - r
                ? (t.loopFix(),
                  (i = n
                    .children(
                      `.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`
                    )
                    .eq(0)
                    .index()),
                  p(() => {
                    t.slideTo(i);
                  }))
                : t.slideTo(i);
          } else t.slideTo(i);
        },
      },
      O = {
        loopCreate: function () {
          const t = this,
            e = r(),
            { params: n, $wrapperEl: s } = t,
            i = s.children().length > 0 ? c(s.children()[0].parentNode) : s;
          i.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
          let a = i.children(`.${n.slideClass}`);
          if (n.loopFillGroupWithBlank) {
            const t = n.slidesPerGroup - (a.length % n.slidesPerGroup);
            if (t !== n.slidesPerGroup) {
              for (let r = 0; r < t; r += 1) {
                const t = c(e.createElement("div")).addClass(
                  `${n.slideClass} ${n.slideBlankClass}`
                );
                i.append(t);
              }
              a = i.children(`.${n.slideClass}`);
            }
          }
          "auto" !== n.slidesPerView ||
            n.loopedSlides ||
            (n.loopedSlides = a.length),
            (t.loopedSlides = Math.ceil(
              parseFloat(n.loopedSlides || n.slidesPerView, 10)
            )),
            (t.loopedSlides += n.loopAdditionalSlides),
            t.loopedSlides > a.length &&
              t.params.loopedSlidesLimit &&
              (t.loopedSlides = a.length);
          const o = [],
            l = [];
          a.each((t, e) => {
            c(t).attr("data-swiper-slide-index", e);
          });
          for (let e = 0; e < t.loopedSlides; e += 1) {
            const t = e - Math.floor(e / a.length) * a.length;
            l.push(a.eq(t)[0]), o.unshift(a.eq(a.length - t - 1)[0]);
          }
          for (let t = 0; t < l.length; t += 1)
            i.append(c(l[t].cloneNode(!0)).addClass(n.slideDuplicateClass));
          for (let t = o.length - 1; t >= 0; t -= 1)
            i.prepend(c(o[t].cloneNode(!0)).addClass(n.slideDuplicateClass));
        },
        loopFix: function () {
          const t = this;
          t.emit("beforeLoopFix");
          const {
            activeIndex: e,
            slides: n,
            loopedSlides: r,
            allowSlidePrev: s,
            allowSlideNext: i,
            snapGrid: a,
            rtlTranslate: o,
          } = t;
          let l;
          (t.allowSlidePrev = !0), (t.allowSlideNext = !0);
          const c = -a[e] - t.getTranslate();
          e < r
            ? ((l = n.length - 3 * r + e),
              (l += r),
              t.slideTo(l, 0, !1, !0) &&
                0 !== c &&
                t.setTranslate((o ? -t.translate : t.translate) - c))
            : e >= n.length - r &&
              ((l = -n.length + e + r),
              (l += r),
              t.slideTo(l, 0, !1, !0) &&
                0 !== c &&
                t.setTranslate((o ? -t.translate : t.translate) - c)),
            (t.allowSlidePrev = s),
            (t.allowSlideNext = i),
            t.emit("loopFix");
        },
        loopDestroy: function () {
          const { $wrapperEl: t, params: e, slides: n } = this;
          t
            .children(
              `.${e.slideClass}.${e.slideDuplicateClass},.${e.slideClass}.${e.slideBlankClass}`
            )
            .remove(),
            n.removeAttr("data-swiper-slide-index");
        },
      };
    function A(t) {
      const e = this,
        n = r(),
        s = i(),
        a = e.touchEventsData,
        { params: o, touches: l, enabled: u } = e;
      if (!u) return;
      if (e.animating && o.preventInteractionOnTransition) return;
      !e.animating && o.cssMode && o.loop && e.loopFix();
      let p = t;
      p.originalEvent && (p = p.originalEvent);
      let f = c(p.target);
      if ("wrapper" === o.touchEventsTarget && !f.closest(e.wrapperEl).length)
        return;
      if (
        ((a.isTouchEvent = "touchstart" === p.type),
        !a.isTouchEvent && "which" in p && 3 === p.which)
      )
        return;
      if (!a.isTouchEvent && "button" in p && p.button > 0) return;
      if (a.isTouched && a.isMoved) return;
      const h = !!o.noSwipingClass && "" !== o.noSwipingClass,
        m = t.composedPath ? t.composedPath() : t.path;
      h && p.target && p.target.shadowRoot && m && (f = c(m[0]));
      const g = o.noSwipingSelector
          ? o.noSwipingSelector
          : `.${o.noSwipingClass}`,
        v = !(!p.target || !p.target.shadowRoot);
      if (
        o.noSwiping &&
        (v
          ? (function (t, e) {
              return (
                void 0 === e && (e = this),
                (function e(n) {
                  if (!n || n === r() || n === i()) return null;
                  n.assignedSlot && (n = n.assignedSlot);
                  const s = n.closest(t);
                  return s || n.getRootNode
                    ? s || e(n.getRootNode().host)
                    : null;
                })(e)
              );
            })(g, f[0])
          : f.closest(g)[0])
      )
        return void (e.allowClick = !0);
      if (o.swipeHandler && !f.closest(o.swipeHandler)[0]) return;
      (l.currentX =
        "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX),
        (l.currentY =
          "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY);
      const y = l.currentX,
        b = l.currentY,
        _ = o.edgeSwipeDetection || o.iOSEdgeSwipeDetection,
        w = o.edgeSwipeThreshold || o.iOSEdgeSwipeThreshold;
      if (_ && (y <= w || y >= s.innerWidth - w)) {
        if ("prevent" !== _) return;
        t.preventDefault();
      }
      if (
        (Object.assign(a, {
          isTouched: !0,
          isMoved: !1,
          allowTouchCallbacks: !0,
          isScrolling: void 0,
          startMoving: void 0,
        }),
        (l.startX = y),
        (l.startY = b),
        (a.touchStartTime = d()),
        (e.allowClick = !0),
        e.updateSize(),
        (e.swipeDirection = void 0),
        o.threshold > 0 && (a.allowThresholdMove = !1),
        "touchstart" !== p.type)
      ) {
        let t = !0;
        f.is(a.focusableElements) &&
          ((t = !1), "SELECT" === f[0].nodeName && (a.isTouched = !1)),
          n.activeElement &&
            c(n.activeElement).is(a.focusableElements) &&
            n.activeElement !== f[0] &&
            n.activeElement.blur();
        const r = t && e.allowTouchMove && o.touchStartPreventDefault;
        (!o.touchStartForcePreventDefault && !r) ||
          f[0].isContentEditable ||
          p.preventDefault();
      }
      e.params.freeMode &&
        e.params.freeMode.enabled &&
        e.freeMode &&
        e.animating &&
        !o.cssMode &&
        e.freeMode.onTouchStart(),
        e.emit("touchStart", p);
    }
    function j(t) {
      const e = r(),
        n = this,
        s = n.touchEventsData,
        { params: i, touches: a, rtlTranslate: o, enabled: l } = n;
      if (!l) return;
      let u = t;
      if ((u.originalEvent && (u = u.originalEvent), !s.isTouched))
        return void (
          s.startMoving &&
          s.isScrolling &&
          n.emit("touchMoveOpposite", u)
        );
      if (s.isTouchEvent && "touchmove" !== u.type) return;
      const p =
          "touchmove" === u.type &&
          u.targetTouches &&
          (u.targetTouches[0] || u.changedTouches[0]),
        f = "touchmove" === u.type ? p.pageX : u.pageX,
        h = "touchmove" === u.type ? p.pageY : u.pageY;
      if (u.preventedByNestedSwiper) return (a.startX = f), void (a.startY = h);
      if (!n.allowTouchMove)
        return (
          c(u.target).is(s.focusableElements) || (n.allowClick = !1),
          void (
            s.isTouched &&
            (Object.assign(a, {
              startX: f,
              startY: h,
              currentX: f,
              currentY: h,
            }),
            (s.touchStartTime = d()))
          )
        );
      if (s.isTouchEvent && i.touchReleaseOnEdges && !i.loop)
        if (n.isVertical()) {
          if (
            (h < a.startY && n.translate <= n.maxTranslate()) ||
            (h > a.startY && n.translate >= n.minTranslate())
          )
            return (s.isTouched = !1), void (s.isMoved = !1);
        } else if (
          (f < a.startX && n.translate <= n.maxTranslate()) ||
          (f > a.startX && n.translate >= n.minTranslate())
        )
          return;
      if (
        s.isTouchEvent &&
        e.activeElement &&
        u.target === e.activeElement &&
        c(u.target).is(s.focusableElements)
      )
        return (s.isMoved = !0), void (n.allowClick = !1);
      if (
        (s.allowTouchCallbacks && n.emit("touchMove", u),
        u.targetTouches && u.targetTouches.length > 1)
      )
        return;
      (a.currentX = f), (a.currentY = h);
      const m = a.currentX - a.startX,
        g = a.currentY - a.startY;
      if (n.params.threshold && Math.sqrt(m ** 2 + g ** 2) < n.params.threshold)
        return;
      if (void 0 === s.isScrolling) {
        let t;
        (n.isHorizontal() && a.currentY === a.startY) ||
        (n.isVertical() && a.currentX === a.startX)
          ? (s.isScrolling = !1)
          : m * m + g * g >= 25 &&
            ((t = (180 * Math.atan2(Math.abs(g), Math.abs(m))) / Math.PI),
            (s.isScrolling = n.isHorizontal()
              ? t > i.touchAngle
              : 90 - t > i.touchAngle));
      }
      if (
        (s.isScrolling && n.emit("touchMoveOpposite", u),
        void 0 === s.startMoving &&
          ((a.currentX === a.startX && a.currentY === a.startY) ||
            (s.startMoving = !0)),
        s.isScrolling)
      )
        return void (s.isTouched = !1);
      if (!s.startMoving) return;
      (n.allowClick = !1),
        !i.cssMode && u.cancelable && u.preventDefault(),
        i.touchMoveStopPropagation && !i.nested && u.stopPropagation(),
        s.isMoved ||
          (i.loop && !i.cssMode && n.loopFix(),
          (s.startTranslate = n.getTranslate()),
          n.setTransition(0),
          n.animating &&
            n.$wrapperEl.trigger("webkitTransitionEnd transitionend"),
          (s.allowMomentumBounce = !1),
          !i.grabCursor ||
            (!0 !== n.allowSlideNext && !0 !== n.allowSlidePrev) ||
            n.setGrabCursor(!0),
          n.emit("sliderFirstMove", u)),
        n.emit("sliderMove", u),
        (s.isMoved = !0);
      let v = n.isHorizontal() ? m : g;
      (a.diff = v),
        (v *= i.touchRatio),
        o && (v = -v),
        (n.swipeDirection = v > 0 ? "prev" : "next"),
        (s.currentTranslate = v + s.startTranslate);
      let y = !0,
        b = i.resistanceRatio;
      if (
        (i.touchReleaseOnEdges && (b = 0),
        v > 0 && s.currentTranslate > n.minTranslate()
          ? ((y = !1),
            i.resistance &&
              (s.currentTranslate =
                n.minTranslate() -
                1 +
                (-n.minTranslate() + s.startTranslate + v) ** b))
          : v < 0 &&
            s.currentTranslate < n.maxTranslate() &&
            ((y = !1),
            i.resistance &&
              (s.currentTranslate =
                n.maxTranslate() +
                1 -
                (n.maxTranslate() - s.startTranslate - v) ** b)),
        y && (u.preventedByNestedSwiper = !0),
        !n.allowSlideNext &&
          "next" === n.swipeDirection &&
          s.currentTranslate < s.startTranslate &&
          (s.currentTranslate = s.startTranslate),
        !n.allowSlidePrev &&
          "prev" === n.swipeDirection &&
          s.currentTranslate > s.startTranslate &&
          (s.currentTranslate = s.startTranslate),
        n.allowSlidePrev ||
          n.allowSlideNext ||
          (s.currentTranslate = s.startTranslate),
        i.threshold > 0)
      ) {
        if (!(Math.abs(v) > i.threshold || s.allowThresholdMove))
          return void (s.currentTranslate = s.startTranslate);
        if (!s.allowThresholdMove)
          return (
            (s.allowThresholdMove = !0),
            (a.startX = a.currentX),
            (a.startY = a.currentY),
            (s.currentTranslate = s.startTranslate),
            void (a.diff = n.isHorizontal()
              ? a.currentX - a.startX
              : a.currentY - a.startY)
          );
      }
      i.followFinger &&
        !i.cssMode &&
        (((i.freeMode && i.freeMode.enabled && n.freeMode) ||
          i.watchSlidesProgress) &&
          (n.updateActiveIndex(), n.updateSlidesClasses()),
        n.params.freeMode &&
          i.freeMode.enabled &&
          n.freeMode &&
          n.freeMode.onTouchMove(),
        n.updateProgress(s.currentTranslate),
        n.setTranslate(s.currentTranslate));
    }
    function $(t) {
      const e = this,
        n = e.touchEventsData,
        {
          params: r,
          touches: s,
          rtlTranslate: i,
          slidesGrid: a,
          enabled: o,
        } = e;
      if (!o) return;
      let l = t;
      if (
        (l.originalEvent && (l = l.originalEvent),
        n.allowTouchCallbacks && e.emit("touchEnd", l),
        (n.allowTouchCallbacks = !1),
        !n.isTouched)
      )
        return (
          n.isMoved && r.grabCursor && e.setGrabCursor(!1),
          (n.isMoved = !1),
          void (n.startMoving = !1)
        );
      r.grabCursor &&
        n.isMoved &&
        n.isTouched &&
        (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) &&
        e.setGrabCursor(!1);
      const c = d(),
        u = c - n.touchStartTime;
      if (e.allowClick) {
        const t = l.path || (l.composedPath && l.composedPath());
        e.updateClickedSlide((t && t[0]) || l.target),
          e.emit("tap click", l),
          u < 300 &&
            c - n.lastClickTime < 300 &&
            e.emit("doubleTap doubleClick", l);
      }
      if (
        ((n.lastClickTime = d()),
        p(() => {
          e.destroyed || (e.allowClick = !0);
        }),
        !n.isTouched ||
          !n.isMoved ||
          !e.swipeDirection ||
          0 === s.diff ||
          n.currentTranslate === n.startTranslate)
      )
        return (n.isTouched = !1), (n.isMoved = !1), void (n.startMoving = !1);
      let f;
      if (
        ((n.isTouched = !1),
        (n.isMoved = !1),
        (n.startMoving = !1),
        (f = r.followFinger
          ? i
            ? e.translate
            : -e.translate
          : -n.currentTranslate),
        r.cssMode)
      )
        return;
      if (e.params.freeMode && r.freeMode.enabled)
        return void e.freeMode.onTouchEnd({ currentPos: f });
      let h = 0,
        m = e.slidesSizesGrid[0];
      for (
        let t = 0;
        t < a.length;
        t += t < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup
      ) {
        const e = t < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        void 0 !== a[t + e]
          ? f >= a[t] && f < a[t + e] && ((h = t), (m = a[t + e] - a[t]))
          : f >= a[t] && ((h = t), (m = a[a.length - 1] - a[a.length - 2]));
      }
      let g = null,
        v = null;
      r.rewind &&
        (e.isBeginning
          ? (v =
              e.params.virtual && e.params.virtual.enabled && e.virtual
                ? e.virtual.slides.length - 1
                : e.slides.length - 1)
          : e.isEnd && (g = 0));
      const y = (f - a[h]) / m,
        b = h < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
      if (u > r.longSwipesMs) {
        if (!r.longSwipes) return void e.slideTo(e.activeIndex);
        "next" === e.swipeDirection &&
          (y >= r.longSwipesRatio
            ? e.slideTo(r.rewind && e.isEnd ? g : h + b)
            : e.slideTo(h)),
          "prev" === e.swipeDirection &&
            (y > 1 - r.longSwipesRatio
              ? e.slideTo(h + b)
              : null !== v && y < 0 && Math.abs(y) > r.longSwipesRatio
              ? e.slideTo(v)
              : e.slideTo(h));
      } else {
        if (!r.shortSwipes) return void e.slideTo(e.activeIndex);
        !e.navigation ||
        (l.target !== e.navigation.nextEl && l.target !== e.navigation.prevEl)
          ? ("next" === e.swipeDirection && e.slideTo(null !== g ? g : h + b),
            "prev" === e.swipeDirection && e.slideTo(null !== v ? v : h))
          : l.target === e.navigation.nextEl
          ? e.slideTo(h + b)
          : e.slideTo(h);
      }
    }
    function D() {
      const t = this,
        { params: e, el: n } = t;
      if (n && 0 === n.offsetWidth) return;
      e.breakpoints && t.setBreakpoint();
      const { allowSlideNext: r, allowSlidePrev: s, snapGrid: i } = t;
      (t.allowSlideNext = !0),
        (t.allowSlidePrev = !0),
        t.updateSize(),
        t.updateSlides(),
        t.updateSlidesClasses(),
        ("auto" === e.slidesPerView || e.slidesPerView > 1) &&
        t.isEnd &&
        !t.isBeginning &&
        !t.params.centeredSlides
          ? t.slideTo(t.slides.length - 1, 0, !1, !0)
          : t.slideTo(t.activeIndex, 0, !1, !0),
        t.autoplay &&
          t.autoplay.running &&
          t.autoplay.paused &&
          t.autoplay.run(),
        (t.allowSlidePrev = s),
        (t.allowSlideNext = r),
        t.params.watchOverflow && i !== t.snapGrid && t.checkOverflow();
    }
    function I(t) {
      const e = this;
      e.enabled &&
        (e.allowClick ||
          (e.params.preventClicks && t.preventDefault(),
          e.params.preventClicksPropagation &&
            e.animating &&
            (t.stopPropagation(), t.stopImmediatePropagation())));
    }
    function L() {
      const t = this,
        { wrapperEl: e, rtlTranslate: n, enabled: r } = t;
      if (!r) return;
      let s;
      (t.previousTranslate = t.translate),
        t.isHorizontal()
          ? (t.translate = -e.scrollLeft)
          : (t.translate = -e.scrollTop),
        0 === t.translate && (t.translate = 0),
        t.updateActiveIndex(),
        t.updateSlidesClasses();
      const i = t.maxTranslate() - t.minTranslate();
      (s = 0 === i ? 0 : (t.translate - t.minTranslate()) / i),
        s !== t.progress && t.updateProgress(n ? -t.translate : t.translate),
        t.emit("setTranslate", t.translate, !1);
    }
    let V = !1;
    function N() {}
    const H = (t, e) => {
      const n = r(),
        {
          params: s,
          touchEvents: i,
          el: a,
          wrapperEl: o,
          device: l,
          support: c,
        } = t,
        u = !!s.nested,
        p = "on" === e ? "addEventListener" : "removeEventListener",
        d = e;
      if (c.touch) {
        const e = !(
          "touchstart" !== i.start ||
          !c.passiveListener ||
          !s.passiveListeners
        ) && { passive: !0, capture: !1 };
        a[p](i.start, t.onTouchStart, e),
          a[p](
            i.move,
            t.onTouchMove,
            c.passiveListener ? { passive: !1, capture: u } : u
          ),
          a[p](i.end, t.onTouchEnd, e),
          i.cancel && a[p](i.cancel, t.onTouchEnd, e);
      } else
        a[p](i.start, t.onTouchStart, !1),
          n[p](i.move, t.onTouchMove, u),
          n[p](i.end, t.onTouchEnd, !1);
      (s.preventClicks || s.preventClicksPropagation) &&
        a[p]("click", t.onClick, !0),
        s.cssMode && o[p]("scroll", t.onScroll),
        s.updateOnWindowResize
          ? t[d](
              l.ios || l.android
                ? "resize orientationchange observerUpdate"
                : "resize observerUpdate",
              D,
              !0
            )
          : t[d]("observerUpdate", D, !0);
    };
    var R = {
      attachEvents: function () {
        const t = this,
          e = r(),
          { params: n, support: s } = t;
        (t.onTouchStart = A.bind(t)),
          (t.onTouchMove = j.bind(t)),
          (t.onTouchEnd = $.bind(t)),
          n.cssMode && (t.onScroll = L.bind(t)),
          (t.onClick = I.bind(t)),
          s.touch && !V && (e.addEventListener("touchstart", N), (V = !0)),
          H(t, "on");
      },
      detachEvents: function () {
        H(this, "off");
      },
    };
    const z = (t, e) => t.grid && e.grid && e.grid.rows > 1;
    var q = {
        addClasses: function () {
          const t = this,
            {
              classNames: e,
              params: n,
              rtl: r,
              $el: s,
              device: i,
              support: a,
            } = t,
            o = (function (t, e) {
              const n = [];
              return (
                t.forEach((t) => {
                  "object" == typeof t
                    ? Object.keys(t).forEach((r) => {
                        t[r] && n.push(e + r);
                      })
                    : "string" == typeof t && n.push(e + t);
                }),
                n
              );
            })(
              [
                "initialized",
                n.direction,
                { "pointer-events": !a.touch },
                { "free-mode": t.params.freeMode && n.freeMode.enabled },
                { autoheight: n.autoHeight },
                { rtl: r },
                { grid: n.grid && n.grid.rows > 1 },
                {
                  "grid-column":
                    n.grid && n.grid.rows > 1 && "column" === n.grid.fill,
                },
                { android: i.android },
                { ios: i.ios },
                { "css-mode": n.cssMode },
                { centered: n.cssMode && n.centeredSlides },
                { "watch-progress": n.watchSlidesProgress },
              ],
              n.containerModifierClass
            );
          e.push(...o), s.addClass([...e].join(" ")), t.emitContainerClasses();
        },
        removeClasses: function () {
          const { $el: t, classNames: e } = this;
          t.removeClass(e.join(" ")), this.emitContainerClasses();
        },
      },
      B = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements:
          "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: 0.85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1,
      };
    function F(t, e) {
      return function (n) {
        void 0 === n && (n = {});
        const r = Object.keys(n)[0],
          s = n[r];
        "object" == typeof s && null !== s
          ? (["navigation", "pagination", "scrollbar"].indexOf(r) >= 0 &&
              !0 === t[r] &&
              (t[r] = { auto: !0 }),
            r in t && "enabled" in s
              ? (!0 === t[r] && (t[r] = { enabled: !0 }),
                "object" != typeof t[r] ||
                  "enabled" in t[r] ||
                  (t[r].enabled = !0),
                t[r] || (t[r] = { enabled: !1 }),
                g(e, n))
              : g(e, n))
          : g(e, n);
      };
    }
    const W = {
        eventsEmitter: k,
        update: E,
        translate: T,
        transition: {
          setTransition: function (t, e) {
            const n = this;
            n.params.cssMode || n.$wrapperEl.transition(t),
              n.emit("setTransition", t, e);
          },
          transitionStart: function (t, e) {
            void 0 === t && (t = !0);
            const n = this,
              { params: r } = n;
            r.cssMode ||
              (r.autoHeight && n.updateAutoHeight(),
              P({ swiper: n, runCallbacks: t, direction: e, step: "Start" }));
          },
          transitionEnd: function (t, e) {
            void 0 === t && (t = !0);
            const n = this,
              { params: r } = n;
            (n.animating = !1),
              r.cssMode ||
                (n.setTransition(0),
                P({ swiper: n, runCallbacks: t, direction: e, step: "End" }));
          },
        },
        slide: M,
        loop: O,
        grabCursor: {
          setGrabCursor: function (t) {
            const e = this;
            if (
              e.support.touch ||
              !e.params.simulateTouch ||
              (e.params.watchOverflow && e.isLocked) ||
              e.params.cssMode
            )
              return;
            const n =
              "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
            (n.style.cursor = "move"),
              (n.style.cursor = t ? "grabbing" : "grab");
          },
          unsetGrabCursor: function () {
            const t = this;
            t.support.touch ||
              (t.params.watchOverflow && t.isLocked) ||
              t.params.cssMode ||
              (t[
                "container" === t.params.touchEventsTarget ? "el" : "wrapperEl"
              ].style.cursor = "");
          },
        },
        events: R,
        breakpoints: {
          setBreakpoint: function () {
            const t = this,
              {
                activeIndex: e,
                initialized: n,
                loopedSlides: r = 0,
                params: s,
                $el: i,
              } = t,
              a = s.breakpoints;
            if (!a || (a && 0 === Object.keys(a).length)) return;
            const o = t.getBreakpoint(a, t.params.breakpointsBase, t.el);
            if (!o || t.currentBreakpoint === o) return;
            const l = (o in a ? a[o] : void 0) || t.originalParams,
              c = z(t, s),
              u = z(t, l),
              p = s.enabled;
            c && !u
              ? (i.removeClass(
                  `${s.containerModifierClass}grid ${s.containerModifierClass}grid-column`
                ),
                t.emitContainerClasses())
              : !c &&
                u &&
                (i.addClass(`${s.containerModifierClass}grid`),
                ((l.grid.fill && "column" === l.grid.fill) ||
                  (!l.grid.fill && "column" === s.grid.fill)) &&
                  i.addClass(`${s.containerModifierClass}grid-column`),
                t.emitContainerClasses()),
              ["navigation", "pagination", "scrollbar"].forEach((e) => {
                const n = s[e] && s[e].enabled,
                  r = l[e] && l[e].enabled;
                n && !r && t[e].disable(), !n && r && t[e].enable();
              });
            const d = l.direction && l.direction !== s.direction,
              f = s.loop && (l.slidesPerView !== s.slidesPerView || d);
            d && n && t.changeDirection(), g(t.params, l);
            const h = t.params.enabled;
            Object.assign(t, {
              allowTouchMove: t.params.allowTouchMove,
              allowSlideNext: t.params.allowSlideNext,
              allowSlidePrev: t.params.allowSlidePrev,
            }),
              p && !h ? t.disable() : !p && h && t.enable(),
              (t.currentBreakpoint = o),
              t.emit("_beforeBreakpoint", l),
              f &&
                n &&
                (t.loopDestroy(),
                t.loopCreate(),
                t.updateSlides(),
                t.slideTo(e - r + t.loopedSlides, 0, !1)),
              t.emit("breakpoint", l);
          },
          getBreakpoint: function (t, e, n) {
            if (
              (void 0 === e && (e = "window"), !t || ("container" === e && !n))
            )
              return;
            let r = !1;
            const s = i(),
              a = "window" === e ? s.innerHeight : n.clientHeight,
              o = Object.keys(t).map((t) => {
                if ("string" == typeof t && 0 === t.indexOf("@")) {
                  const e = parseFloat(t.substr(1));
                  return { value: a * e, point: t };
                }
                return { value: t, point: t };
              });
            o.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10));
            for (let t = 0; t < o.length; t += 1) {
              const { point: i, value: a } = o[t];
              "window" === e
                ? s.matchMedia(`(min-width: ${a}px)`).matches && (r = i)
                : a <= n.clientWidth && (r = i);
            }
            return r || "max";
          },
        },
        checkOverflow: {
          checkOverflow: function () {
            const t = this,
              { isLocked: e, params: n } = t,
              { slidesOffsetBefore: r } = n;
            if (r) {
              const e = t.slides.length - 1,
                n = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * r;
              t.isLocked = t.size > n;
            } else t.isLocked = 1 === t.snapGrid.length;
            !0 === n.allowSlideNext && (t.allowSlideNext = !t.isLocked),
              !0 === n.allowSlidePrev && (t.allowSlidePrev = !t.isLocked),
              e && e !== t.isLocked && (t.isEnd = !1),
              e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock");
          },
        },
        classes: q,
        images: {
          loadImage: function (t, e, n, r, s, a) {
            const o = i();
            let l;
            function u() {
              a && a();
            }
            c(t).parent("picture")[0] || (t.complete && s)
              ? u()
              : e
              ? ((l = new o.Image()),
                (l.onload = u),
                (l.onerror = u),
                r && (l.sizes = r),
                n && (l.srcset = n),
                e && (l.src = e))
              : u();
          },
          preloadImages: function () {
            const t = this;
            function e() {
              null != t &&
                t &&
                !t.destroyed &&
                (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1),
                t.imagesLoaded === t.imagesToLoad.length &&
                  (t.params.updateOnImagesReady && t.update(),
                  t.emit("imagesReady")));
            }
            t.imagesToLoad = t.$el.find("img");
            for (let n = 0; n < t.imagesToLoad.length; n += 1) {
              const r = t.imagesToLoad[n];
              t.loadImage(
                r,
                r.currentSrc || r.getAttribute("src"),
                r.srcset || r.getAttribute("srcset"),
                r.sizes || r.getAttribute("sizes"),
                !0,
                e
              );
            }
          },
        },
      },
      U = {};
    class G {
      constructor() {
        let t, e;
        for (var n = arguments.length, r = new Array(n), s = 0; s < n; s++)
          r[s] = arguments[s];
        if (
          (1 === r.length &&
          r[0].constructor &&
          "Object" === Object.prototype.toString.call(r[0]).slice(8, -1)
            ? (e = r[0])
            : ([t, e] = r),
          e || (e = {}),
          (e = g({}, e)),
          t && !e.el && (e.el = t),
          e.el && c(e.el).length > 1)
        ) {
          const t = [];
          return (
            c(e.el).each((n) => {
              const r = g({}, e, { el: n });
              t.push(new G(r));
            }),
            t
          );
        }
        const i = this;
        (i.__swiper__ = !0),
          (i.support = S()),
          (i.device = C({ userAgent: e.userAgent })),
          (i.browser = x()),
          (i.eventsListeners = {}),
          (i.eventsAnyListeners = []),
          (i.modules = [...i.__modules__]),
          e.modules && Array.isArray(e.modules) && i.modules.push(...e.modules);
        const a = {};
        i.modules.forEach((t) => {
          t({
            swiper: i,
            extendParams: F(e, a),
            on: i.on.bind(i),
            once: i.once.bind(i),
            off: i.off.bind(i),
            emit: i.emit.bind(i),
          });
        });
        const o = g({}, B, a);
        return (
          (i.params = g({}, o, U, e)),
          (i.originalParams = g({}, i.params)),
          (i.passedParams = g({}, e)),
          i.params &&
            i.params.on &&
            Object.keys(i.params.on).forEach((t) => {
              i.on(t, i.params.on[t]);
            }),
          i.params && i.params.onAny && i.onAny(i.params.onAny),
          (i.$ = c),
          Object.assign(i, {
            enabled: i.params.enabled,
            el: t,
            classNames: [],
            slides: c(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: () => "horizontal" === i.params.direction,
            isVertical: () => "vertical" === i.params.direction,
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: i.params.allowSlideNext,
            allowSlidePrev: i.params.allowSlidePrev,
            touchEvents: (function () {
              const t = ["touchstart", "touchmove", "touchend", "touchcancel"],
                e = ["pointerdown", "pointermove", "pointerup"];
              return (
                (i.touchEventsTouch = {
                  start: t[0],
                  move: t[1],
                  end: t[2],
                  cancel: t[3],
                }),
                (i.touchEventsDesktop = { start: e[0], move: e[1], end: e[2] }),
                i.support.touch || !i.params.simulateTouch
                  ? i.touchEventsTouch
                  : i.touchEventsDesktop
              );
            })(),
            touchEventsData: {
              isTouched: void 0,
              isMoved: void 0,
              allowTouchCallbacks: void 0,
              touchStartTime: void 0,
              isScrolling: void 0,
              currentTranslate: void 0,
              startTranslate: void 0,
              allowThresholdMove: void 0,
              focusableElements: i.params.focusableElements,
              lastClickTime: d(),
              clickTimeout: void 0,
              velocities: [],
              allowMomentumBounce: void 0,
              isTouchEvent: void 0,
              startMoving: void 0,
            },
            allowClick: !0,
            allowTouchMove: i.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0,
            },
            imagesToLoad: [],
            imagesLoaded: 0,
          }),
          i.emit("_swiper"),
          i.params.init && i.init(),
          i
        );
      }
      enable() {
        const t = this;
        t.enabled ||
          ((t.enabled = !0),
          t.params.grabCursor && t.setGrabCursor(),
          t.emit("enable"));
      }
      disable() {
        const t = this;
        t.enabled &&
          ((t.enabled = !1),
          t.params.grabCursor && t.unsetGrabCursor(),
          t.emit("disable"));
      }
      setProgress(t, e) {
        const n = this;
        t = Math.min(Math.max(t, 0), 1);
        const r = n.minTranslate(),
          s = (n.maxTranslate() - r) * t + r;
        n.translateTo(s, void 0 === e ? 0 : e),
          n.updateActiveIndex(),
          n.updateSlidesClasses();
      }
      emitContainerClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el) return;
        const e = t.el.className
          .split(" ")
          .filter(
            (e) =>
              0 === e.indexOf("swiper") ||
              0 === e.indexOf(t.params.containerModifierClass)
          );
        t.emit("_containerClasses", e.join(" "));
      }
      getSlideClasses(t) {
        const e = this;
        return e.destroyed
          ? ""
          : t.className
              .split(" ")
              .filter(
                (t) =>
                  0 === t.indexOf("swiper-slide") ||
                  0 === t.indexOf(e.params.slideClass)
              )
              .join(" ");
      }
      emitSlidesClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el) return;
        const e = [];
        t.slides.each((n) => {
          const r = t.getSlideClasses(n);
          e.push({ slideEl: n, classNames: r }), t.emit("_slideClass", n, r);
        }),
          t.emit("_slideClasses", e);
      }
      slidesPerViewDynamic(t, e) {
        void 0 === t && (t = "current"), void 0 === e && (e = !1);
        const {
          params: n,
          slides: r,
          slidesGrid: s,
          slidesSizesGrid: i,
          size: a,
          activeIndex: o,
        } = this;
        let l = 1;
        if (n.centeredSlides) {
          let t,
            e = r[o].swiperSlideSize;
          for (let n = o + 1; n < r.length; n += 1)
            r[n] &&
              !t &&
              ((e += r[n].swiperSlideSize), (l += 1), e > a && (t = !0));
          for (let n = o - 1; n >= 0; n -= 1)
            r[n] &&
              !t &&
              ((e += r[n].swiperSlideSize), (l += 1), e > a && (t = !0));
        } else if ("current" === t)
          for (let t = o + 1; t < r.length; t += 1)
            (e ? s[t] + i[t] - s[o] < a : s[t] - s[o] < a) && (l += 1);
        else for (let t = o - 1; t >= 0; t -= 1) s[o] - s[t] < a && (l += 1);
        return l;
      }
      update() {
        const t = this;
        if (!t || t.destroyed) return;
        const { snapGrid: e, params: n } = t;
        function r() {
          const e = t.rtlTranslate ? -1 * t.translate : t.translate,
            n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
          t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();
        }
        let s;
        n.breakpoints && t.setBreakpoint(),
          t.updateSize(),
          t.updateSlides(),
          t.updateProgress(),
          t.updateSlidesClasses(),
          t.params.freeMode && t.params.freeMode.enabled
            ? (r(), t.params.autoHeight && t.updateAutoHeight())
            : ((s =
                ("auto" === t.params.slidesPerView ||
                  t.params.slidesPerView > 1) &&
                t.isEnd &&
                !t.params.centeredSlides
                  ? t.slideTo(t.slides.length - 1, 0, !1, !0)
                  : t.slideTo(t.activeIndex, 0, !1, !0)),
              s || r()),
          n.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
          t.emit("update");
      }
      changeDirection(t, e) {
        void 0 === e && (e = !0);
        const n = this,
          r = n.params.direction;
        return (
          t || (t = "horizontal" === r ? "vertical" : "horizontal"),
          t === r ||
            ("horizontal" !== t && "vertical" !== t) ||
            (n.$el
              .removeClass(`${n.params.containerModifierClass}${r}`)
              .addClass(`${n.params.containerModifierClass}${t}`),
            n.emitContainerClasses(),
            (n.params.direction = t),
            n.slides.each((e) => {
              "vertical" === t ? (e.style.width = "") : (e.style.height = "");
            }),
            n.emit("changeDirection"),
            e && n.update()),
          n
        );
      }
      changeLanguageDirection(t) {
        const e = this;
        (e.rtl && "rtl" === t) ||
          (!e.rtl && "ltr" === t) ||
          ((e.rtl = "rtl" === t),
          (e.rtlTranslate = "horizontal" === e.params.direction && e.rtl),
          e.rtl
            ? (e.$el.addClass(`${e.params.containerModifierClass}rtl`),
              (e.el.dir = "rtl"))
            : (e.$el.removeClass(`${e.params.containerModifierClass}rtl`),
              (e.el.dir = "ltr")),
          e.update());
      }
      mount(t) {
        const e = this;
        if (e.mounted) return !0;
        const n = c(t || e.params.el);
        if (!(t = n[0])) return !1;
        t.swiper = e;
        const s = () =>
          `.${(e.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let i = (() => {
          if (t && t.shadowRoot && t.shadowRoot.querySelector) {
            const e = c(t.shadowRoot.querySelector(s()));
            return (e.children = (t) => n.children(t)), e;
          }
          return n.children ? n.children(s()) : c(n).children(s());
        })();
        if (0 === i.length && e.params.createElements) {
          const t = r().createElement("div");
          (i = c(t)),
            (t.className = e.params.wrapperClass),
            n.append(t),
            n.children(`.${e.params.slideClass}`).each((t) => {
              i.append(t);
            });
        }
        return (
          Object.assign(e, {
            $el: n,
            el: t,
            $wrapperEl: i,
            wrapperEl: i[0],
            mounted: !0,
            rtl: "rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction"),
            rtlTranslate:
              "horizontal" === e.params.direction &&
              ("rtl" === t.dir.toLowerCase() || "rtl" === n.css("direction")),
            wrongRTL: "-webkit-box" === i.css("display"),
          }),
          !0
        );
      }
      init(t) {
        const e = this;
        return (
          e.initialized ||
            !1 === e.mount(t) ||
            (e.emit("beforeInit"),
            e.params.breakpoints && e.setBreakpoint(),
            e.addClasses(),
            e.params.loop && e.loopCreate(),
            e.updateSize(),
            e.updateSlides(),
            e.params.watchOverflow && e.checkOverflow(),
            e.params.grabCursor && e.enabled && e.setGrabCursor(),
            e.params.preloadImages && e.preloadImages(),
            e.params.loop
              ? e.slideTo(
                  e.params.initialSlide + e.loopedSlides,
                  0,
                  e.params.runCallbacksOnInit,
                  !1,
                  !0
                )
              : e.slideTo(
                  e.params.initialSlide,
                  0,
                  e.params.runCallbacksOnInit,
                  !1,
                  !0
                ),
            e.attachEvents(),
            (e.initialized = !0),
            e.emit("init"),
            e.emit("afterInit")),
          e
        );
      }
      destroy(t, e) {
        void 0 === t && (t = !0), void 0 === e && (e = !0);
        const n = this,
          { params: r, $el: s, $wrapperEl: i, slides: a } = n;
        return (
          void 0 === n.params ||
            n.destroyed ||
            (n.emit("beforeDestroy"),
            (n.initialized = !1),
            n.detachEvents(),
            r.loop && n.loopDestroy(),
            e &&
              (n.removeClasses(),
              s.removeAttr("style"),
              i.removeAttr("style"),
              a &&
                a.length &&
                a
                  .removeClass(
                    [
                      r.slideVisibleClass,
                      r.slideActiveClass,
                      r.slideNextClass,
                      r.slidePrevClass,
                    ].join(" ")
                  )
                  .removeAttr("style")
                  .removeAttr("data-swiper-slide-index")),
            n.emit("destroy"),
            Object.keys(n.eventsListeners).forEach((t) => {
              n.off(t);
            }),
            !1 !== t &&
              ((n.$el[0].swiper = null),
              (function (t) {
                const e = t;
                Object.keys(e).forEach((t) => {
                  try {
                    e[t] = null;
                  } catch (t) {
                    console.log(t);
                  }
                  try {
                    delete e[t];
                  } catch (t) {
                    console.log(t);
                  }
                });
              })(n)),
            (n.destroyed = !0)),
          null
        );
      }
      static extendDefaults(t) {
        g(U, t);
      }
      static get extendedDefaults() {
        return U;
      }
      static get defaults() {
        return B;
      }
      static installModule(t) {
        G.prototype.__modules__ || (G.prototype.__modules__ = []);
        const e = G.prototype.__modules__;
        "function" == typeof t && e.indexOf(t) < 0 && e.push(t);
      }
      static use(t) {
        return Array.isArray(t)
          ? (t.forEach((t) => G.installModule(t)), G)
          : (G.installModule(t), G);
      }
    }
    function Y(t, e, n, s) {
      const i = r();
      return (
        t.params.createElements &&
          Object.keys(s).forEach((r) => {
            if (!n[r] && !0 === n.auto) {
              let a = t.$el.children(`.${s[r]}`)[0];
              a ||
                ((a = i.createElement("div")),
                (a.className = s[r]),
                t.$el.append(a)),
                (n[r] = a),
                (e[r] = a);
            }
          }),
        n
      );
    }
    function X(t) {
      return (
        void 0 === t && (t = ""),
        `.${t
          .trim()
          .replace(/([.:!/])/g, "\\$1")
          .replace(/ /g, ".")}`
      );
    }
    function K(t) {
      const e = this,
        { $wrapperEl: n, params: r } = e;
      if ((r.loop && e.loopDestroy(), "object" == typeof t && "length" in t))
        for (let e = 0; e < t.length; e += 1) t[e] && n.append(t[e]);
      else n.append(t);
      r.loop && e.loopCreate(), r.observer || e.update();
    }
    function Q(t) {
      const e = this,
        { params: n, $wrapperEl: r, activeIndex: s } = e;
      n.loop && e.loopDestroy();
      let i = s + 1;
      if ("object" == typeof t && "length" in t) {
        for (let e = 0; e < t.length; e += 1) t[e] && r.prepend(t[e]);
        i = s + t.length;
      } else r.prepend(t);
      n.loop && e.loopCreate(), n.observer || e.update(), e.slideTo(i, 0, !1);
    }
    function J(t, e) {
      const n = this,
        { $wrapperEl: r, params: s, activeIndex: i } = n;
      let a = i;
      s.loop &&
        ((a -= n.loopedSlides),
        n.loopDestroy(),
        (n.slides = r.children(`.${s.slideClass}`)));
      const o = n.slides.length;
      if (t <= 0) return void n.prependSlide(e);
      if (t >= o) return void n.appendSlide(e);
      let l = a > t ? a + 1 : a;
      const c = [];
      for (let e = o - 1; e >= t; e -= 1) {
        const t = n.slides.eq(e);
        t.remove(), c.unshift(t);
      }
      if ("object" == typeof e && "length" in e) {
        for (let t = 0; t < e.length; t += 1) e[t] && r.append(e[t]);
        l = a > t ? a + e.length : a;
      } else r.append(e);
      for (let t = 0; t < c.length; t += 1) r.append(c[t]);
      s.loop && n.loopCreate(),
        s.observer || n.update(),
        s.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1);
    }
    function Z(t) {
      const e = this,
        { params: n, $wrapperEl: r, activeIndex: s } = e;
      let i = s;
      n.loop &&
        ((i -= e.loopedSlides),
        e.loopDestroy(),
        (e.slides = r.children(`.${n.slideClass}`)));
      let a,
        o = i;
      if ("object" == typeof t && "length" in t) {
        for (let n = 0; n < t.length; n += 1)
          (a = t[n]), e.slides[a] && e.slides.eq(a).remove(), a < o && (o -= 1);
        o = Math.max(o, 0);
      } else (a = t), e.slides[a] && e.slides.eq(a).remove(), a < o && (o -= 1), (o = Math.max(o, 0));
      n.loop && e.loopCreate(),
        n.observer || e.update(),
        n.loop ? e.slideTo(o + e.loopedSlides, 0, !1) : e.slideTo(o, 0, !1);
    }
    function tt() {
      const t = this,
        e = [];
      for (let n = 0; n < t.slides.length; n += 1) e.push(n);
      t.removeSlide(e);
    }
    function et(t) {
      const {
        effect: e,
        swiper: n,
        on: r,
        setTranslate: s,
        setTransition: i,
        overwriteParams: a,
        perspective: o,
        recreateShadows: l,
        getEffectParams: c,
      } = t;
      let u;
      r("beforeInit", () => {
        if (n.params.effect !== e) return;
        n.classNames.push(`${n.params.containerModifierClass}${e}`),
          o && o() && n.classNames.push(`${n.params.containerModifierClass}3d`);
        const t = a ? a() : {};
        Object.assign(n.params, t), Object.assign(n.originalParams, t);
      }),
        r("setTranslate", () => {
          n.params.effect === e && s();
        }),
        r("setTransition", (t, r) => {
          n.params.effect === e && i(r);
        }),
        r("transitionEnd", () => {
          if (n.params.effect === e && l) {
            if (!c || !c().slideShadows) return;
            n.slides.each((t) => {
              n.$(t)
                .find(
                  ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                )
                .remove();
            }),
              l();
          }
        }),
        r("virtualUpdate", () => {
          n.params.effect === e &&
            (n.slides.length || (u = !0),
            requestAnimationFrame(() => {
              u && n.slides && n.slides.length && (s(), (u = !1));
            }));
        });
    }
    function nt(t, e) {
      return t.transformEl
        ? e.find(t.transformEl).css({
            "backface-visibility": "hidden",
            "-webkit-backface-visibility": "hidden",
          })
        : e;
    }
    function rt(t) {
      let { swiper: e, duration: n, transformEl: r, allSlides: s } = t;
      const { slides: i, activeIndex: a, $wrapperEl: o } = e;
      if (e.params.virtualTranslate && 0 !== n) {
        let t,
          n = !1;
        (t = s ? (r ? i.find(r) : i) : r ? i.eq(a).find(r) : i.eq(a)),
          t.transitionEnd(() => {
            if (n) return;
            if (!e || e.destroyed) return;
            (n = !0), (e.animating = !1);
            const t = ["webkitTransitionEnd", "transitionend"];
            for (let e = 0; e < t.length; e += 1) o.trigger(t[e]);
          });
      }
    }
    function st(t, e, n) {
      const r = "swiper-slide-shadow" + (n ? `-${n}` : ""),
        s = t.transformEl ? e.find(t.transformEl) : e;
      let i = s.children(`.${r}`);
      return (
        i.length ||
          ((i = c(
            `<div class="swiper-slide-shadow${n ? `-${n}` : ""}"></div>`
          )),
          s.append(i)),
        i
      );
    }
    Object.keys(W).forEach((t) => {
      Object.keys(W[t]).forEach((e) => {
        G.prototype[e] = W[t][e];
      });
    }),
      G.use([
        function (t) {
          let { swiper: e, on: n, emit: r } = t;
          const s = i();
          let a = null,
            o = null;
          const l = () => {
              e &&
                !e.destroyed &&
                e.initialized &&
                (r("beforeResize"), r("resize"));
            },
            c = () => {
              e && !e.destroyed && e.initialized && r("orientationchange");
            };
          n("init", () => {
            e.params.resizeObserver && void 0 !== s.ResizeObserver
              ? e &&
                !e.destroyed &&
                e.initialized &&
                ((a = new ResizeObserver((t) => {
                  o = s.requestAnimationFrame(() => {
                    const { width: n, height: r } = e;
                    let s = n,
                      i = r;
                    t.forEach((t) => {
                      let { contentBoxSize: n, contentRect: r, target: a } = t;
                      (a && a !== e.el) ||
                        ((s = r ? r.width : (n[0] || n).inlineSize),
                        (i = r ? r.height : (n[0] || n).blockSize));
                    }),
                      (s === n && i === r) || l();
                  });
                })),
                a.observe(e.el))
              : (s.addEventListener("resize", l),
                s.addEventListener("orientationchange", c));
          }),
            n("destroy", () => {
              o && s.cancelAnimationFrame(o),
                a && a.unobserve && e.el && (a.unobserve(e.el), (a = null)),
                s.removeEventListener("resize", l),
                s.removeEventListener("orientationchange", c);
            });
        },
        function (t) {
          let { swiper: e, extendParams: n, on: r, emit: s } = t;
          const a = [],
            o = i(),
            l = function (t, e) {
              void 0 === e && (e = {});
              const n = new (o.MutationObserver || o.WebkitMutationObserver)(
                (t) => {
                  if (1 === t.length) return void s("observerUpdate", t[0]);
                  const e = function () {
                    s("observerUpdate", t[0]);
                  };
                  o.requestAnimationFrame
                    ? o.requestAnimationFrame(e)
                    : o.setTimeout(e, 0);
                }
              );
              n.observe(t, {
                attributes: void 0 === e.attributes || e.attributes,
                childList: void 0 === e.childList || e.childList,
                characterData: void 0 === e.characterData || e.characterData,
              }),
                a.push(n);
            };
          n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }),
            r("init", () => {
              if (e.params.observer) {
                if (e.params.observeParents) {
                  const t = e.$el.parents();
                  for (let e = 0; e < t.length; e += 1) l(t[e]);
                }
                l(e.$el[0], { childList: e.params.observeSlideChildren }),
                  l(e.$wrapperEl[0], { attributes: !1 });
              }
            }),
            r("destroy", () => {
              a.forEach((t) => {
                t.disconnect();
              }),
                a.splice(0, a.length);
            });
        },
      ]);
    const it = [
      function (t) {
        let e,
          { swiper: n, extendParams: r, on: s, emit: i } = t;
        function a(t, e) {
          const r = n.params.virtual;
          if (r.cache && n.virtual.cache[e]) return n.virtual.cache[e];
          const s = r.renderSlide
            ? c(r.renderSlide.call(n, t, e))
            : c(
                `<div class="${n.params.slideClass}" data-swiper-slide-index="${e}">${t}</div>`
              );
          return (
            s.attr("data-swiper-slide-index") ||
              s.attr("data-swiper-slide-index", e),
            r.cache && (n.virtual.cache[e] = s),
            s
          );
        }
        function o(t) {
          const {
              slidesPerView: e,
              slidesPerGroup: r,
              centeredSlides: s,
            } = n.params,
            { addSlidesBefore: o, addSlidesAfter: l } = n.params.virtual,
            { from: c, to: u, slides: p, slidesGrid: d, offset: f } = n.virtual;
          n.params.cssMode || n.updateActiveIndex();
          const h = n.activeIndex || 0;
          let m, g, v;
          (m = n.rtlTranslate ? "right" : n.isHorizontal() ? "left" : "top"),
            s
              ? ((g = Math.floor(e / 2) + r + l),
                (v = Math.floor(e / 2) + r + o))
              : ((g = e + (r - 1) + l), (v = r + o));
          const y = Math.max((h || 0) - v, 0),
            b = Math.min((h || 0) + g, p.length - 1),
            _ = (n.slidesGrid[y] || 0) - (n.slidesGrid[0] || 0);
          function w() {
            n.updateSlides(),
              n.updateProgress(),
              n.updateSlidesClasses(),
              n.lazy && n.params.lazy.enabled && n.lazy.load(),
              i("virtualUpdate");
          }
          if (
            (Object.assign(n.virtual, {
              from: y,
              to: b,
              offset: _,
              slidesGrid: n.slidesGrid,
            }),
            c === y && u === b && !t)
          )
            return (
              n.slidesGrid !== d && _ !== f && n.slides.css(m, `${_}px`),
              n.updateProgress(),
              void i("virtualUpdate")
            );
          if (n.params.virtual.renderExternal)
            return (
              n.params.virtual.renderExternal.call(n, {
                offset: _,
                from: y,
                to: b,
                slides: (function () {
                  const t = [];
                  for (let e = y; e <= b; e += 1) t.push(p[e]);
                  return t;
                })(),
              }),
              void (n.params.virtual.renderExternalUpdate
                ? w()
                : i("virtualUpdate"))
            );
          const S = [],
            C = [];
          if (t) n.$wrapperEl.find(`.${n.params.slideClass}`).remove();
          else
            for (let t = c; t <= u; t += 1)
              (t < y || t > b) &&
                n.$wrapperEl
                  .find(
                    `.${n.params.slideClass}[data-swiper-slide-index="${t}"]`
                  )
                  .remove();
          for (let e = 0; e < p.length; e += 1)
            e >= y &&
              e <= b &&
              (void 0 === u || t
                ? C.push(e)
                : (e > u && C.push(e), e < c && S.push(e)));
          C.forEach((t) => {
            n.$wrapperEl.append(a(p[t], t));
          }),
            S.sort((t, e) => e - t).forEach((t) => {
              n.$wrapperEl.prepend(a(p[t], t));
            }),
            n.$wrapperEl.children(".swiper-slide").css(m, `${_}px`),
            w();
        }
        r({
          virtual: {
            enabled: !1,
            slides: [],
            cache: !0,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: !0,
            addSlidesBefore: 0,
            addSlidesAfter: 0,
          },
        }),
          (n.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: [],
          }),
          s("beforeInit", () => {
            n.params.virtual.enabled &&
              ((n.virtual.slides = n.params.virtual.slides),
              n.classNames.push(`${n.params.containerModifierClass}virtual`),
              (n.params.watchSlidesProgress = !0),
              (n.originalParams.watchSlidesProgress = !0),
              n.params.initialSlide || o());
          }),
          s("setTranslate", () => {
            n.params.virtual.enabled &&
              (n.params.cssMode && !n._immediateVirtual
                ? (clearTimeout(e),
                  (e = setTimeout(() => {
                    o();
                  }, 100)))
                : o());
          }),
          s("init update resize", () => {
            n.params.virtual.enabled &&
              n.params.cssMode &&
              v(n.wrapperEl, "--swiper-virtual-size", `${n.virtualSize}px`);
          }),
          Object.assign(n.virtual, {
            appendSlide: function (t) {
              if ("object" == typeof t && "length" in t)
                for (let e = 0; e < t.length; e += 1)
                  t[e] && n.virtual.slides.push(t[e]);
              else n.virtual.slides.push(t);
              o(!0);
            },
            prependSlide: function (t) {
              const e = n.activeIndex;
              let r = e + 1,
                s = 1;
              if (Array.isArray(t)) {
                for (let e = 0; e < t.length; e += 1)
                  t[e] && n.virtual.slides.unshift(t[e]);
                (r = e + t.length), (s = t.length);
              } else n.virtual.slides.unshift(t);
              if (n.params.virtual.cache) {
                const t = n.virtual.cache,
                  e = {};
                Object.keys(t).forEach((n) => {
                  const r = t[n],
                    i = r.attr("data-swiper-slide-index");
                  i && r.attr("data-swiper-slide-index", parseInt(i, 10) + s),
                    (e[parseInt(n, 10) + s] = r);
                }),
                  (n.virtual.cache = e);
              }
              o(!0), n.slideTo(r, 0);
            },
            removeSlide: function (t) {
              if (null == t) return;
              let e = n.activeIndex;
              if (Array.isArray(t))
                for (let r = t.length - 1; r >= 0; r -= 1)
                  n.virtual.slides.splice(t[r], 1),
                    n.params.virtual.cache && delete n.virtual.cache[t[r]],
                    t[r] < e && (e -= 1),
                    (e = Math.max(e, 0));
              else
                n.virtual.slides.splice(t, 1),
                  n.params.virtual.cache && delete n.virtual.cache[t],
                  t < e && (e -= 1),
                  (e = Math.max(e, 0));
              o(!0), n.slideTo(e, 0);
            },
            removeAllSlides: function () {
              (n.virtual.slides = []),
                n.params.virtual.cache && (n.virtual.cache = {}),
                o(!0),
                n.slideTo(0, 0);
            },
            update: o,
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: s, emit: a } = t;
        const o = r(),
          l = i();
        function u(t) {
          if (!e.enabled) return;
          const { rtlTranslate: n } = e;
          let r = t;
          r.originalEvent && (r = r.originalEvent);
          const s = r.keyCode || r.charCode,
            i = e.params.keyboard.pageUpDown,
            c = i && 33 === s,
            u = i && 34 === s,
            p = 37 === s,
            d = 39 === s,
            f = 38 === s,
            h = 40 === s;
          if (
            !e.allowSlideNext &&
            ((e.isHorizontal() && d) || (e.isVertical() && h) || u)
          )
            return !1;
          if (
            !e.allowSlidePrev &&
            ((e.isHorizontal() && p) || (e.isVertical() && f) || c)
          )
            return !1;
          if (
            !(
              r.shiftKey ||
              r.altKey ||
              r.ctrlKey ||
              r.metaKey ||
              (o.activeElement &&
                o.activeElement.nodeName &&
                ("input" === o.activeElement.nodeName.toLowerCase() ||
                  "textarea" === o.activeElement.nodeName.toLowerCase()))
            )
          ) {
            if (
              e.params.keyboard.onlyInViewport &&
              (c || u || p || d || f || h)
            ) {
              let t = !1;
              if (
                e.$el.parents(`.${e.params.slideClass}`).length > 0 &&
                0 === e.$el.parents(`.${e.params.slideActiveClass}`).length
              )
                return;
              const r = e.$el,
                s = r[0].clientWidth,
                i = r[0].clientHeight,
                a = l.innerWidth,
                o = l.innerHeight,
                c = e.$el.offset();
              n && (c.left -= e.$el[0].scrollLeft);
              const u = [
                [c.left, c.top],
                [c.left + s, c.top],
                [c.left, c.top + i],
                [c.left + s, c.top + i],
              ];
              for (let e = 0; e < u.length; e += 1) {
                const n = u[e];
                if (n[0] >= 0 && n[0] <= a && n[1] >= 0 && n[1] <= o) {
                  if (0 === n[0] && 0 === n[1]) continue;
                  t = !0;
                }
              }
              if (!t) return;
            }
            e.isHorizontal()
              ? ((c || u || p || d) &&
                  (r.preventDefault
                    ? r.preventDefault()
                    : (r.returnValue = !1)),
                (((u || d) && !n) || ((c || p) && n)) && e.slideNext(),
                (((c || p) && !n) || ((u || d) && n)) && e.slidePrev())
              : ((c || u || f || h) &&
                  (r.preventDefault
                    ? r.preventDefault()
                    : (r.returnValue = !1)),
                (u || h) && e.slideNext(),
                (c || f) && e.slidePrev()),
              a("keyPress", s);
          }
        }
        function p() {
          e.keyboard.enabled ||
            (c(o).on("keydown", u), (e.keyboard.enabled = !0));
        }
        function d() {
          e.keyboard.enabled &&
            (c(o).off("keydown", u), (e.keyboard.enabled = !1));
        }
        (e.keyboard = { enabled: !1 }),
          n({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }),
          s("init", () => {
            e.params.keyboard.enabled && p();
          }),
          s("destroy", () => {
            e.keyboard.enabled && d();
          }),
          Object.assign(e.keyboard, { enable: p, disable: d });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r, emit: s } = t;
        const a = i();
        let o;
        n({
          mousewheel: {
            enabled: !1,
            releaseOnEdges: !1,
            invert: !1,
            forceToAxis: !1,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
          },
        }),
          (e.mousewheel = { enabled: !1 });
        let l,
          u = d();
        const f = [];
        function h() {
          e.enabled && (e.mouseEntered = !0);
        }
        function m() {
          e.enabled && (e.mouseEntered = !1);
        }
        function g(t) {
          return !(
            (e.params.mousewheel.thresholdDelta &&
              t.delta < e.params.mousewheel.thresholdDelta) ||
            (e.params.mousewheel.thresholdTime &&
              d() - u < e.params.mousewheel.thresholdTime) ||
            (!(t.delta >= 6 && d() - u < 60) &&
              (t.direction < 0
                ? (e.isEnd && !e.params.loop) ||
                  e.animating ||
                  (e.slideNext(), s("scroll", t.raw))
                : (e.isBeginning && !e.params.loop) ||
                  e.animating ||
                  (e.slidePrev(), s("scroll", t.raw)),
              (u = new a.Date().getTime()),
              1))
          );
        }
        function v(t) {
          let n = t,
            r = !0;
          if (!e.enabled) return;
          const i = e.params.mousewheel;
          e.params.cssMode && n.preventDefault();
          let a = e.$el;
          if (
            ("container" !== e.params.mousewheel.eventsTarget &&
              (a = c(e.params.mousewheel.eventsTarget)),
            !e.mouseEntered && !a[0].contains(n.target) && !i.releaseOnEdges)
          )
            return !0;
          n.originalEvent && (n = n.originalEvent);
          let u = 0;
          const h = e.rtlTranslate ? -1 : 1,
            m = (function (t) {
              let e = 0,
                n = 0,
                r = 0,
                s = 0;
              return (
                "detail" in t && (n = t.detail),
                "wheelDelta" in t && (n = -t.wheelDelta / 120),
                "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120),
                "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120),
                "axis" in t &&
                  t.axis === t.HORIZONTAL_AXIS &&
                  ((e = n), (n = 0)),
                (r = 10 * e),
                (s = 10 * n),
                "deltaY" in t && (s = t.deltaY),
                "deltaX" in t && (r = t.deltaX),
                t.shiftKey && !r && ((r = s), (s = 0)),
                (r || s) &&
                  t.deltaMode &&
                  (1 === t.deltaMode
                    ? ((r *= 40), (s *= 40))
                    : ((r *= 800), (s *= 800))),
                r && !e && (e = r < 1 ? -1 : 1),
                s && !n && (n = s < 1 ? -1 : 1),
                { spinX: e, spinY: n, pixelX: r, pixelY: s }
              );
            })(n);
          if (i.forceToAxis)
            if (e.isHorizontal()) {
              if (!(Math.abs(m.pixelX) > Math.abs(m.pixelY))) return !0;
              u = -m.pixelX * h;
            } else {
              if (!(Math.abs(m.pixelY) > Math.abs(m.pixelX))) return !0;
              u = -m.pixelY;
            }
          else
            u =
              Math.abs(m.pixelX) > Math.abs(m.pixelY)
                ? -m.pixelX * h
                : -m.pixelY;
          if (0 === u) return !0;
          i.invert && (u = -u);
          let v = e.getTranslate() + u * i.sensitivity;
          if (
            (v >= e.minTranslate() && (v = e.minTranslate()),
            v <= e.maxTranslate() && (v = e.maxTranslate()),
            (r =
              !!e.params.loop ||
              !(v === e.minTranslate() || v === e.maxTranslate())),
            r && e.params.nested && n.stopPropagation(),
            e.params.freeMode && e.params.freeMode.enabled)
          ) {
            const t = {
                time: d(),
                delta: Math.abs(u),
                direction: Math.sign(u),
              },
              r =
                l &&
                t.time < l.time + 500 &&
                t.delta <= l.delta &&
                t.direction === l.direction;
            if (!r) {
              (l = void 0), e.params.loop && e.loopFix();
              let a = e.getTranslate() + u * i.sensitivity;
              const c = e.isBeginning,
                d = e.isEnd;
              if (
                (a >= e.minTranslate() && (a = e.minTranslate()),
                a <= e.maxTranslate() && (a = e.maxTranslate()),
                e.setTransition(0),
                e.setTranslate(a),
                e.updateProgress(),
                e.updateActiveIndex(),
                e.updateSlidesClasses(),
                ((!c && e.isBeginning) || (!d && e.isEnd)) &&
                  e.updateSlidesClasses(),
                e.params.freeMode.sticky)
              ) {
                clearTimeout(o), (o = void 0), f.length >= 15 && f.shift();
                const n = f.length ? f[f.length - 1] : void 0,
                  r = f[0];
                if (
                  (f.push(t),
                  n && (t.delta > n.delta || t.direction !== n.direction))
                )
                  f.splice(0);
                else if (
                  f.length >= 15 &&
                  t.time - r.time < 500 &&
                  r.delta - t.delta >= 1 &&
                  t.delta <= 6
                ) {
                  const n = u > 0 ? 0.8 : 0.2;
                  (l = t),
                    f.splice(0),
                    (o = p(() => {
                      e.slideToClosest(e.params.speed, !0, void 0, n);
                    }, 0));
                }
                o ||
                  (o = p(() => {
                    (l = t),
                      f.splice(0),
                      e.slideToClosest(e.params.speed, !0, void 0, 0.5);
                  }, 500));
              }
              if (
                (r || s("scroll", n),
                e.params.autoplay &&
                  e.params.autoplayDisableOnInteraction &&
                  e.autoplay.stop(),
                a === e.minTranslate() || a === e.maxTranslate())
              )
                return !0;
            }
          } else {
            const n = {
              time: d(),
              delta: Math.abs(u),
              direction: Math.sign(u),
              raw: t,
            };
            f.length >= 2 && f.shift();
            const r = f.length ? f[f.length - 1] : void 0;
            if (
              (f.push(n),
              r
                ? (n.direction !== r.direction ||
                    n.delta > r.delta ||
                    n.time > r.time + 150) &&
                  g(n)
                : g(n),
              (function (t) {
                const n = e.params.mousewheel;
                if (t.direction < 0) {
                  if (e.isEnd && !e.params.loop && n.releaseOnEdges) return !0;
                } else if (e.isBeginning && !e.params.loop && n.releaseOnEdges)
                  return !0;
                return !1;
              })(n))
            )
              return !0;
          }
          return (
            n.preventDefault ? n.preventDefault() : (n.returnValue = !1), !1
          );
        }
        function y(t) {
          let n = e.$el;
          "container" !== e.params.mousewheel.eventsTarget &&
            (n = c(e.params.mousewheel.eventsTarget)),
            n[t]("mouseenter", h),
            n[t]("mouseleave", m),
            n[t]("wheel", v);
        }
        function b() {
          return e.params.cssMode
            ? (e.wrapperEl.removeEventListener("wheel", v), !0)
            : !e.mousewheel.enabled &&
                (y("on"), (e.mousewheel.enabled = !0), !0);
        }
        function _() {
          return e.params.cssMode
            ? (e.wrapperEl.addEventListener(event, v), !0)
            : !!e.mousewheel.enabled &&
                (y("off"), (e.mousewheel.enabled = !1), !0);
        }
        r("init", () => {
          !e.params.mousewheel.enabled && e.params.cssMode && _(),
            e.params.mousewheel.enabled && b();
        }),
          r("destroy", () => {
            e.params.cssMode && b(), e.mousewheel.enabled && _();
          }),
          Object.assign(e.mousewheel, { enable: b, disable: _ });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r, emit: s } = t;
        function i(t) {
          let n;
          return (
            t &&
              ((n = c(t)),
              e.params.uniqueNavElements &&
                "string" == typeof t &&
                n.length > 1 &&
                1 === e.$el.find(t).length &&
                (n = e.$el.find(t))),
            n
          );
        }
        function a(t, n) {
          const r = e.params.navigation;
          t &&
            t.length > 0 &&
            (t[n ? "addClass" : "removeClass"](r.disabledClass),
            t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = n),
            e.params.watchOverflow &&
              e.enabled &&
              t[e.isLocked ? "addClass" : "removeClass"](r.lockClass));
        }
        function o() {
          if (e.params.loop) return;
          const { $nextEl: t, $prevEl: n } = e.navigation;
          a(n, e.isBeginning && !e.params.rewind),
            a(t, e.isEnd && !e.params.rewind);
        }
        function l(t) {
          t.preventDefault(),
            (!e.isBeginning || e.params.loop || e.params.rewind) &&
              (e.slidePrev(), s("navigationPrev"));
        }
        function u(t) {
          t.preventDefault(),
            (!e.isEnd || e.params.loop || e.params.rewind) &&
              (e.slideNext(), s("navigationNext"));
        }
        function p() {
          const t = e.params.navigation;
          if (
            ((e.params.navigation = Y(
              e,
              e.originalParams.navigation,
              e.params.navigation,
              { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }
            )),
            !t.nextEl && !t.prevEl)
          )
            return;
          const n = i(t.nextEl),
            r = i(t.prevEl);
          n && n.length > 0 && n.on("click", u),
            r && r.length > 0 && r.on("click", l),
            Object.assign(e.navigation, {
              $nextEl: n,
              nextEl: n && n[0],
              $prevEl: r,
              prevEl: r && r[0],
            }),
            e.enabled ||
              (n && n.addClass(t.lockClass), r && r.addClass(t.lockClass));
        }
        function d() {
          const { $nextEl: t, $prevEl: n } = e.navigation;
          t &&
            t.length &&
            (t.off("click", u),
            t.removeClass(e.params.navigation.disabledClass)),
            n &&
              n.length &&
              (n.off("click", l),
              n.removeClass(e.params.navigation.disabledClass));
        }
        n({
          navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled",
          },
        }),
          (e.navigation = {
            nextEl: null,
            $nextEl: null,
            prevEl: null,
            $prevEl: null,
          }),
          r("init", () => {
            !1 === e.params.navigation.enabled ? f() : (p(), o());
          }),
          r("toEdge fromEdge lock unlock", () => {
            o();
          }),
          r("destroy", () => {
            d();
          }),
          r("enable disable", () => {
            const { $nextEl: t, $prevEl: n } = e.navigation;
            t &&
              t[e.enabled ? "removeClass" : "addClass"](
                e.params.navigation.lockClass
              ),
              n &&
                n[e.enabled ? "removeClass" : "addClass"](
                  e.params.navigation.lockClass
                );
          }),
          r("click", (t, n) => {
            const { $nextEl: r, $prevEl: i } = e.navigation,
              a = n.target;
            if (e.params.navigation.hideOnClick && !c(a).is(i) && !c(a).is(r)) {
              if (
                e.pagination &&
                e.params.pagination &&
                e.params.pagination.clickable &&
                (e.pagination.el === a || e.pagination.el.contains(a))
              )
                return;
              let t;
              r
                ? (t = r.hasClass(e.params.navigation.hiddenClass))
                : i && (t = i.hasClass(e.params.navigation.hiddenClass)),
                s(!0 === t ? "navigationShow" : "navigationHide"),
                r && r.toggleClass(e.params.navigation.hiddenClass),
                i && i.toggleClass(e.params.navigation.hiddenClass);
            }
          });
        const f = () => {
          e.$el.addClass(e.params.navigation.navigationDisabledClass), d();
        };
        Object.assign(e.navigation, {
          enable: () => {
            e.$el.removeClass(e.params.navigation.navigationDisabledClass),
              p(),
              o();
          },
          disable: f,
          update: o,
          init: p,
          destroy: d,
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r, emit: s } = t;
        const i = "swiper-pagination";
        let a;
        n({
          pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: (t) => t,
            formatFractionTotal: (t) => t,
            bulletClass: `${i}-bullet`,
            bulletActiveClass: `${i}-bullet-active`,
            modifierClass: `${i}-`,
            currentClass: `${i}-current`,
            totalClass: `${i}-total`,
            hiddenClass: `${i}-hidden`,
            progressbarFillClass: `${i}-progressbar-fill`,
            progressbarOppositeClass: `${i}-progressbar-opposite`,
            clickableClass: `${i}-clickable`,
            lockClass: `${i}-lock`,
            horizontalClass: `${i}-horizontal`,
            verticalClass: `${i}-vertical`,
            paginationDisabledClass: `${i}-disabled`,
          },
        }),
          (e.pagination = { el: null, $el: null, bullets: [] });
        let o = 0;
        function l() {
          return (
            !e.params.pagination.el ||
            !e.pagination.el ||
            !e.pagination.$el ||
            0 === e.pagination.$el.length
          );
        }
        function u(t, n) {
          const { bulletActiveClass: r } = e.params.pagination;
          t[n]().addClass(`${r}-${n}`)[n]().addClass(`${r}-${n}-${n}`);
        }
        function p() {
          const t = e.rtl,
            n = e.params.pagination;
          if (l()) return;
          const r =
              e.virtual && e.params.virtual.enabled
                ? e.virtual.slides.length
                : e.slides.length,
            i = e.pagination.$el;
          let p;
          const d = e.params.loop
            ? Math.ceil((r - 2 * e.loopedSlides) / e.params.slidesPerGroup)
            : e.snapGrid.length;
          if (
            (e.params.loop
              ? ((p = Math.ceil(
                  (e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup
                )),
                p > r - 1 - 2 * e.loopedSlides && (p -= r - 2 * e.loopedSlides),
                p > d - 1 && (p -= d),
                p < 0 && "bullets" !== e.params.paginationType && (p = d + p))
              : (p = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0),
            "bullets" === n.type &&
              e.pagination.bullets &&
              e.pagination.bullets.length > 0)
          ) {
            const r = e.pagination.bullets;
            let s, l, d;
            if (
              (n.dynamicBullets &&
                ((a = r.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"]),
                i.css(
                  e.isHorizontal() ? "width" : "height",
                  a * (n.dynamicMainBullets + 4) + "px"
                ),
                n.dynamicMainBullets > 1 &&
                  void 0 !== e.previousIndex &&
                  ((o += p - (e.previousIndex - e.loopedSlides || 0)),
                  o > n.dynamicMainBullets - 1
                    ? (o = n.dynamicMainBullets - 1)
                    : o < 0 && (o = 0)),
                (s = Math.max(p - o, 0)),
                (l = s + (Math.min(r.length, n.dynamicMainBullets) - 1)),
                (d = (l + s) / 2)),
              r.removeClass(
                ["", "-next", "-next-next", "-prev", "-prev-prev", "-main"]
                  .map((t) => `${n.bulletActiveClass}${t}`)
                  .join(" ")
              ),
              i.length > 1)
            )
              r.each((t) => {
                const e = c(t),
                  r = e.index();
                r === p && e.addClass(n.bulletActiveClass),
                  n.dynamicBullets &&
                    (r >= s &&
                      r <= l &&
                      e.addClass(`${n.bulletActiveClass}-main`),
                    r === s && u(e, "prev"),
                    r === l && u(e, "next"));
              });
            else {
              const t = r.eq(p),
                i = t.index();
              if ((t.addClass(n.bulletActiveClass), n.dynamicBullets)) {
                const t = r.eq(s),
                  a = r.eq(l);
                for (let t = s; t <= l; t += 1)
                  r.eq(t).addClass(`${n.bulletActiveClass}-main`);
                if (e.params.loop)
                  if (i >= r.length) {
                    for (let t = n.dynamicMainBullets; t >= 0; t -= 1)
                      r.eq(r.length - t).addClass(
                        `${n.bulletActiveClass}-main`
                      );
                    r.eq(r.length - n.dynamicMainBullets - 1).addClass(
                      `${n.bulletActiveClass}-prev`
                    );
                  } else u(t, "prev"), u(a, "next");
                else u(t, "prev"), u(a, "next");
              }
            }
            if (n.dynamicBullets) {
              const s = Math.min(r.length, n.dynamicMainBullets + 4),
                i = (a * s - a) / 2 - d * a,
                o = t ? "right" : "left";
              r.css(e.isHorizontal() ? o : "top", `${i}px`);
            }
          }
          if (
            ("fraction" === n.type &&
              (i.find(X(n.currentClass)).text(n.formatFractionCurrent(p + 1)),
              i.find(X(n.totalClass)).text(n.formatFractionTotal(d))),
            "progressbar" === n.type)
          ) {
            let t;
            t = n.progressbarOpposite
              ? e.isHorizontal()
                ? "vertical"
                : "horizontal"
              : e.isHorizontal()
              ? "horizontal"
              : "vertical";
            const r = (p + 1) / d;
            let s = 1,
              a = 1;
            "horizontal" === t ? (s = r) : (a = r),
              i
                .find(X(n.progressbarFillClass))
                .transform(`translate3d(0,0,0) scaleX(${s}) scaleY(${a})`)
                .transition(e.params.speed);
          }
          "custom" === n.type && n.renderCustom
            ? (i.html(n.renderCustom(e, p + 1, d)), s("paginationRender", i[0]))
            : s("paginationUpdate", i[0]),
            e.params.watchOverflow &&
              e.enabled &&
              i[e.isLocked ? "addClass" : "removeClass"](n.lockClass);
        }
        function d() {
          const t = e.params.pagination;
          if (l()) return;
          const n =
              e.virtual && e.params.virtual.enabled
                ? e.virtual.slides.length
                : e.slides.length,
            r = e.pagination.$el;
          let i = "";
          if ("bullets" === t.type) {
            let s = e.params.loop
              ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup)
              : e.snapGrid.length;
            e.params.freeMode &&
              e.params.freeMode.enabled &&
              !e.params.loop &&
              s > n &&
              (s = n);
            for (let n = 0; n < s; n += 1)
              t.renderBullet
                ? (i += t.renderBullet.call(e, n, t.bulletClass))
                : (i += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`);
            r.html(i), (e.pagination.bullets = r.find(X(t.bulletClass)));
          }
          "fraction" === t.type &&
            ((i = t.renderFraction
              ? t.renderFraction.call(e, t.currentClass, t.totalClass)
              : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`),
            r.html(i)),
            "progressbar" === t.type &&
              ((i = t.renderProgressbar
                ? t.renderProgressbar.call(e, t.progressbarFillClass)
                : `<span class="${t.progressbarFillClass}"></span>`),
              r.html(i)),
            "custom" !== t.type && s("paginationRender", e.pagination.$el[0]);
        }
        function f() {
          e.params.pagination = Y(
            e,
            e.originalParams.pagination,
            e.params.pagination,
            { el: "swiper-pagination" }
          );
          const t = e.params.pagination;
          if (!t.el) return;
          let n = c(t.el);
          0 !== n.length &&
            (e.params.uniqueNavElements &&
              "string" == typeof t.el &&
              n.length > 1 &&
              ((n = e.$el.find(t.el)),
              n.length > 1 &&
                (n = n.filter((t) => c(t).parents(".swiper")[0] === e.el))),
            "bullets" === t.type && t.clickable && n.addClass(t.clickableClass),
            n.addClass(t.modifierClass + t.type),
            n.addClass(e.isHorizontal() ? t.horizontalClass : t.verticalClass),
            "bullets" === t.type &&
              t.dynamicBullets &&
              (n.addClass(`${t.modifierClass}${t.type}-dynamic`),
              (o = 0),
              t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)),
            "progressbar" === t.type &&
              t.progressbarOpposite &&
              n.addClass(t.progressbarOppositeClass),
            t.clickable &&
              n.on("click", X(t.bulletClass), function (t) {
                t.preventDefault();
                let n = c(this).index() * e.params.slidesPerGroup;
                e.params.loop && (n += e.loopedSlides), e.slideTo(n);
              }),
            Object.assign(e.pagination, { $el: n, el: n[0] }),
            e.enabled || n.addClass(t.lockClass));
        }
        function h() {
          const t = e.params.pagination;
          if (l()) return;
          const n = e.pagination.$el;
          n.removeClass(t.hiddenClass),
            n.removeClass(t.modifierClass + t.type),
            n.removeClass(
              e.isHorizontal() ? t.horizontalClass : t.verticalClass
            ),
            e.pagination.bullets &&
              e.pagination.bullets.removeClass &&
              e.pagination.bullets.removeClass(t.bulletActiveClass),
            t.clickable && n.off("click", X(t.bulletClass));
        }
        r("init", () => {
          !1 === e.params.pagination.enabled ? m() : (f(), d(), p());
        }),
          r("activeIndexChange", () => {
            (e.params.loop || void 0 === e.snapIndex) && p();
          }),
          r("snapIndexChange", () => {
            e.params.loop || p();
          }),
          r("slidesLengthChange", () => {
            e.params.loop && (d(), p());
          }),
          r("snapGridLengthChange", () => {
            e.params.loop || (d(), p());
          }),
          r("destroy", () => {
            h();
          }),
          r("enable disable", () => {
            const { $el: t } = e.pagination;
            t &&
              t[e.enabled ? "removeClass" : "addClass"](
                e.params.pagination.lockClass
              );
          }),
          r("lock unlock", () => {
            p();
          }),
          r("click", (t, n) => {
            const r = n.target,
              { $el: i } = e.pagination;
            if (
              e.params.pagination.el &&
              e.params.pagination.hideOnClick &&
              i &&
              i.length > 0 &&
              !c(r).hasClass(e.params.pagination.bulletClass)
            ) {
              if (
                e.navigation &&
                ((e.navigation.nextEl && r === e.navigation.nextEl) ||
                  (e.navigation.prevEl && r === e.navigation.prevEl))
              )
                return;
              const t = i.hasClass(e.params.pagination.hiddenClass);
              s(!0 === t ? "paginationShow" : "paginationHide"),
                i.toggleClass(e.params.pagination.hiddenClass);
            }
          });
        const m = () => {
          e.$el.addClass(e.params.pagination.paginationDisabledClass),
            e.pagination.$el &&
              e.pagination.$el.addClass(
                e.params.pagination.paginationDisabledClass
              ),
            h();
        };
        Object.assign(e.pagination, {
          enable: () => {
            e.$el.removeClass(e.params.pagination.paginationDisabledClass),
              e.pagination.$el &&
                e.pagination.$el.removeClass(
                  e.params.pagination.paginationDisabledClass
                ),
              f(),
              d(),
              p();
          },
          disable: m,
          render: d,
          update: p,
          init: f,
          destroy: h,
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: s, emit: i } = t;
        const a = r();
        let o,
          l,
          u,
          d,
          f = !1,
          h = null,
          m = null;
        function g() {
          if (!e.params.scrollbar.el || !e.scrollbar.el) return;
          const { scrollbar: t, rtlTranslate: n, progress: r } = e,
            { $dragEl: s, $el: i } = t,
            a = e.params.scrollbar;
          let o = l,
            c = (u - l) * r;
          n
            ? ((c = -c),
              c > 0 ? ((o = l - c), (c = 0)) : -c + l > u && (o = u + c))
            : c < 0
            ? ((o = l + c), (c = 0))
            : c + l > u && (o = u - c),
            e.isHorizontal()
              ? (s.transform(`translate3d(${c}px, 0, 0)`),
                (s[0].style.width = `${o}px`))
              : (s.transform(`translate3d(0px, ${c}px, 0)`),
                (s[0].style.height = `${o}px`)),
            a.hide &&
              (clearTimeout(h),
              (i[0].style.opacity = 1),
              (h = setTimeout(() => {
                (i[0].style.opacity = 0), i.transition(400);
              }, 1e3)));
        }
        function v() {
          if (!e.params.scrollbar.el || !e.scrollbar.el) return;
          const { scrollbar: t } = e,
            { $dragEl: n, $el: r } = t;
          (n[0].style.width = ""),
            (n[0].style.height = ""),
            (u = e.isHorizontal() ? r[0].offsetWidth : r[0].offsetHeight),
            (d =
              e.size /
              (e.virtualSize +
                e.params.slidesOffsetBefore -
                (e.params.centeredSlides ? e.snapGrid[0] : 0))),
            (l =
              "auto" === e.params.scrollbar.dragSize
                ? u * d
                : parseInt(e.params.scrollbar.dragSize, 10)),
            e.isHorizontal()
              ? (n[0].style.width = `${l}px`)
              : (n[0].style.height = `${l}px`),
            (r[0].style.display = d >= 1 ? "none" : ""),
            e.params.scrollbar.hide && (r[0].style.opacity = 0),
            e.params.watchOverflow &&
              e.enabled &&
              t.$el[e.isLocked ? "addClass" : "removeClass"](
                e.params.scrollbar.lockClass
              );
        }
        function y(t) {
          return e.isHorizontal()
            ? "touchstart" === t.type || "touchmove" === t.type
              ? t.targetTouches[0].clientX
              : t.clientX
            : "touchstart" === t.type || "touchmove" === t.type
            ? t.targetTouches[0].clientY
            : t.clientY;
        }
        function b(t) {
          const { scrollbar: n, rtlTranslate: r } = e,
            { $el: s } = n;
          let i;
          (i =
            (y(t) -
              s.offset()[e.isHorizontal() ? "left" : "top"] -
              (null !== o ? o : l / 2)) /
            (u - l)),
            (i = Math.max(Math.min(i, 1), 0)),
            r && (i = 1 - i);
          const a =
            e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * i;
          e.updateProgress(a),
            e.setTranslate(a),
            e.updateActiveIndex(),
            e.updateSlidesClasses();
        }
        function _(t) {
          const n = e.params.scrollbar,
            { scrollbar: r, $wrapperEl: s } = e,
            { $el: a, $dragEl: l } = r;
          (f = !0),
            (o =
              t.target === l[0] || t.target === l
                ? y(t) -
                  t.target.getBoundingClientRect()[
                    e.isHorizontal() ? "left" : "top"
                  ]
                : null),
            t.preventDefault(),
            t.stopPropagation(),
            s.transition(100),
            l.transition(100),
            b(t),
            clearTimeout(m),
            a.transition(0),
            n.hide && a.css("opacity", 1),
            e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"),
            i("scrollbarDragStart", t);
        }
        function w(t) {
          const { scrollbar: n, $wrapperEl: r } = e,
            { $el: s, $dragEl: a } = n;
          f &&
            (t.preventDefault ? t.preventDefault() : (t.returnValue = !1),
            b(t),
            r.transition(0),
            s.transition(0),
            a.transition(0),
            i("scrollbarDragMove", t));
        }
        function S(t) {
          const n = e.params.scrollbar,
            { scrollbar: r, $wrapperEl: s } = e,
            { $el: a } = r;
          f &&
            ((f = !1),
            e.params.cssMode &&
              (e.$wrapperEl.css("scroll-snap-type", ""), s.transition("")),
            n.hide &&
              (clearTimeout(m),
              (m = p(() => {
                a.css("opacity", 0), a.transition(400);
              }, 1e3))),
            i("scrollbarDragEnd", t),
            n.snapOnRelease && e.slideToClosest());
        }
        function C(t) {
          const {
              scrollbar: n,
              touchEventsTouch: r,
              touchEventsDesktop: s,
              params: i,
              support: o,
            } = e,
            l = n.$el;
          if (!l) return;
          const c = l[0],
            u = !(!o.passiveListener || !i.passiveListeners) && {
              passive: !1,
              capture: !1,
            },
            p = !(!o.passiveListener || !i.passiveListeners) && {
              passive: !0,
              capture: !1,
            };
          if (!c) return;
          const d = "on" === t ? "addEventListener" : "removeEventListener";
          o.touch
            ? (c[d](r.start, _, u), c[d](r.move, w, u), c[d](r.end, S, p))
            : (c[d](s.start, _, u), a[d](s.move, w, u), a[d](s.end, S, p));
        }
        function x() {
          const { scrollbar: t, $el: n } = e;
          e.params.scrollbar = Y(
            e,
            e.originalParams.scrollbar,
            e.params.scrollbar,
            { el: "swiper-scrollbar" }
          );
          const r = e.params.scrollbar;
          if (!r.el) return;
          let s = c(r.el);
          e.params.uniqueNavElements &&
            "string" == typeof r.el &&
            s.length > 1 &&
            1 === n.find(r.el).length &&
            (s = n.find(r.el)),
            s.addClass(e.isHorizontal() ? r.horizontalClass : r.verticalClass);
          let i = s.find(`.${e.params.scrollbar.dragClass}`);
          0 === i.length &&
            ((i = c(`<div class="${e.params.scrollbar.dragClass}"></div>`)),
            s.append(i)),
            Object.assign(t, { $el: s, el: s[0], $dragEl: i, dragEl: i[0] }),
            r.draggable && e.params.scrollbar.el && e.scrollbar.el && C("on"),
            s &&
              s[e.enabled ? "removeClass" : "addClass"](
                e.params.scrollbar.lockClass
              );
        }
        function k() {
          const t = e.params.scrollbar,
            n = e.scrollbar.$el;
          n &&
            n.removeClass(
              e.isHorizontal() ? t.horizontalClass : t.verticalClass
            ),
            e.params.scrollbar.el && e.scrollbar.el && C("off");
        }
        n({
          scrollbar: {
            el: null,
            dragSize: "auto",
            hide: !1,
            draggable: !1,
            snapOnRelease: !0,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: "swiper-scrollbar-horizontal",
            verticalClass: "swiper-scrollbar-vertical",
          },
        }),
          (e.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }),
          s("init", () => {
            !1 === e.params.scrollbar.enabled ? E() : (x(), v(), g());
          }),
          s("update resize observerUpdate lock unlock", () => {
            v();
          }),
          s("setTranslate", () => {
            g();
          }),
          s("setTransition", (t, n) => {
            !(function (t) {
              e.params.scrollbar.el &&
                e.scrollbar.el &&
                e.scrollbar.$dragEl.transition(t);
            })(n);
          }),
          s("enable disable", () => {
            const { $el: t } = e.scrollbar;
            t &&
              t[e.enabled ? "removeClass" : "addClass"](
                e.params.scrollbar.lockClass
              );
          }),
          s("destroy", () => {
            k();
          });
        const E = () => {
          e.$el.addClass(e.params.scrollbar.scrollbarDisabledClass),
            e.scrollbar.$el &&
              e.scrollbar.$el.addClass(
                e.params.scrollbar.scrollbarDisabledClass
              ),
            k();
        };
        Object.assign(e.scrollbar, {
          enable: () => {
            e.$el.removeClass(e.params.scrollbar.scrollbarDisabledClass),
              e.scrollbar.$el &&
                e.scrollbar.$el.removeClass(
                  e.params.scrollbar.scrollbarDisabledClass
                ),
              x(),
              v(),
              g();
          },
          disable: E,
          updateSize: v,
          setTranslate: g,
          init: x,
          destroy: k,
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({ parallax: { enabled: !1 } });
        const s = (t, n) => {
            const { rtl: r } = e,
              s = c(t),
              i = r ? -1 : 1,
              a = s.attr("data-swiper-parallax") || "0";
            let o = s.attr("data-swiper-parallax-x"),
              l = s.attr("data-swiper-parallax-y");
            const u = s.attr("data-swiper-parallax-scale"),
              p = s.attr("data-swiper-parallax-opacity");
            if (
              (o || l
                ? ((o = o || "0"), (l = l || "0"))
                : e.isHorizontal()
                ? ((o = a), (l = "0"))
                : ((l = a), (o = "0")),
              (o =
                o.indexOf("%") >= 0
                  ? parseInt(o, 10) * n * i + "%"
                  : o * n * i + "px"),
              (l =
                l.indexOf("%") >= 0 ? parseInt(l, 10) * n + "%" : l * n + "px"),
              null != p)
            ) {
              const t = p - (p - 1) * (1 - Math.abs(n));
              s[0].style.opacity = t;
            }
            if (null == u) s.transform(`translate3d(${o}, ${l}, 0px)`);
            else {
              const t = u - (u - 1) * (1 - Math.abs(n));
              s.transform(`translate3d(${o}, ${l}, 0px) scale(${t})`);
            }
          },
          i = () => {
            const { $el: t, slides: n, progress: r, snapGrid: i } = e;
            t
              .children(
                "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
              )
              .each((t) => {
                s(t, r);
              }),
              n.each((t, n) => {
                let a = t.progress;
                e.params.slidesPerGroup > 1 &&
                  "auto" !== e.params.slidesPerView &&
                  (a += Math.ceil(n / 2) - r * (i.length - 1)),
                  (a = Math.min(Math.max(a, -1), 1)),
                  c(t)
                    .find(
                      "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                    )
                    .each((t) => {
                      s(t, a);
                    });
              });
          };
        r("beforeInit", () => {
          e.params.parallax.enabled &&
            ((e.params.watchSlidesProgress = !0),
            (e.originalParams.watchSlidesProgress = !0));
        }),
          r("init", () => {
            e.params.parallax.enabled && i();
          }),
          r("setTranslate", () => {
            e.params.parallax.enabled && i();
          }),
          r("setTransition", (t, n) => {
            e.params.parallax.enabled &&
              (function (t) {
                void 0 === t && (t = e.params.speed);
                const { $el: n } = e;
                n.find(
                  "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                ).each((e) => {
                  const n = c(e);
                  let r =
                    parseInt(n.attr("data-swiper-parallax-duration"), 10) || t;
                  0 === t && (r = 0), n.transition(r);
                });
              })(n);
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r, emit: s } = t;
        const a = i();
        n({
          zoom: {
            enabled: !1,
            maxRatio: 3,
            minRatio: 1,
            toggle: !0,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed",
          },
        }),
          (e.zoom = { enabled: !1 });
        let o,
          l,
          u,
          p = 1,
          d = !1;
        const h = {
            $slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            $imageEl: void 0,
            $imageWrapEl: void 0,
            maxRatio: 3,
          },
          m = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {},
          },
          g = {
            x: void 0,
            y: void 0,
            prevPositionX: void 0,
            prevPositionY: void 0,
            prevTime: void 0,
          };
        let v = 1;
        function y(t) {
          if (t.targetTouches.length < 2) return 1;
          const e = t.targetTouches[0].pageX,
            n = t.targetTouches[0].pageY,
            r = t.targetTouches[1].pageX,
            s = t.targetTouches[1].pageY;
          return Math.sqrt((r - e) ** 2 + (s - n) ** 2);
        }
        function b(t) {
          const n = e.support,
            r = e.params.zoom;
          if (((l = !1), (u = !1), !n.gestures)) {
            if (
              "touchstart" !== t.type ||
              ("touchstart" === t.type && t.targetTouches.length < 2)
            )
              return;
            (l = !0), (h.scaleStart = y(t));
          }
          (h.$slideEl && h.$slideEl.length) ||
          ((h.$slideEl = c(t.target).closest(`.${e.params.slideClass}`)),
          0 === h.$slideEl.length && (h.$slideEl = e.slides.eq(e.activeIndex)),
          (h.$imageEl = h.$slideEl
            .find(`.${r.containerClass}`)
            .eq(0)
            .find("picture, img, svg, canvas, .swiper-zoom-target")
            .eq(0)),
          (h.$imageWrapEl = h.$imageEl.parent(`.${r.containerClass}`)),
          (h.maxRatio = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio),
          0 !== h.$imageWrapEl.length)
            ? (h.$imageEl && h.$imageEl.transition(0), (d = !0))
            : (h.$imageEl = void 0);
        }
        function _(t) {
          const n = e.support,
            r = e.params.zoom,
            s = e.zoom;
          if (!n.gestures) {
            if (
              "touchmove" !== t.type ||
              ("touchmove" === t.type && t.targetTouches.length < 2)
            )
              return;
            (u = !0), (h.scaleMove = y(t));
          }
          h.$imageEl && 0 !== h.$imageEl.length
            ? (n.gestures
                ? (s.scale = t.scale * p)
                : (s.scale = (h.scaleMove / h.scaleStart) * p),
              s.scale > h.maxRatio &&
                (s.scale = h.maxRatio - 1 + (s.scale - h.maxRatio + 1) ** 0.5),
              s.scale < r.minRatio &&
                (s.scale = r.minRatio + 1 - (r.minRatio - s.scale + 1) ** 0.5),
              h.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`))
            : "gesturechange" === t.type && b(t);
        }
        function w(t) {
          const n = e.device,
            r = e.support,
            s = e.params.zoom,
            i = e.zoom;
          if (!r.gestures) {
            if (!l || !u) return;
            if (
              "touchend" !== t.type ||
              ("touchend" === t.type &&
                t.changedTouches.length < 2 &&
                !n.android)
            )
              return;
            (l = !1), (u = !1);
          }
          h.$imageEl &&
            0 !== h.$imageEl.length &&
            ((i.scale = Math.max(Math.min(i.scale, h.maxRatio), s.minRatio)),
            h.$imageEl
              .transition(e.params.speed)
              .transform(`translate3d(0,0,0) scale(${i.scale})`),
            (p = i.scale),
            (d = !1),
            1 === i.scale && (h.$slideEl = void 0));
        }
        function S(t) {
          const n = e.zoom;
          if (!h.$imageEl || 0 === h.$imageEl.length) return;
          if (((e.allowClick = !1), !m.isTouched || !h.$slideEl)) return;
          m.isMoved ||
            ((m.width = h.$imageEl[0].offsetWidth),
            (m.height = h.$imageEl[0].offsetHeight),
            (m.startX = f(h.$imageWrapEl[0], "x") || 0),
            (m.startY = f(h.$imageWrapEl[0], "y") || 0),
            (h.slideWidth = h.$slideEl[0].offsetWidth),
            (h.slideHeight = h.$slideEl[0].offsetHeight),
            h.$imageWrapEl.transition(0));
          const r = m.width * n.scale,
            s = m.height * n.scale;
          if (!(r < h.slideWidth && s < h.slideHeight)) {
            if (
              ((m.minX = Math.min(h.slideWidth / 2 - r / 2, 0)),
              (m.maxX = -m.minX),
              (m.minY = Math.min(h.slideHeight / 2 - s / 2, 0)),
              (m.maxY = -m.minY),
              (m.touchesCurrent.x =
                "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX),
              (m.touchesCurrent.y =
                "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY),
              !m.isMoved && !d)
            ) {
              if (
                e.isHorizontal() &&
                ((Math.floor(m.minX) === Math.floor(m.startX) &&
                  m.touchesCurrent.x < m.touchesStart.x) ||
                  (Math.floor(m.maxX) === Math.floor(m.startX) &&
                    m.touchesCurrent.x > m.touchesStart.x))
              )
                return void (m.isTouched = !1);
              if (
                !e.isHorizontal() &&
                ((Math.floor(m.minY) === Math.floor(m.startY) &&
                  m.touchesCurrent.y < m.touchesStart.y) ||
                  (Math.floor(m.maxY) === Math.floor(m.startY) &&
                    m.touchesCurrent.y > m.touchesStart.y))
              )
                return void (m.isTouched = !1);
            }
            t.cancelable && t.preventDefault(),
              t.stopPropagation(),
              (m.isMoved = !0),
              (m.currentX = m.touchesCurrent.x - m.touchesStart.x + m.startX),
              (m.currentY = m.touchesCurrent.y - m.touchesStart.y + m.startY),
              m.currentX < m.minX &&
                (m.currentX = m.minX + 1 - (m.minX - m.currentX + 1) ** 0.8),
              m.currentX > m.maxX &&
                (m.currentX = m.maxX - 1 + (m.currentX - m.maxX + 1) ** 0.8),
              m.currentY < m.minY &&
                (m.currentY = m.minY + 1 - (m.minY - m.currentY + 1) ** 0.8),
              m.currentY > m.maxY &&
                (m.currentY = m.maxY - 1 + (m.currentY - m.maxY + 1) ** 0.8),
              g.prevPositionX || (g.prevPositionX = m.touchesCurrent.x),
              g.prevPositionY || (g.prevPositionY = m.touchesCurrent.y),
              g.prevTime || (g.prevTime = Date.now()),
              (g.x =
                (m.touchesCurrent.x - g.prevPositionX) /
                (Date.now() - g.prevTime) /
                2),
              (g.y =
                (m.touchesCurrent.y - g.prevPositionY) /
                (Date.now() - g.prevTime) /
                2),
              Math.abs(m.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0),
              Math.abs(m.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0),
              (g.prevPositionX = m.touchesCurrent.x),
              (g.prevPositionY = m.touchesCurrent.y),
              (g.prevTime = Date.now()),
              h.$imageWrapEl.transform(
                `translate3d(${m.currentX}px, ${m.currentY}px,0)`
              );
          }
        }
        function C() {
          const t = e.zoom;
          h.$slideEl &&
            e.previousIndex !== e.activeIndex &&
            (h.$imageEl && h.$imageEl.transform("translate3d(0,0,0) scale(1)"),
            h.$imageWrapEl && h.$imageWrapEl.transform("translate3d(0,0,0)"),
            (t.scale = 1),
            (p = 1),
            (h.$slideEl = void 0),
            (h.$imageEl = void 0),
            (h.$imageWrapEl = void 0));
        }
        function x(t) {
          const n = e.zoom,
            r = e.params.zoom;
          if (
            (h.$slideEl ||
              (t &&
                t.target &&
                (h.$slideEl = c(t.target).closest(`.${e.params.slideClass}`)),
              h.$slideEl ||
                (e.params.virtual && e.params.virtual.enabled && e.virtual
                  ? (h.$slideEl = e.$wrapperEl.children(
                      `.${e.params.slideActiveClass}`
                    ))
                  : (h.$slideEl = e.slides.eq(e.activeIndex))),
              (h.$imageEl = h.$slideEl
                .find(`.${r.containerClass}`)
                .eq(0)
                .find("picture, img, svg, canvas, .swiper-zoom-target")
                .eq(0)),
              (h.$imageWrapEl = h.$imageEl.parent(`.${r.containerClass}`))),
            !h.$imageEl ||
              0 === h.$imageEl.length ||
              !h.$imageWrapEl ||
              0 === h.$imageWrapEl.length)
          )
            return;
          let s, i, o, l, u, d, f, g, v, y, b, _, w, S, C, x, k, E;
          e.params.cssMode &&
            ((e.wrapperEl.style.overflow = "hidden"),
            (e.wrapperEl.style.touchAction = "none")),
            h.$slideEl.addClass(`${r.zoomedSlideClass}`),
            void 0 === m.touchesStart.x && t
              ? ((s =
                  "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX),
                (i =
                  "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY))
              : ((s = m.touchesStart.x), (i = m.touchesStart.y)),
            (n.scale = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio),
            (p = h.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio),
            t
              ? ((k = h.$slideEl[0].offsetWidth),
                (E = h.$slideEl[0].offsetHeight),
                (o = h.$slideEl.offset().left + a.scrollX),
                (l = h.$slideEl.offset().top + a.scrollY),
                (u = o + k / 2 - s),
                (d = l + E / 2 - i),
                (v = h.$imageEl[0].offsetWidth),
                (y = h.$imageEl[0].offsetHeight),
                (b = v * n.scale),
                (_ = y * n.scale),
                (w = Math.min(k / 2 - b / 2, 0)),
                (S = Math.min(E / 2 - _ / 2, 0)),
                (C = -w),
                (x = -S),
                (f = u * n.scale),
                (g = d * n.scale),
                f < w && (f = w),
                f > C && (f = C),
                g < S && (g = S),
                g > x && (g = x))
              : ((f = 0), (g = 0)),
            h.$imageWrapEl
              .transition(300)
              .transform(`translate3d(${f}px, ${g}px,0)`),
            h.$imageEl
              .transition(300)
              .transform(`translate3d(0,0,0) scale(${n.scale})`);
        }
        function k() {
          const t = e.zoom,
            n = e.params.zoom;
          h.$slideEl ||
            (e.params.virtual && e.params.virtual.enabled && e.virtual
              ? (h.$slideEl = e.$wrapperEl.children(
                  `.${e.params.slideActiveClass}`
                ))
              : (h.$slideEl = e.slides.eq(e.activeIndex)),
            (h.$imageEl = h.$slideEl
              .find(`.${n.containerClass}`)
              .eq(0)
              .find("picture, img, svg, canvas, .swiper-zoom-target")
              .eq(0)),
            (h.$imageWrapEl = h.$imageEl.parent(`.${n.containerClass}`))),
            h.$imageEl &&
              0 !== h.$imageEl.length &&
              h.$imageWrapEl &&
              0 !== h.$imageWrapEl.length &&
              (e.params.cssMode &&
                ((e.wrapperEl.style.overflow = ""),
                (e.wrapperEl.style.touchAction = "")),
              (t.scale = 1),
              (p = 1),
              h.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"),
              h.$imageEl
                .transition(300)
                .transform("translate3d(0,0,0) scale(1)"),
              h.$slideEl.removeClass(`${n.zoomedSlideClass}`),
              (h.$slideEl = void 0));
        }
        function E(t) {
          const n = e.zoom;
          n.scale && 1 !== n.scale ? k() : x(t);
        }
        function T() {
          const t = e.support;
          return {
            passiveListener: !(
              "touchstart" !== e.touchEvents.start ||
              !t.passiveListener ||
              !e.params.passiveListeners
            ) && { passive: !0, capture: !1 },
            activeListenerWithCapture: !t.passiveListener || {
              passive: !1,
              capture: !0,
            },
          };
        }
        function P() {
          return `.${e.params.slideClass}`;
        }
        function M(t) {
          const { passiveListener: n } = T(),
            r = P();
          e.$wrapperEl[t]("gesturestart", r, b, n),
            e.$wrapperEl[t]("gesturechange", r, _, n),
            e.$wrapperEl[t]("gestureend", r, w, n);
        }
        function O() {
          o || ((o = !0), M("on"));
        }
        function A() {
          o && ((o = !1), M("off"));
        }
        function j() {
          const t = e.zoom;
          if (t.enabled) return;
          t.enabled = !0;
          const n = e.support,
            { passiveListener: r, activeListenerWithCapture: s } = T(),
            i = P();
          n.gestures
            ? (e.$wrapperEl.on(e.touchEvents.start, O, r),
              e.$wrapperEl.on(e.touchEvents.end, A, r))
            : "touchstart" === e.touchEvents.start &&
              (e.$wrapperEl.on(e.touchEvents.start, i, b, r),
              e.$wrapperEl.on(e.touchEvents.move, i, _, s),
              e.$wrapperEl.on(e.touchEvents.end, i, w, r),
              e.touchEvents.cancel &&
                e.$wrapperEl.on(e.touchEvents.cancel, i, w, r)),
            e.$wrapperEl.on(
              e.touchEvents.move,
              `.${e.params.zoom.containerClass}`,
              S,
              s
            );
        }
        function $() {
          const t = e.zoom;
          if (!t.enabled) return;
          const n = e.support;
          t.enabled = !1;
          const { passiveListener: r, activeListenerWithCapture: s } = T(),
            i = P();
          n.gestures
            ? (e.$wrapperEl.off(e.touchEvents.start, O, r),
              e.$wrapperEl.off(e.touchEvents.end, A, r))
            : "touchstart" === e.touchEvents.start &&
              (e.$wrapperEl.off(e.touchEvents.start, i, b, r),
              e.$wrapperEl.off(e.touchEvents.move, i, _, s),
              e.$wrapperEl.off(e.touchEvents.end, i, w, r),
              e.touchEvents.cancel &&
                e.$wrapperEl.off(e.touchEvents.cancel, i, w, r)),
            e.$wrapperEl.off(
              e.touchEvents.move,
              `.${e.params.zoom.containerClass}`,
              S,
              s
            );
        }
        Object.defineProperty(e.zoom, "scale", {
          get: () => v,
          set(t) {
            if (v !== t) {
              const e = h.$imageEl ? h.$imageEl[0] : void 0,
                n = h.$slideEl ? h.$slideEl[0] : void 0;
              s("zoomChange", t, e, n);
            }
            v = t;
          },
        }),
          r("init", () => {
            e.params.zoom.enabled && j();
          }),
          r("destroy", () => {
            $();
          }),
          r("touchStart", (t, n) => {
            e.zoom.enabled &&
              (function (t) {
                const n = e.device;
                h.$imageEl &&
                  0 !== h.$imageEl.length &&
                  (m.isTouched ||
                    (n.android && t.cancelable && t.preventDefault(),
                    (m.isTouched = !0),
                    (m.touchesStart.x =
                      "touchstart" === t.type
                        ? t.targetTouches[0].pageX
                        : t.pageX),
                    (m.touchesStart.y =
                      "touchstart" === t.type
                        ? t.targetTouches[0].pageY
                        : t.pageY)));
              })(n);
          }),
          r("touchEnd", () => {
            e.zoom.enabled &&
              (function () {
                const t = e.zoom;
                if (!h.$imageEl || 0 === h.$imageEl.length) return;
                if (!m.isTouched || !m.isMoved)
                  return (m.isTouched = !1), void (m.isMoved = !1);
                (m.isTouched = !1), (m.isMoved = !1);
                let n = 300,
                  r = 300;
                const s = g.x * n,
                  i = m.currentX + s,
                  a = g.y * r,
                  o = m.currentY + a;
                0 !== g.x && (n = Math.abs((i - m.currentX) / g.x)),
                  0 !== g.y && (r = Math.abs((o - m.currentY) / g.y));
                const l = Math.max(n, r);
                (m.currentX = i), (m.currentY = o);
                const c = m.width * t.scale,
                  u = m.height * t.scale;
                (m.minX = Math.min(h.slideWidth / 2 - c / 2, 0)),
                  (m.maxX = -m.minX),
                  (m.minY = Math.min(h.slideHeight / 2 - u / 2, 0)),
                  (m.maxY = -m.minY),
                  (m.currentX = Math.max(Math.min(m.currentX, m.maxX), m.minX)),
                  (m.currentY = Math.max(Math.min(m.currentY, m.maxY), m.minY)),
                  h.$imageWrapEl
                    .transition(l)
                    .transform(
                      `translate3d(${m.currentX}px, ${m.currentY}px,0)`
                    );
              })();
          }),
          r("doubleTap", (t, n) => {
            !e.animating &&
              e.params.zoom.enabled &&
              e.zoom.enabled &&
              e.params.zoom.toggle &&
              E(n);
          }),
          r("transitionEnd", () => {
            e.zoom.enabled && e.params.zoom.enabled && C();
          }),
          r("slideChange", () => {
            e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && C();
          }),
          Object.assign(e.zoom, {
            enable: j,
            disable: $,
            in: x,
            out: k,
            toggle: E,
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r, emit: s } = t;
        n({
          lazy: {
            checkInView: !1,
            enabled: !1,
            loadPrevNext: !1,
            loadPrevNextAmount: 1,
            loadOnTransitionStart: !1,
            scrollingElement: "",
            elementClass: "swiper-lazy",
            loadingClass: "swiper-lazy-loading",
            loadedClass: "swiper-lazy-loaded",
            preloaderClass: "swiper-lazy-preloader",
          },
        }),
          (e.lazy = {});
        let a = !1,
          o = !1;
        function l(t, n) {
          void 0 === n && (n = !0);
          const r = e.params.lazy;
          if (void 0 === t) return;
          if (0 === e.slides.length) return;
          const i =
              e.virtual && e.params.virtual.enabled
                ? e.$wrapperEl.children(
                    `.${e.params.slideClass}[data-swiper-slide-index="${t}"]`
                  )
                : e.slides.eq(t),
            a = i.find(
              `.${r.elementClass}:not(.${r.loadedClass}):not(.${r.loadingClass})`
            );
          !i.hasClass(r.elementClass) ||
            i.hasClass(r.loadedClass) ||
            i.hasClass(r.loadingClass) ||
            a.push(i[0]),
            0 !== a.length &&
              a.each((t) => {
                const a = c(t);
                a.addClass(r.loadingClass);
                const o = a.attr("data-background"),
                  u = a.attr("data-src"),
                  p = a.attr("data-srcset"),
                  d = a.attr("data-sizes"),
                  f = a.parent("picture");
                e.loadImage(a[0], u || o, p, d, !1, () => {
                  if (null != e && e && (!e || e.params) && !e.destroyed) {
                    if (
                      (o
                        ? (a.css("background-image", `url("${o}")`),
                          a.removeAttr("data-background"))
                        : (p &&
                            (a.attr("srcset", p), a.removeAttr("data-srcset")),
                          d && (a.attr("sizes", d), a.removeAttr("data-sizes")),
                          f.length &&
                            f.children("source").each((t) => {
                              const e = c(t);
                              e.attr("data-srcset") &&
                                (e.attr("srcset", e.attr("data-srcset")),
                                e.removeAttr("data-srcset"));
                            }),
                          u && (a.attr("src", u), a.removeAttr("data-src"))),
                      a.addClass(r.loadedClass).removeClass(r.loadingClass),
                      i.find(`.${r.preloaderClass}`).remove(),
                      e.params.loop && n)
                    ) {
                      const t = i.attr("data-swiper-slide-index");
                      i.hasClass(e.params.slideDuplicateClass)
                        ? l(
                            e.$wrapperEl
                              .children(
                                `[data-swiper-slide-index="${t}"]:not(.${e.params.slideDuplicateClass})`
                              )
                              .index(),
                            !1
                          )
                        : l(
                            e.$wrapperEl
                              .children(
                                `.${e.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`
                              )
                              .index(),
                            !1
                          );
                    }
                    s("lazyImageReady", i[0], a[0]),
                      e.params.autoHeight && e.updateAutoHeight();
                  }
                }),
                  s("lazyImageLoad", i[0], a[0]);
              });
        }
        function u() {
          const { $wrapperEl: t, params: n, slides: r, activeIndex: s } = e,
            i = e.virtual && n.virtual.enabled,
            a = n.lazy;
          let u = n.slidesPerView;
          function p(e) {
            if (i) {
              if (
                t.children(`.${n.slideClass}[data-swiper-slide-index="${e}"]`)
                  .length
              )
                return !0;
            } else if (r[e]) return !0;
            return !1;
          }
          function d(t) {
            return i ? c(t).attr("data-swiper-slide-index") : c(t).index();
          }
          if (
            ("auto" === u && (u = 0),
            o || (o = !0),
            e.params.watchSlidesProgress)
          )
            t.children(`.${n.slideVisibleClass}`).each((t) => {
              l(i ? c(t).attr("data-swiper-slide-index") : c(t).index());
            });
          else if (u > 1) for (let t = s; t < s + u; t += 1) p(t) && l(t);
          else l(s);
          if (a.loadPrevNext)
            if (u > 1 || (a.loadPrevNextAmount && a.loadPrevNextAmount > 1)) {
              const t = a.loadPrevNextAmount,
                e = Math.ceil(u),
                n = Math.min(s + e + Math.max(t, e), r.length),
                i = Math.max(s - Math.max(e, t), 0);
              for (let t = s + e; t < n; t += 1) p(t) && l(t);
              for (let t = i; t < s; t += 1) p(t) && l(t);
            } else {
              const e = t.children(`.${n.slideNextClass}`);
              e.length > 0 && l(d(e));
              const r = t.children(`.${n.slidePrevClass}`);
              r.length > 0 && l(d(r));
            }
        }
        function p() {
          const t = i();
          if (!e || e.destroyed) return;
          const n = e.params.lazy.scrollingElement
              ? c(e.params.lazy.scrollingElement)
              : c(t),
            r = n[0] === t,
            s = r ? t.innerWidth : n[0].offsetWidth,
            o = r ? t.innerHeight : n[0].offsetHeight,
            l = e.$el.offset(),
            { rtlTranslate: d } = e;
          let f = !1;
          d && (l.left -= e.$el[0].scrollLeft);
          const h = [
            [l.left, l.top],
            [l.left + e.width, l.top],
            [l.left, l.top + e.height],
            [l.left + e.width, l.top + e.height],
          ];
          for (let t = 0; t < h.length; t += 1) {
            const e = h[t];
            if (e[0] >= 0 && e[0] <= s && e[1] >= 0 && e[1] <= o) {
              if (0 === e[0] && 0 === e[1]) continue;
              f = !0;
            }
          }
          const m = !(
            "touchstart" !== e.touchEvents.start ||
            !e.support.passiveListener ||
            !e.params.passiveListeners
          ) && { passive: !0, capture: !1 };
          f
            ? (u(), n.off("scroll", p, m))
            : a || ((a = !0), n.on("scroll", p, m));
        }
        r("beforeInit", () => {
          e.params.lazy.enabled &&
            e.params.preloadImages &&
            (e.params.preloadImages = !1);
        }),
          r("init", () => {
            e.params.lazy.enabled && (e.params.lazy.checkInView ? p() : u());
          }),
          r("scroll", () => {
            e.params.freeMode &&
              e.params.freeMode.enabled &&
              !e.params.freeMode.sticky &&
              u();
          }),
          r("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
            e.params.lazy.enabled && (e.params.lazy.checkInView ? p() : u());
          }),
          r("transitionStart", () => {
            e.params.lazy.enabled &&
              (e.params.lazy.loadOnTransitionStart ||
                (!e.params.lazy.loadOnTransitionStart && !o)) &&
              (e.params.lazy.checkInView ? p() : u());
          }),
          r("transitionEnd", () => {
            e.params.lazy.enabled &&
              !e.params.lazy.loadOnTransitionStart &&
              (e.params.lazy.checkInView ? p() : u());
          }),
          r("slideChange", () => {
            const {
              lazy: t,
              cssMode: n,
              watchSlidesProgress: r,
              touchReleaseOnEdges: s,
              resistanceRatio: i,
            } = e.params;
            t.enabled && (n || (r && (s || 0 === i))) && u();
          }),
          r("destroy", () => {
            e.$el &&
              e.$el
                .find(`.${e.params.lazy.loadingClass}`)
                .removeClass(e.params.lazy.loadingClass);
          }),
          Object.assign(e.lazy, { load: u, loadInSlide: l });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        function s(t, e) {
          const n = (function () {
            let t, e, n;
            return (r, s) => {
              for (e = -1, t = r.length; t - e > 1; )
                (n = (t + e) >> 1), r[n] <= s ? (e = n) : (t = n);
              return t;
            };
          })();
          let r, s;
          return (
            (this.x = t),
            (this.y = e),
            (this.lastIndex = t.length - 1),
            (this.interpolate = function (t) {
              return t
                ? ((s = n(this.x, t)),
                  (r = s - 1),
                  ((t - this.x[r]) * (this.y[s] - this.y[r])) /
                    (this.x[s] - this.x[r]) +
                    this.y[r])
                : 0;
            }),
            this
          );
        }
        function i() {
          e.controller.control &&
            e.controller.spline &&
            ((e.controller.spline = void 0), delete e.controller.spline);
        }
        n({ controller: { control: void 0, inverse: !1, by: "slide" } }),
          (e.controller = { control: void 0 }),
          r("beforeInit", () => {
            e.controller.control = e.params.controller.control;
          }),
          r("update", () => {
            i();
          }),
          r("resize", () => {
            i();
          }),
          r("observerUpdate", () => {
            i();
          }),
          r("setTranslate", (t, n, r) => {
            e.controller.control && e.controller.setTranslate(n, r);
          }),
          r("setTransition", (t, n, r) => {
            e.controller.control && e.controller.setTransition(n, r);
          }),
          Object.assign(e.controller, {
            setTranslate: function (t, n) {
              const r = e.controller.control;
              let i, a;
              const o = e.constructor;
              function l(t) {
                const n = e.rtlTranslate ? -e.translate : e.translate;
                "slide" === e.params.controller.by &&
                  ((function (t) {
                    e.controller.spline ||
                      (e.controller.spline = e.params.loop
                        ? new s(e.slidesGrid, t.slidesGrid)
                        : new s(e.snapGrid, t.snapGrid));
                  })(t),
                  (a = -e.controller.spline.interpolate(-n))),
                  (a && "container" !== e.params.controller.by) ||
                    ((i =
                      (t.maxTranslate() - t.minTranslate()) /
                      (e.maxTranslate() - e.minTranslate())),
                    (a = (n - e.minTranslate()) * i + t.minTranslate())),
                  e.params.controller.inverse && (a = t.maxTranslate() - a),
                  t.updateProgress(a),
                  t.setTranslate(a, e),
                  t.updateActiveIndex(),
                  t.updateSlidesClasses();
              }
              if (Array.isArray(r))
                for (let t = 0; t < r.length; t += 1)
                  r[t] !== n && r[t] instanceof o && l(r[t]);
              else r instanceof o && n !== r && l(r);
            },
            setTransition: function (t, n) {
              const r = e.constructor,
                s = e.controller.control;
              let i;
              function a(n) {
                n.setTransition(t, e),
                  0 !== t &&
                    (n.transitionStart(),
                    n.params.autoHeight &&
                      p(() => {
                        n.updateAutoHeight();
                      }),
                    n.$wrapperEl.transitionEnd(() => {
                      s &&
                        (n.params.loop &&
                          "slide" === e.params.controller.by &&
                          n.loopFix(),
                        n.transitionEnd());
                    }));
              }
              if (Array.isArray(s))
                for (i = 0; i < s.length; i += 1)
                  s[i] !== n && s[i] instanceof r && a(s[i]);
              else s instanceof r && n !== s && a(s);
            },
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          a11y: {
            enabled: !0,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
            id: null,
          },
        }),
          (e.a11y = { clicked: !1 });
        let s = null;
        function i(t) {
          const e = s;
          0 !== e.length && (e.html(""), e.html(t));
        }
        function a(t) {
          t.attr("tabIndex", "0");
        }
        function o(t) {
          t.attr("tabIndex", "-1");
        }
        function l(t, e) {
          t.attr("role", e);
        }
        function u(t, e) {
          t.attr("aria-roledescription", e);
        }
        function p(t, e) {
          t.attr("aria-label", e);
        }
        function d(t) {
          t.attr("aria-disabled", !0);
        }
        function f(t) {
          t.attr("aria-disabled", !1);
        }
        function h(t) {
          if (13 !== t.keyCode && 32 !== t.keyCode) return;
          const n = e.params.a11y,
            r = c(t.target);
          e.navigation &&
            e.navigation.$nextEl &&
            r.is(e.navigation.$nextEl) &&
            ((e.isEnd && !e.params.loop) || e.slideNext(),
            e.isEnd ? i(n.lastSlideMessage) : i(n.nextSlideMessage)),
            e.navigation &&
              e.navigation.$prevEl &&
              r.is(e.navigation.$prevEl) &&
              ((e.isBeginning && !e.params.loop) || e.slidePrev(),
              e.isBeginning ? i(n.firstSlideMessage) : i(n.prevSlideMessage)),
            e.pagination &&
              r.is(X(e.params.pagination.bulletClass)) &&
              r[0].click();
        }
        function m() {
          return (
            e.pagination && e.pagination.bullets && e.pagination.bullets.length
          );
        }
        function g() {
          return m() && e.params.pagination.clickable;
        }
        const v = (t, e, n) => {
            a(t),
              "BUTTON" !== t[0].tagName && (l(t, "button"), t.on("keydown", h)),
              p(t, n),
              (function (t, e) {
                t.attr("aria-controls", e);
              })(t, e);
          },
          y = () => {
            e.a11y.clicked = !0;
          },
          b = () => {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                e.a11y.clicked = !1;
              });
            });
          },
          _ = (t) => {
            if (e.a11y.clicked) return;
            const n = t.target.closest(`.${e.params.slideClass}`);
            if (!n || !e.slides.includes(n)) return;
            const r = e.slides.indexOf(n) === e.activeIndex,
              s =
                e.params.watchSlidesProgress &&
                e.visibleSlides &&
                e.visibleSlides.includes(n);
            r ||
              s ||
              (e.isHorizontal() ? (e.el.scrollLeft = 0) : (e.el.scrollTop = 0),
              e.slideTo(e.slides.indexOf(n), 0));
          },
          w = () => {
            const t = e.params.a11y;
            t.itemRoleDescriptionMessage &&
              u(c(e.slides), t.itemRoleDescriptionMessage),
              t.slideRole && l(c(e.slides), t.slideRole);
            const n = e.params.loop
              ? e.slides.filter(
                  (t) => !t.classList.contains(e.params.slideDuplicateClass)
                ).length
              : e.slides.length;
            t.slideLabelMessage &&
              e.slides.each((r, s) => {
                const i = c(r),
                  a = e.params.loop
                    ? parseInt(i.attr("data-swiper-slide-index"), 10)
                    : s;
                p(
                  i,
                  t.slideLabelMessage
                    .replace(/\{\{index\}\}/, a + 1)
                    .replace(/\{\{slidesLength\}\}/, n)
                );
              });
          };
        r("beforeInit", () => {
          s = c(
            `<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`
          );
        }),
          r("afterInit", () => {
            e.params.a11y.enabled &&
              (() => {
                const t = e.params.a11y;
                e.$el.append(s);
                const n = e.$el;
                t.containerRoleDescriptionMessage &&
                  u(n, t.containerRoleDescriptionMessage),
                  t.containerMessage && p(n, t.containerMessage);
                const r = e.$wrapperEl,
                  i =
                    t.id ||
                    r.attr("id") ||
                    `swiper-wrapper-${
                      ((a = 16),
                      void 0 === a && (a = 16),
                      "x"
                        .repeat(a)
                        .replace(/x/g, () =>
                          Math.round(16 * Math.random()).toString(16)
                        ))
                    }`;
                var a;
                const o =
                  e.params.autoplay && e.params.autoplay.enabled
                    ? "off"
                    : "polite";
                var l;
                let c, d;
                (l = i),
                  r.attr("id", l),
                  (function (t, e) {
                    t.attr("aria-live", e);
                  })(r, o),
                  w(),
                  e.navigation &&
                    e.navigation.$nextEl &&
                    (c = e.navigation.$nextEl),
                  e.navigation &&
                    e.navigation.$prevEl &&
                    (d = e.navigation.$prevEl),
                  c && c.length && v(c, i, t.nextSlideMessage),
                  d && d.length && v(d, i, t.prevSlideMessage),
                  g() &&
                    e.pagination.$el.on(
                      "keydown",
                      X(e.params.pagination.bulletClass),
                      h
                    ),
                  e.$el.on("focus", _, !0),
                  e.$el.on("pointerdown", y, !0),
                  e.$el.on("pointerup", b, !0);
              })();
          }),
          r(
            "slidesLengthChange snapGridLengthChange slidesGridLengthChange",
            () => {
              e.params.a11y.enabled && w();
            }
          ),
          r("fromEdge toEdge afterInit lock unlock", () => {
            e.params.a11y.enabled &&
              (function () {
                if (e.params.loop || e.params.rewind || !e.navigation) return;
                const { $nextEl: t, $prevEl: n } = e.navigation;
                n &&
                  n.length > 0 &&
                  (e.isBeginning ? (d(n), o(n)) : (f(n), a(n))),
                  t && t.length > 0 && (e.isEnd ? (d(t), o(t)) : (f(t), a(t)));
              })();
          }),
          r("paginationUpdate", () => {
            e.params.a11y.enabled &&
              (function () {
                const t = e.params.a11y;
                m() &&
                  e.pagination.bullets.each((n) => {
                    const r = c(n);
                    e.params.pagination.clickable &&
                      (a(r),
                      e.params.pagination.renderBullet ||
                        (l(r, "button"),
                        p(
                          r,
                          t.paginationBulletMessage.replace(
                            /\{\{index\}\}/,
                            r.index() + 1
                          )
                        ))),
                      r.is(`.${e.params.pagination.bulletActiveClass}`)
                        ? r.attr("aria-current", "true")
                        : r.removeAttr("aria-current");
                  });
              })();
          }),
          r("destroy", () => {
            e.params.a11y.enabled &&
              (function () {
                let t, n;
                s && s.length > 0 && s.remove(),
                  e.navigation &&
                    e.navigation.$nextEl &&
                    (t = e.navigation.$nextEl),
                  e.navigation &&
                    e.navigation.$prevEl &&
                    (n = e.navigation.$prevEl),
                  t && t.off("keydown", h),
                  n && n.off("keydown", h),
                  g() &&
                    e.pagination.$el.off(
                      "keydown",
                      X(e.params.pagination.bulletClass),
                      h
                    ),
                  e.$el.off("focus", _, !0),
                  e.$el.off("pointerdown", y, !0),
                  e.$el.off("pointerup", b, !0);
              })();
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          history: {
            enabled: !1,
            root: "",
            replaceState: !1,
            key: "slides",
            keepQuery: !1,
          },
        });
        let s = !1,
          a = {};
        const o = (t) =>
            t
              .toString()
              .replace(/\s+/g, "-")
              .replace(/[^\w-]+/g, "")
              .replace(/--+/g, "-")
              .replace(/^-+/, "")
              .replace(/-+$/, ""),
          l = (t) => {
            const e = i();
            let n;
            n = t ? new URL(t) : e.location;
            const r = n.pathname
                .slice(1)
                .split("/")
                .filter((t) => "" !== t),
              s = r.length;
            return { key: r[s - 2], value: r[s - 1] };
          },
          c = (t, n) => {
            const r = i();
            if (!s || !e.params.history.enabled) return;
            let a;
            a = e.params.url ? new URL(e.params.url) : r.location;
            const l = e.slides.eq(n);
            let c = o(l.attr("data-history"));
            if (e.params.history.root.length > 0) {
              let n = e.params.history.root;
              "/" === n[n.length - 1] && (n = n.slice(0, n.length - 1)),
                (c = `${n}/${t}/${c}`);
            } else a.pathname.includes(t) || (c = `${t}/${c}`);
            e.params.history.keepQuery && (c += a.search);
            const u = r.history.state;
            (u && u.value === c) ||
              (e.params.history.replaceState
                ? r.history.replaceState({ value: c }, null, c)
                : r.history.pushState({ value: c }, null, c));
          },
          u = (t, n, r) => {
            if (n)
              for (let s = 0, i = e.slides.length; s < i; s += 1) {
                const i = e.slides.eq(s);
                if (
                  o(i.attr("data-history")) === n &&
                  !i.hasClass(e.params.slideDuplicateClass)
                ) {
                  const n = i.index();
                  e.slideTo(n, t, r);
                }
              }
            else e.slideTo(0, t, r);
          },
          p = () => {
            (a = l(e.params.url)), u(e.params.speed, a.value, !1);
          };
        r("init", () => {
          e.params.history.enabled &&
            (() => {
              const t = i();
              if (e.params.history) {
                if (!t.history || !t.history.pushState)
                  return (
                    (e.params.history.enabled = !1),
                    void (e.params.hashNavigation.enabled = !0)
                  );
                (s = !0),
                  (a = l(e.params.url)),
                  (a.key || a.value) &&
                    (u(0, a.value, e.params.runCallbacksOnInit),
                    e.params.history.replaceState ||
                      t.addEventListener("popstate", p));
              }
            })();
        }),
          r("destroy", () => {
            e.params.history.enabled &&
              (() => {
                const t = i();
                e.params.history.replaceState ||
                  t.removeEventListener("popstate", p);
              })();
          }),
          r("transitionEnd _freeModeNoMomentumRelease", () => {
            s && c(e.params.history.key, e.activeIndex);
          }),
          r("slideChange", () => {
            s && e.params.cssMode && c(e.params.history.key, e.activeIndex);
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, emit: s, on: a } = t,
          o = !1;
        const l = r(),
          u = i();
        n({
          hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 },
        });
        const p = () => {
            s("hashChange");
            const t = l.location.hash.replace("#", "");
            if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) {
              const n = e.$wrapperEl
                .children(`.${e.params.slideClass}[data-hash="${t}"]`)
                .index();
              if (void 0 === n) return;
              e.slideTo(n);
            }
          },
          d = () => {
            if (o && e.params.hashNavigation.enabled)
              if (
                e.params.hashNavigation.replaceState &&
                u.history &&
                u.history.replaceState
              )
                u.history.replaceState(
                  null,
                  null,
                  `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""
                ),
                  s("hashSet");
              else {
                const t = e.slides.eq(e.activeIndex),
                  n = t.attr("data-hash") || t.attr("data-history");
                (l.location.hash = n || ""), s("hashSet");
              }
          };
        a("init", () => {
          e.params.hashNavigation.enabled &&
            (() => {
              if (
                !e.params.hashNavigation.enabled ||
                (e.params.history && e.params.history.enabled)
              )
                return;
              o = !0;
              const t = l.location.hash.replace("#", "");
              if (t) {
                const n = 0;
                for (let r = 0, s = e.slides.length; r < s; r += 1) {
                  const s = e.slides.eq(r);
                  if (
                    (s.attr("data-hash") || s.attr("data-history")) === t &&
                    !s.hasClass(e.params.slideDuplicateClass)
                  ) {
                    const t = s.index();
                    e.slideTo(t, n, e.params.runCallbacksOnInit, !0);
                  }
                }
              }
              e.params.hashNavigation.watchState && c(u).on("hashchange", p);
            })();
        }),
          a("destroy", () => {
            e.params.hashNavigation.enabled &&
              e.params.hashNavigation.watchState &&
              c(u).off("hashchange", p);
          }),
          a("transitionEnd _freeModeNoMomentumRelease", () => {
            o && d();
          }),
          a("slideChange", () => {
            o && e.params.cssMode && d();
          });
      },
      function (t) {
        let e,
          { swiper: n, extendParams: s, on: i, emit: a } = t;
        function o() {
          if (!n.size)
            return (n.autoplay.running = !1), void (n.autoplay.paused = !1);
          const t = n.slides.eq(n.activeIndex);
          let r = n.params.autoplay.delay;
          t.attr("data-swiper-autoplay") &&
            (r = t.attr("data-swiper-autoplay") || n.params.autoplay.delay),
            clearTimeout(e),
            (e = p(() => {
              let t;
              n.params.autoplay.reverseDirection
                ? n.params.loop
                  ? (n.loopFix(),
                    (t = n.slidePrev(n.params.speed, !0, !0)),
                    a("autoplay"))
                  : n.isBeginning
                  ? n.params.autoplay.stopOnLastSlide
                    ? c()
                    : ((t = n.slideTo(
                        n.slides.length - 1,
                        n.params.speed,
                        !0,
                        !0
                      )),
                      a("autoplay"))
                  : ((t = n.slidePrev(n.params.speed, !0, !0)), a("autoplay"))
                : n.params.loop
                ? (n.loopFix(),
                  (t = n.slideNext(n.params.speed, !0, !0)),
                  a("autoplay"))
                : n.isEnd
                ? n.params.autoplay.stopOnLastSlide
                  ? c()
                  : ((t = n.slideTo(0, n.params.speed, !0, !0)), a("autoplay"))
                : ((t = n.slideNext(n.params.speed, !0, !0)), a("autoplay")),
                ((n.params.cssMode && n.autoplay.running) || !1 === t) && o();
            }, r));
        }
        function l() {
          return (
            void 0 === e &&
            !n.autoplay.running &&
            ((n.autoplay.running = !0), a("autoplayStart"), o(), !0)
          );
        }
        function c() {
          return (
            !!n.autoplay.running &&
            void 0 !== e &&
            (e && (clearTimeout(e), (e = void 0)),
            (n.autoplay.running = !1),
            a("autoplayStop"),
            !0)
          );
        }
        function u(t) {
          n.autoplay.running &&
            (n.autoplay.paused ||
              (e && clearTimeout(e),
              (n.autoplay.paused = !0),
              0 !== t && n.params.autoplay.waitForTransition
                ? ["transitionend", "webkitTransitionEnd"].forEach((t) => {
                    n.$wrapperEl[0].addEventListener(t, f);
                  })
                : ((n.autoplay.paused = !1), o())));
        }
        function d() {
          const t = r();
          "hidden" === t.visibilityState && n.autoplay.running && u(),
            "visible" === t.visibilityState &&
              n.autoplay.paused &&
              (o(), (n.autoplay.paused = !1));
        }
        function f(t) {
          n &&
            !n.destroyed &&
            n.$wrapperEl &&
            t.target === n.$wrapperEl[0] &&
            (["transitionend", "webkitTransitionEnd"].forEach((t) => {
              n.$wrapperEl[0].removeEventListener(t, f);
            }),
            (n.autoplay.paused = !1),
            n.autoplay.running ? o() : c());
        }
        function h() {
          n.params.autoplay.disableOnInteraction
            ? c()
            : (a("autoplayPause"), u()),
            ["transitionend", "webkitTransitionEnd"].forEach((t) => {
              n.$wrapperEl[0].removeEventListener(t, f);
            });
        }
        function m() {
          n.params.autoplay.disableOnInteraction ||
            ((n.autoplay.paused = !1), a("autoplayResume"), o());
        }
        (n.autoplay = { running: !1, paused: !1 }),
          s({
            autoplay: {
              enabled: !1,
              delay: 3e3,
              waitForTransition: !0,
              disableOnInteraction: !0,
              stopOnLastSlide: !1,
              reverseDirection: !1,
              pauseOnMouseEnter: !1,
            },
          }),
          i("init", () => {
            n.params.autoplay.enabled &&
              (l(),
              r().addEventListener("visibilitychange", d),
              n.params.autoplay.pauseOnMouseEnter &&
                (n.$el.on("mouseenter", h), n.$el.on("mouseleave", m)));
          }),
          i("beforeTransitionStart", (t, e, r) => {
            n.autoplay.running &&
              (r || !n.params.autoplay.disableOnInteraction
                ? n.autoplay.pause(e)
                : c());
          }),
          i("sliderFirstMove", () => {
            n.autoplay.running &&
              (n.params.autoplay.disableOnInteraction ? c() : u());
          }),
          i("touchEnd", () => {
            n.params.cssMode &&
              n.autoplay.paused &&
              !n.params.autoplay.disableOnInteraction &&
              o();
          }),
          i("destroy", () => {
            n.$el.off("mouseenter", h),
              n.$el.off("mouseleave", m),
              n.autoplay.running && c(),
              r().removeEventListener("visibilitychange", d);
          }),
          Object.assign(n.autoplay, { pause: u, run: o, start: l, stop: c });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          thumbs: {
            swiper: null,
            multipleActiveThumbs: !0,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs",
          },
        });
        let s = !1,
          i = !1;
        function a() {
          const t = e.thumbs.swiper;
          if (!t || t.destroyed) return;
          const n = t.clickedIndex,
            r = t.clickedSlide;
          if (r && c(r).hasClass(e.params.thumbs.slideThumbActiveClass)) return;
          if (null == n) return;
          let s;
          if (
            ((s = t.params.loop
              ? parseInt(c(t.clickedSlide).attr("data-swiper-slide-index"), 10)
              : n),
            e.params.loop)
          ) {
            let t = e.activeIndex;
            e.slides.eq(t).hasClass(e.params.slideDuplicateClass) &&
              (e.loopFix(),
              (e._clientLeft = e.$wrapperEl[0].clientLeft),
              (t = e.activeIndex));
            const n = e.slides
                .eq(t)
                .prevAll(`[data-swiper-slide-index="${s}"]`)
                .eq(0)
                .index(),
              r = e.slides
                .eq(t)
                .nextAll(`[data-swiper-slide-index="${s}"]`)
                .eq(0)
                .index();
            s = void 0 === n ? r : void 0 === r ? n : r - t < t - n ? r : n;
          }
          e.slideTo(s);
        }
        function o() {
          const { thumbs: t } = e.params;
          if (s) return !1;
          s = !0;
          const n = e.constructor;
          if (t.swiper instanceof n)
            (e.thumbs.swiper = t.swiper),
              Object.assign(e.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              }),
              Object.assign(e.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1,
              });
          else if (h(t.swiper)) {
            const r = Object.assign({}, t.swiper);
            Object.assign(r, {
              watchSlidesProgress: !0,
              slideToClickedSlide: !1,
            }),
              (e.thumbs.swiper = new n(r)),
              (i = !0);
          }
          return (
            e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass),
            e.thumbs.swiper.on("tap", a),
            !0
          );
        }
        function l(t) {
          const n = e.thumbs.swiper;
          if (!n || n.destroyed) return;
          const r =
            "auto" === n.params.slidesPerView
              ? n.slidesPerViewDynamic()
              : n.params.slidesPerView;
          let s = 1;
          const i = e.params.thumbs.slideThumbActiveClass;
          if (
            (e.params.slidesPerView > 1 &&
              !e.params.centeredSlides &&
              (s = e.params.slidesPerView),
            e.params.thumbs.multipleActiveThumbs || (s = 1),
            (s = Math.floor(s)),
            n.slides.removeClass(i),
            n.params.loop || (n.params.virtual && n.params.virtual.enabled))
          )
            for (let t = 0; t < s; t += 1)
              n.$wrapperEl
                .children(`[data-swiper-slide-index="${e.realIndex + t}"]`)
                .addClass(i);
          else
            for (let t = 0; t < s; t += 1)
              n.slides.eq(e.realIndex + t).addClass(i);
          const a = e.params.thumbs.autoScrollOffset,
            o = a && !n.params.loop;
          if (e.realIndex !== n.realIndex || o) {
            let s,
              i,
              l = n.activeIndex;
            if (n.params.loop) {
              n.slides.eq(l).hasClass(n.params.slideDuplicateClass) &&
                (n.loopFix(),
                (n._clientLeft = n.$wrapperEl[0].clientLeft),
                (l = n.activeIndex));
              const t = n.slides
                  .eq(l)
                  .prevAll(`[data-swiper-slide-index="${e.realIndex}"]`)
                  .eq(0)
                  .index(),
                r = n.slides
                  .eq(l)
                  .nextAll(`[data-swiper-slide-index="${e.realIndex}"]`)
                  .eq(0)
                  .index();
              (s =
                void 0 === t
                  ? r
                  : void 0 === r
                  ? t
                  : r - l == l - t
                  ? n.params.slidesPerGroup > 1
                    ? r
                    : l
                  : r - l < l - t
                  ? r
                  : t),
                (i = e.activeIndex > e.previousIndex ? "next" : "prev");
            } else
              (s = e.realIndex), (i = s > e.previousIndex ? "next" : "prev");
            o && (s += "next" === i ? a : -1 * a),
              n.visibleSlidesIndexes &&
                n.visibleSlidesIndexes.indexOf(s) < 0 &&
                (n.params.centeredSlides
                  ? (s =
                      s > l
                        ? s - Math.floor(r / 2) + 1
                        : s + Math.floor(r / 2) - 1)
                  : s > l && n.params.slidesPerGroup,
                n.slideTo(s, t ? 0 : void 0));
          }
        }
        (e.thumbs = { swiper: null }),
          r("beforeInit", () => {
            const { thumbs: t } = e.params;
            t && t.swiper && (o(), l(!0));
          }),
          r("slideChange update resize observerUpdate", () => {
            l();
          }),
          r("setTransition", (t, n) => {
            const r = e.thumbs.swiper;
            r && !r.destroyed && r.setTransition(n);
          }),
          r("beforeDestroy", () => {
            const t = e.thumbs.swiper;
            t && !t.destroyed && i && t.destroy();
          }),
          Object.assign(e.thumbs, { init: o, update: l });
      },
      function (t) {
        let { swiper: e, extendParams: n, emit: r, once: s } = t;
        n({
          freeMode: {
            enabled: !1,
            momentum: !0,
            momentumRatio: 1,
            momentumBounce: !0,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: !1,
            minimumVelocity: 0.02,
          },
        }),
          Object.assign(e, {
            freeMode: {
              onTouchStart: function () {
                const t = e.getTranslate();
                e.setTranslate(t),
                  e.setTransition(0),
                  (e.touchEventsData.velocities.length = 0),
                  e.freeMode.onTouchEnd({
                    currentPos: e.rtl ? e.translate : -e.translate,
                  });
              },
              onTouchMove: function () {
                const { touchEventsData: t, touches: n } = e;
                0 === t.velocities.length &&
                  t.velocities.push({
                    position: n[e.isHorizontal() ? "startX" : "startY"],
                    time: t.touchStartTime,
                  }),
                  t.velocities.push({
                    position: n[e.isHorizontal() ? "currentX" : "currentY"],
                    time: d(),
                  });
              },
              onTouchEnd: function (t) {
                let { currentPos: n } = t;
                const {
                    params: i,
                    $wrapperEl: a,
                    rtlTranslate: o,
                    snapGrid: l,
                    touchEventsData: c,
                  } = e,
                  u = d() - c.touchStartTime;
                if (n < -e.minTranslate()) e.slideTo(e.activeIndex);
                else if (n > -e.maxTranslate())
                  e.slides.length < l.length
                    ? e.slideTo(l.length - 1)
                    : e.slideTo(e.slides.length - 1);
                else {
                  if (i.freeMode.momentum) {
                    if (c.velocities.length > 1) {
                      const t = c.velocities.pop(),
                        n = c.velocities.pop(),
                        r = t.position - n.position,
                        s = t.time - n.time;
                      (e.velocity = r / s),
                        (e.velocity /= 2),
                        Math.abs(e.velocity) < i.freeMode.minimumVelocity &&
                          (e.velocity = 0),
                        (s > 150 || d() - t.time > 300) && (e.velocity = 0);
                    } else e.velocity = 0;
                    (e.velocity *= i.freeMode.momentumVelocityRatio),
                      (c.velocities.length = 0);
                    let t = 1e3 * i.freeMode.momentumRatio;
                    const n = e.velocity * t;
                    let u = e.translate + n;
                    o && (u = -u);
                    let p,
                      f = !1;
                    const h =
                      20 *
                      Math.abs(e.velocity) *
                      i.freeMode.momentumBounceRatio;
                    let m;
                    if (u < e.maxTranslate())
                      i.freeMode.momentumBounce
                        ? (u + e.maxTranslate() < -h &&
                            (u = e.maxTranslate() - h),
                          (p = e.maxTranslate()),
                          (f = !0),
                          (c.allowMomentumBounce = !0))
                        : (u = e.maxTranslate()),
                        i.loop && i.centeredSlides && (m = !0);
                    else if (u > e.minTranslate())
                      i.freeMode.momentumBounce
                        ? (u - e.minTranslate() > h &&
                            (u = e.minTranslate() + h),
                          (p = e.minTranslate()),
                          (f = !0),
                          (c.allowMomentumBounce = !0))
                        : (u = e.minTranslate()),
                        i.loop && i.centeredSlides && (m = !0);
                    else if (i.freeMode.sticky) {
                      let t;
                      for (let e = 0; e < l.length; e += 1)
                        if (l[e] > -u) {
                          t = e;
                          break;
                        }
                      (u =
                        Math.abs(l[t] - u) < Math.abs(l[t - 1] - u) ||
                        "next" === e.swipeDirection
                          ? l[t]
                          : l[t - 1]),
                        (u = -u);
                    }
                    if (
                      (m &&
                        s("transitionEnd", () => {
                          e.loopFix();
                        }),
                      0 !== e.velocity)
                    ) {
                      if (
                        ((t = o
                          ? Math.abs((-u - e.translate) / e.velocity)
                          : Math.abs((u - e.translate) / e.velocity)),
                        i.freeMode.sticky)
                      ) {
                        const n = Math.abs((o ? -u : u) - e.translate),
                          r = e.slidesSizesGrid[e.activeIndex];
                        t =
                          n < r
                            ? i.speed
                            : n < 2 * r
                            ? 1.5 * i.speed
                            : 2.5 * i.speed;
                      }
                    } else if (i.freeMode.sticky)
                      return void e.slideToClosest();
                    i.freeMode.momentumBounce && f
                      ? (e.updateProgress(p),
                        e.setTransition(t),
                        e.setTranslate(u),
                        e.transitionStart(!0, e.swipeDirection),
                        (e.animating = !0),
                        a.transitionEnd(() => {
                          e &&
                            !e.destroyed &&
                            c.allowMomentumBounce &&
                            (r("momentumBounce"),
                            e.setTransition(i.speed),
                            setTimeout(() => {
                              e.setTranslate(p),
                                a.transitionEnd(() => {
                                  e && !e.destroyed && e.transitionEnd();
                                });
                            }, 0));
                        }))
                      : e.velocity
                      ? (r("_freeModeNoMomentumRelease"),
                        e.updateProgress(u),
                        e.setTransition(t),
                        e.setTranslate(u),
                        e.transitionStart(!0, e.swipeDirection),
                        e.animating ||
                          ((e.animating = !0),
                          a.transitionEnd(() => {
                            e && !e.destroyed && e.transitionEnd();
                          })))
                      : e.updateProgress(u),
                      e.updateActiveIndex(),
                      e.updateSlidesClasses();
                  } else {
                    if (i.freeMode.sticky) return void e.slideToClosest();
                    i.freeMode && r("_freeModeNoMomentumRelease");
                  }
                  (!i.freeMode.momentum || u >= i.longSwipesMs) &&
                    (e.updateProgress(),
                    e.updateActiveIndex(),
                    e.updateSlidesClasses());
                }
              },
            },
          });
      },
      function (t) {
        let e,
          n,
          r,
          { swiper: s, extendParams: i } = t;
        i({ grid: { rows: 1, fill: "column" } }),
          (s.grid = {
            initSlides: (t) => {
              const { slidesPerView: i } = s.params,
                { rows: a, fill: o } = s.params.grid;
              (n = e / a),
                (r = Math.floor(t / a)),
                (e = Math.floor(t / a) === t / a ? t : Math.ceil(t / a) * a),
                "auto" !== i && "row" === o && (e = Math.max(e, i * a));
            },
            updateSlide: (t, i, a, o) => {
              const { slidesPerGroup: l, spaceBetween: c } = s.params,
                { rows: u, fill: p } = s.params.grid;
              let d, f, h;
              if ("row" === p && l > 1) {
                const n = Math.floor(t / (l * u)),
                  r = t - u * l * n,
                  s = 0 === n ? l : Math.min(Math.ceil((a - n * u * l) / u), l);
                (h = Math.floor(r / s)),
                  (f = r - h * s + n * l),
                  (d = f + (h * e) / u),
                  i.css({ "-webkit-order": d, order: d });
              } else
                "column" === p
                  ? ((f = Math.floor(t / u)),
                    (h = t - f * u),
                    (f > r || (f === r && h === u - 1)) &&
                      ((h += 1), h >= u && ((h = 0), (f += 1))))
                  : ((h = Math.floor(t / n)), (f = t - h * n));
              i.css(o("margin-top"), 0 !== h ? c && `${c}px` : "");
            },
            updateWrapperSize: (t, n, r) => {
              const {
                  spaceBetween: i,
                  centeredSlides: a,
                  roundLengths: o,
                } = s.params,
                { rows: l } = s.params.grid;
              if (
                ((s.virtualSize = (t + i) * e),
                (s.virtualSize = Math.ceil(s.virtualSize / l) - i),
                s.$wrapperEl.css({ [r("width")]: `${s.virtualSize + i}px` }),
                a)
              ) {
                n.splice(0, n.length);
                const t = [];
                for (let e = 0; e < n.length; e += 1) {
                  let r = n[e];
                  o && (r = Math.floor(r)),
                    n[e] < s.virtualSize + n[0] && t.push(r);
                }
                n.push(...t);
              }
            },
          });
      },
      function (t) {
        let { swiper: e } = t;
        Object.assign(e, {
          appendSlide: K.bind(e),
          prependSlide: Q.bind(e),
          addSlide: J.bind(e),
          removeSlide: Z.bind(e),
          removeAllSlides: tt.bind(e),
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({ fadeEffect: { crossFade: !1, transformEl: null } }),
          et({
            effect: "fade",
            swiper: e,
            on: r,
            setTranslate: () => {
              const { slides: t } = e,
                n = e.params.fadeEffect;
              for (let r = 0; r < t.length; r += 1) {
                const t = e.slides.eq(r);
                let s = -t[0].swiperSlideOffset;
                e.params.virtualTranslate || (s -= e.translate);
                let i = 0;
                e.isHorizontal() || ((i = s), (s = 0));
                const a = e.params.fadeEffect.crossFade
                  ? Math.max(1 - Math.abs(t[0].progress), 0)
                  : 1 + Math.min(Math.max(t[0].progress, -1), 0);
                nt(n, t)
                  .css({ opacity: a })
                  .transform(`translate3d(${s}px, ${i}px, 0px)`);
              }
            },
            setTransition: (t) => {
              const { transformEl: n } = e.params.fadeEffect;
              (n ? e.slides.find(n) : e.slides).transition(t),
                rt({ swiper: e, duration: t, transformEl: n, allSlides: !0 });
            },
            overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: !0,
              spaceBetween: 0,
              virtualTranslate: !e.params.cssMode,
            }),
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          cubeEffect: {
            slideShadows: !0,
            shadow: !0,
            shadowOffset: 20,
            shadowScale: 0.94,
          },
        });
        const s = (t, e, n) => {
          let r = n
              ? t.find(".swiper-slide-shadow-left")
              : t.find(".swiper-slide-shadow-top"),
            s = n
              ? t.find(".swiper-slide-shadow-right")
              : t.find(".swiper-slide-shadow-bottom");
          0 === r.length &&
            ((r = c(
              `<div class="swiper-slide-shadow-${n ? "left" : "top"}"></div>`
            )),
            t.append(r)),
            0 === s.length &&
              ((s = c(
                `<div class="swiper-slide-shadow-${
                  n ? "right" : "bottom"
                }"></div>`
              )),
              t.append(s)),
            r.length && (r[0].style.opacity = Math.max(-e, 0)),
            s.length && (s[0].style.opacity = Math.max(e, 0));
        };
        et({
          effect: "cube",
          swiper: e,
          on: r,
          setTranslate: () => {
            const {
                $el: t,
                $wrapperEl: n,
                slides: r,
                width: i,
                height: a,
                rtlTranslate: o,
                size: l,
                browser: u,
              } = e,
              p = e.params.cubeEffect,
              d = e.isHorizontal(),
              f = e.virtual && e.params.virtual.enabled;
            let h,
              m = 0;
            p.shadow &&
              (d
                ? ((h = n.find(".swiper-cube-shadow")),
                  0 === h.length &&
                    ((h = c('<div class="swiper-cube-shadow"></div>')),
                    n.append(h)),
                  h.css({ height: `${i}px` }))
                : ((h = t.find(".swiper-cube-shadow")),
                  0 === h.length &&
                    ((h = c('<div class="swiper-cube-shadow"></div>')),
                    t.append(h))));
            for (let t = 0; t < r.length; t += 1) {
              const e = r.eq(t);
              let n = t;
              f && (n = parseInt(e.attr("data-swiper-slide-index"), 10));
              let i = 90 * n,
                a = Math.floor(i / 360);
              o && ((i = -i), (a = Math.floor(-i / 360)));
              const c = Math.max(Math.min(e[0].progress, 1), -1);
              let u = 0,
                h = 0,
                g = 0;
              n % 4 == 0
                ? ((u = 4 * -a * l), (g = 0))
                : (n - 1) % 4 == 0
                ? ((u = 0), (g = 4 * -a * l))
                : (n - 2) % 4 == 0
                ? ((u = l + 4 * a * l), (g = l))
                : (n - 3) % 4 == 0 && ((u = -l), (g = 3 * l + 4 * l * a)),
                o && (u = -u),
                d || ((h = u), (u = 0));
              const v = `rotateX(${d ? 0 : -i}deg) rotateY(${
                d ? i : 0
              }deg) translate3d(${u}px, ${h}px, ${g}px)`;
              c <= 1 &&
                c > -1 &&
                ((m = 90 * n + 90 * c), o && (m = 90 * -n - 90 * c)),
                e.transform(v),
                p.slideShadows && s(e, c, d);
            }
            if (
              (n.css({
                "-webkit-transform-origin": `50% 50% -${l / 2}px`,
                "transform-origin": `50% 50% -${l / 2}px`,
              }),
              p.shadow)
            )
              if (d)
                h.transform(
                  `translate3d(0px, ${i / 2 + p.shadowOffset}px, ${
                    -i / 2
                  }px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`
                );
              else {
                const t = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
                  e =
                    1.5 -
                    (Math.sin((2 * t * Math.PI) / 360) / 2 +
                      Math.cos((2 * t * Math.PI) / 360) / 2),
                  n = p.shadowScale,
                  r = p.shadowScale / e,
                  s = p.shadowOffset;
                h.transform(
                  `scale3d(${n}, 1, ${r}) translate3d(0px, ${a / 2 + s}px, ${
                    -a / 2 / r
                  }px) rotateX(-90deg)`
                );
              }
            const g = u.isSafari || u.isWebView ? -l / 2 : 0;
            n.transform(
              `translate3d(0px,0,${g}px) rotateX(${
                e.isHorizontal() ? 0 : m
              }deg) rotateY(${e.isHorizontal() ? -m : 0}deg)`
            ),
              n[0].style.setProperty("--swiper-cube-translate-z", `${g}px`);
          },
          setTransition: (t) => {
            const { $el: n, slides: r } = e;
            r
              .transition(t)
              .find(
                ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
              )
              .transition(t),
              e.params.cubeEffect.shadow &&
                !e.isHorizontal() &&
                n.find(".swiper-cube-shadow").transition(t);
          },
          recreateShadows: () => {
            const t = e.isHorizontal();
            e.slides.each((e) => {
              const n = Math.max(Math.min(e.progress, 1), -1);
              s(c(e), n, t);
            });
          },
          getEffectParams: () => e.params.cubeEffect,
          perspective: () => !0,
          overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            resistanceRatio: 0,
            spaceBetween: 0,
            centeredSlides: !1,
            virtualTranslate: !0,
          }),
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          flipEffect: {
            slideShadows: !0,
            limitRotation: !0,
            transformEl: null,
          },
        });
        const s = (t, n, r) => {
          let s = e.isHorizontal()
              ? t.find(".swiper-slide-shadow-left")
              : t.find(".swiper-slide-shadow-top"),
            i = e.isHorizontal()
              ? t.find(".swiper-slide-shadow-right")
              : t.find(".swiper-slide-shadow-bottom");
          0 === s.length && (s = st(r, t, e.isHorizontal() ? "left" : "top")),
            0 === i.length &&
              (i = st(r, t, e.isHorizontal() ? "right" : "bottom")),
            s.length && (s[0].style.opacity = Math.max(-n, 0)),
            i.length && (i[0].style.opacity = Math.max(n, 0));
        };
        et({
          effect: "flip",
          swiper: e,
          on: r,
          setTranslate: () => {
            const { slides: t, rtlTranslate: n } = e,
              r = e.params.flipEffect;
            for (let i = 0; i < t.length; i += 1) {
              const a = t.eq(i);
              let o = a[0].progress;
              e.params.flipEffect.limitRotation &&
                (o = Math.max(Math.min(a[0].progress, 1), -1));
              const l = a[0].swiperSlideOffset;
              let c = -180 * o,
                u = 0,
                p = e.params.cssMode ? -l - e.translate : -l,
                d = 0;
              e.isHorizontal()
                ? n && (c = -c)
                : ((d = p), (p = 0), (u = -c), (c = 0)),
                (a[0].style.zIndex = -Math.abs(Math.round(o)) + t.length),
                r.slideShadows && s(a, o, r);
              const f = `translate3d(${p}px, ${d}px, 0px) rotateX(${u}deg) rotateY(${c}deg)`;
              nt(r, a).transform(f);
            }
          },
          setTransition: (t) => {
            const { transformEl: n } = e.params.flipEffect;
            (n ? e.slides.find(n) : e.slides)
              .transition(t)
              .find(
                ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
              )
              .transition(t),
              rt({ swiper: e, duration: t, transformEl: n });
          },
          recreateShadows: () => {
            const t = e.params.flipEffect;
            e.slides.each((n) => {
              const r = c(n);
              let i = r[0].progress;
              e.params.flipEffect.limitRotation &&
                (i = Math.max(Math.min(n.progress, 1), -1)),
                s(r, i, t);
            });
          },
          getEffectParams: () => e.params.flipEffect,
          perspective: () => !0,
          overwriteParams: () => ({
            slidesPerView: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: !0,
            spaceBetween: 0,
            virtualTranslate: !e.params.cssMode,
          }),
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: !0,
            transformEl: null,
          },
        }),
          et({
            effect: "coverflow",
            swiper: e,
            on: r,
            setTranslate: () => {
              const { width: t, height: n, slides: r, slidesSizesGrid: s } = e,
                i = e.params.coverflowEffect,
                a = e.isHorizontal(),
                o = e.translate,
                l = a ? t / 2 - o : n / 2 - o,
                c = a ? i.rotate : -i.rotate,
                u = i.depth;
              for (let t = 0, e = r.length; t < e; t += 1) {
                const e = r.eq(t),
                  n = s[t],
                  o = (l - e[0].swiperSlideOffset - n / 2) / n,
                  p =
                    "function" == typeof i.modifier
                      ? i.modifier(o)
                      : o * i.modifier;
                let d = a ? c * p : 0,
                  f = a ? 0 : c * p,
                  h = -u * Math.abs(p),
                  m = i.stretch;
                "string" == typeof m &&
                  -1 !== m.indexOf("%") &&
                  (m = (parseFloat(i.stretch) / 100) * n);
                let g = a ? 0 : m * p,
                  v = a ? m * p : 0,
                  y = 1 - (1 - i.scale) * Math.abs(p);
                Math.abs(v) < 0.001 && (v = 0),
                  Math.abs(g) < 0.001 && (g = 0),
                  Math.abs(h) < 0.001 && (h = 0),
                  Math.abs(d) < 0.001 && (d = 0),
                  Math.abs(f) < 0.001 && (f = 0),
                  Math.abs(y) < 0.001 && (y = 0);
                const b = `translate3d(${v}px,${g}px,${h}px)  rotateX(${f}deg) rotateY(${d}deg) scale(${y})`;
                if (
                  (nt(i, e).transform(b),
                  (e[0].style.zIndex = 1 - Math.abs(Math.round(p))),
                  i.slideShadows)
                ) {
                  let t = a
                      ? e.find(".swiper-slide-shadow-left")
                      : e.find(".swiper-slide-shadow-top"),
                    n = a
                      ? e.find(".swiper-slide-shadow-right")
                      : e.find(".swiper-slide-shadow-bottom");
                  0 === t.length && (t = st(i, e, a ? "left" : "top")),
                    0 === n.length && (n = st(i, e, a ? "right" : "bottom")),
                    t.length && (t[0].style.opacity = p > 0 ? p : 0),
                    n.length && (n[0].style.opacity = -p > 0 ? -p : 0);
                }
              }
            },
            setTransition: (t) => {
              const { transformEl: n } = e.params.coverflowEffect;
              (n ? e.slides.find(n) : e.slides)
                .transition(t)
                .find(
                  ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                )
                .transition(t);
            },
            perspective: () => !0,
            overwriteParams: () => ({ watchSlidesProgress: !0 }),
          });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          creativeEffect: {
            transformEl: null,
            limitProgress: 1,
            shadowPerProgress: !1,
            progressMultiplier: 1,
            perspective: !0,
            prev: {
              translate: [0, 0, 0],
              rotate: [0, 0, 0],
              opacity: 1,
              scale: 1,
            },
            next: {
              translate: [0, 0, 0],
              rotate: [0, 0, 0],
              opacity: 1,
              scale: 1,
            },
          },
        });
        const s = (t) => ("string" == typeof t ? t : `${t}px`);
        et({
          effect: "creative",
          swiper: e,
          on: r,
          setTranslate: () => {
            const { slides: t, $wrapperEl: n, slidesSizesGrid: r } = e,
              i = e.params.creativeEffect,
              { progressMultiplier: a } = i,
              o = e.params.centeredSlides;
            if (o) {
              const t = r[0] / 2 - e.params.slidesOffsetBefore || 0;
              n.transform(`translateX(calc(50% - ${t}px))`);
            }
            for (let n = 0; n < t.length; n += 1) {
              const r = t.eq(n),
                l = r[0].progress,
                c = Math.min(
                  Math.max(r[0].progress, -i.limitProgress),
                  i.limitProgress
                );
              let u = c;
              o ||
                (u = Math.min(
                  Math.max(r[0].originalProgress, -i.limitProgress),
                  i.limitProgress
                ));
              const p = r[0].swiperSlideOffset,
                d = [e.params.cssMode ? -p - e.translate : -p, 0, 0],
                f = [0, 0, 0];
              let h = !1;
              e.isHorizontal() || ((d[1] = d[0]), (d[0] = 0));
              let m = {
                translate: [0, 0, 0],
                rotate: [0, 0, 0],
                scale: 1,
                opacity: 1,
              };
              c < 0
                ? ((m = i.next), (h = !0))
                : c > 0 && ((m = i.prev), (h = !0)),
                d.forEach((t, e) => {
                  d[e] = `calc(${t}px + (${s(m.translate[e])} * ${Math.abs(
                    c * a
                  )}))`;
                }),
                f.forEach((t, e) => {
                  f[e] = m.rotate[e] * Math.abs(c * a);
                }),
                (r[0].style.zIndex = -Math.abs(Math.round(l)) + t.length);
              const g = d.join(", "),
                v = `rotateX(${f[0]}deg) rotateY(${f[1]}deg) rotateZ(${f[2]}deg)`,
                y =
                  u < 0
                    ? `scale(${1 + (1 - m.scale) * u * a})`
                    : `scale(${1 - (1 - m.scale) * u * a})`,
                b =
                  u < 0
                    ? 1 + (1 - m.opacity) * u * a
                    : 1 - (1 - m.opacity) * u * a,
                _ = `translate3d(${g}) ${v} ${y}`;
              if ((h && m.shadow) || !h) {
                let t = r.children(".swiper-slide-shadow");
                if ((0 === t.length && m.shadow && (t = st(i, r)), t.length)) {
                  const e = i.shadowPerProgress ? c * (1 / i.limitProgress) : c;
                  t[0].style.opacity = Math.min(Math.max(Math.abs(e), 0), 1);
                }
              }
              const w = nt(i, r);
              w.transform(_).css({ opacity: b }),
                m.origin && w.css("transform-origin", m.origin);
            }
          },
          setTransition: (t) => {
            const { transformEl: n } = e.params.creativeEffect;
            (n ? e.slides.find(n) : e.slides)
              .transition(t)
              .find(".swiper-slide-shadow")
              .transition(t),
              rt({ swiper: e, duration: t, transformEl: n, allSlides: !0 });
          },
          perspective: () => e.params.creativeEffect.perspective,
          overwriteParams: () => ({
            watchSlidesProgress: !0,
            virtualTranslate: !e.params.cssMode,
          }),
        });
      },
      function (t) {
        let { swiper: e, extendParams: n, on: r } = t;
        n({
          cardsEffect: {
            slideShadows: !0,
            transformEl: null,
            rotate: !0,
            perSlideRotate: 2,
            perSlideOffset: 8,
          },
        }),
          et({
            effect: "cards",
            swiper: e,
            on: r,
            setTranslate: () => {
              const { slides: t, activeIndex: n } = e,
                r = e.params.cardsEffect,
                { startTranslate: s, isTouched: i } = e.touchEventsData,
                a = e.translate;
              for (let o = 0; o < t.length; o += 1) {
                const l = t.eq(o),
                  c = l[0].progress,
                  u = Math.min(Math.max(c, -4), 4);
                let p = l[0].swiperSlideOffset;
                e.params.centeredSlides &&
                  !e.params.cssMode &&
                  e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`),
                  e.params.centeredSlides &&
                    e.params.cssMode &&
                    (p -= t[0].swiperSlideOffset);
                let d = e.params.cssMode ? -p - e.translate : -p,
                  f = 0;
                const h = -100 * Math.abs(u);
                let m = 1,
                  g = -r.perSlideRotate * u,
                  v = r.perSlideOffset - 0.75 * Math.abs(u);
                const y =
                    e.virtual && e.params.virtual.enabled
                      ? e.virtual.from + o
                      : o,
                  b =
                    (y === n || y === n - 1) &&
                    u > 0 &&
                    u < 1 &&
                    (i || e.params.cssMode) &&
                    a < s,
                  _ =
                    (y === n || y === n + 1) &&
                    u < 0 &&
                    u > -1 &&
                    (i || e.params.cssMode) &&
                    a > s;
                if (b || _) {
                  const t = (1 - Math.abs((Math.abs(u) - 0.5) / 0.5)) ** 0.5;
                  (g += -28 * u * t),
                    (m += -0.5 * t),
                    (v += 96 * t),
                    (f = -25 * t * Math.abs(u) + "%");
                }
                if (
                  ((d =
                    u < 0
                      ? `calc(${d}px + (${v * Math.abs(u)}%))`
                      : u > 0
                      ? `calc(${d}px + (-${v * Math.abs(u)}%))`
                      : `${d}px`),
                  !e.isHorizontal())
                ) {
                  const t = f;
                  (f = d), (d = t);
                }
                const w =
                    u < 0 ? "" + (1 + (1 - m) * u) : "" + (1 - (1 - m) * u),
                  S = `\n        translate3d(${d}, ${f}, ${h}px)\n        rotateZ(${
                    r.rotate ? g : 0
                  }deg)\n        scale(${w})\n      `;
                if (r.slideShadows) {
                  let t = l.find(".swiper-slide-shadow");
                  0 === t.length && (t = st(r, l)),
                    t.length &&
                      (t[0].style.opacity = Math.min(
                        Math.max((Math.abs(u) - 0.5) / 0.5, 0),
                        1
                      ));
                }
                (l[0].style.zIndex = -Math.abs(Math.round(c)) + t.length),
                  nt(r, l).transform(S);
              }
            },
            setTransition: (t) => {
              const { transformEl: n } = e.params.cardsEffect;
              (n ? e.slides.find(n) : e.slides)
                .transition(t)
                .find(".swiper-slide-shadow")
                .transition(t),
                rt({ swiper: e, duration: t, transformEl: n });
            },
            perspective: () => !0,
            overwriteParams: () => ({
              watchSlidesProgress: !0,
              virtualTranslate: !e.params.cssMode,
            }),
          });
      },
    ];
    return G.use(it), G;
  }),
  function (t, e) {
    "object" == typeof exports && "object" == typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define([], e)
      : "object" == typeof exports
      ? (exports.HSStickyBlock = e())
      : (t.HSStickyBlock = e());
  },
  (function (t, e) {
    if ("object" == typeof exports && "object" == typeof module)
      module.exports = e();
    else if ("function" == typeof define && define.amd) define([], e);
    else {
      var n = e();
      for (var r in n) ("object" == typeof exports ? exports : t)[r] = n[r];
    }
  })(window, function () {
    return (function (t) {
      var e = {};
      function n(r) {
        if (e[r]) return e[r].exports;
        var s = (e[r] = { i: r, l: !1, exports: {} });
        return t[r].call(s.exports, s, s.exports, n), (s.l = !0), s.exports;
      }
      return (
        (n.m = t),
        (n.c = e),
        (n.d = function (t, e, r) {
          n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r });
        }),
        (n.r = function (t) {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(t, "__esModule", { value: !0 });
        }),
        (n.t = function (t, e) {
          if ((1 & e && (t = n(t)), 8 & e)) return t;
          if (4 & e && "object" == typeof t && t && t.__esModule) return t;
          var r = Object.create(null);
          if (
            (n.r(r),
            Object.defineProperty(r, "default", { enumerable: !0, value: t }),
            2 & e && "string" != typeof t)
          )
            for (var s in t)
              n.d(
                r,
                s,
                function (e) {
                  return t[e];
                }.bind(null, s)
              );
          return r;
        }),
        (n.n = function (t) {
          var e =
            t && t.__esModule
              ? function () {
                  return t.default;
                }
              : function () {
                  return t;
                };
          return n.d(e, "a", e), e;
        }),
        (n.o = function (t, e) {
          return Object.prototype.hasOwnProperty.call(t, e);
        }),
        (n.p = ""),
        n((n.s = 0))
      );
    })([
      function (t, e, n) {
        "use strict";
        n.r(e);
        var r,
          s = "fslightbox-",
          i = "".concat(s, "styles"),
          a = "".concat(s, "cursor-grabbing"),
          o = "".concat(s, "full-dimension"),
          l = "".concat(s, "flex-centered"),
          c = "".concat(s, "open"),
          u = "".concat(s, "transform-transition"),
          p = "".concat(s, "absoluted"),
          d = "".concat(s, "slide-btn"),
          f = "".concat(d, "-container"),
          h = "".concat(s, "fade-in"),
          m = "".concat(s, "fade-out"),
          g = h + "-strong",
          v = m + "-strong",
          y = "".concat(s, "opacity-"),
          b = "".concat(y, "1"),
          _ = "".concat(s, "source");

        function S(t) {
          var e,
            n = t.props,
            r = 0,
            s = {};
          (this.getSourceTypeFromLocalStorageByUrl = function (t) {
            return e[t] ? e[t] : i(t);
          }),
            (this.handleReceivedSourceTypeForUrl = function (t, n) {
              !1 === s[n] &&
                (r--,
                "invalid" !== t ? (s[n] = t) : delete s[n],
                0 === r &&
                  ((function (t, e) {
                    for (var n in e) t[n] = e[n];
                  })(e, s),
                  localStorage.setItem("fslightbox-types", JSON.stringify(e))));
            });
          var i = function (t) {
            r++, (s[t] = !1);
          };
          n.disableLocalStorage
            ? ((this.getSourceTypeFromLocalStorageByUrl = function () {}),
              (this.handleReceivedSourceTypeForUrl = function () {}))
            : (e = JSON.parse(localStorage.getItem("fslightbox-types"))) ||
              ((e = {}), (this.getSourceTypeFromLocalStorageByUrl = i));
        }
        function C(t, e, n, r) {
          var s = t.data,
            i = t.elements.sources,
            a = n / r,
            o = 0;
          this.adjustSize = function () {
            if ((o = s.maxSourceWidth / a) < s.maxSourceHeight)
              return n < s.maxSourceWidth && (o = r), l();
            (o = r > s.maxSourceHeight ? s.maxSourceHeight : r), l();
          };
          var l = function () {
            (i[e].style.width = o * a + "px"), (i[e].style.height = o + "px");
          };
        }
        function x(t, e) {
          var n = this,
            r = t.collections.sourceSizers,
            s = t.elements,
            i = s.sourceAnimationWrappers,
            a = s.sourceMainWrappers,
            o = s.sources,
            l = t.resolve;
          function c(t, n) {
            (r[e] = l(C, [e, t, n])), r[e].adjustSize();
          }
          this.runActions = function (t, r) {
            o[e].classList.add(b),
              i[e].classList.add(g),
              a[e].removeChild(a[e].firstChild),
              c(t, r),
              (n.runActions = c);
          };
        }
        function k(t, e) {
          var n,
            r = this,
            s = t.elements.sources,
            i = t.props,
            a = (0, t.resolve)(x, [e]);
          (this.handleImageLoad = function (t) {
            var e = t.target,
              n = e.naturalWidth,
              r = e.naturalHeight;
            a.runActions(n, r);
          }),
            (this.handleVideoLoad = function (t) {
              var e = t.target,
                r = e.videoWidth,
                s = e.videoHeight;
              (n = !0), a.runActions(r, s);
            }),
            (this.handleNotMetaDatedVideoLoad = function () {
              n || r.handleYoutubeLoad();
            }),
            (this.handleYoutubeLoad = function () {
              var t = 1920,
                e = 1080;
              i.maxYoutubeDimensions &&
                ((t = i.maxYoutubeDimensions.width),
                (e = i.maxYoutubeDimensions.height)),
                a.runActions(t, e);
            }),
            (this.handleCustomLoad = function () {
              setTimeout(function () {
                var t = s[e];
                a.runActions(t.offsetWidth, t.offsetHeight);
              });
            });
        }
        function E(t, e, n) {
          var r = t.elements.sources,
            s = t.props.customClasses,
            i = s[e] ? s[e] : "";
          r[e].className = n + " " + i;
        }
        function T(t, e) {
          var n = t.elements.sources,
            r = t.props.customAttributes;
          for (var s in r[e]) n[e].setAttribute(s, r[e][s]);
        }
        function P(t, e) {
          var n = t.collections.sourceLoadHandlers,
            r = t.elements,
            s = r.sources,
            i = r.sourceAnimationWrappers,
            a = t.props.sources;
          (s[e] = document.createElement("img")),
            E(t, e, _),
            (s[e].src = a[e]),
            (s[e].onload = n[e].handleImageLoad),
            T(t, e),
            i[e].appendChild(s[e]);
        }
        function M(t, e) {
          var n = t.collections.sourceLoadHandlers,
            r = t.elements,
            s = r.sources,
            i = r.sourceAnimationWrappers,
            a = t.props,
            o = a.sources,
            l = a.videosPosters;
          (s[e] = document.createElement("video")),
            E(t, e, _),
            (s[e].src = o[e]),
            (s[e].onloadedmetadata = function (t) {
              n[e].handleVideoLoad(t);
            }),
            (s[e].controls = !0),
            T(t, e),
            l[e] && (s[e].poster = l[e]);
          var c = document.createElement("source");
          (c.src = o[e]),
            s[e].appendChild(c),
            setTimeout(n[e].handleNotMetaDatedVideoLoad, 3e3),
            i[e].appendChild(s[e]);
        }
        function O(t, e) {
          var n = t.collections.sourceLoadHandlers,
            r = t.elements,
            i = r.sources,
            a = r.sourceAnimationWrappers,
            o = t.props.sources;
          (i[e] = document.createElement("iframe")),
            E(t, e, "".concat(_, " ").concat(s, "youtube-iframe")),
            (i[e].src = "https://www.youtube.com/embed/".concat(
              o[e].match(
                /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|v=)([^#]*).*/
              )[2],
              "?enablejsapi=1"
            )),
            (i[e].allowFullscreen = !0),
            T(t, e),
            a[e].appendChild(i[e]),
            n[e].handleYoutubeLoad();
        }
        function A(t, e) {
          var n = t.collections.sourceLoadHandlers,
            r = t.elements,
            s = r.sources,
            i = r.sourceAnimationWrappers,
            a = t.props.sources;
          (s[e] = a[e]),
            E(t, e, "".concat(s[e].className, " ").concat(_)),
            i[e].appendChild(s[e]),
            n[e].handleCustomLoad();
        }
        function j(t, e) {
          var n = t.elements,
            r = n.sources,
            i = n.sourceAnimationWrappers,
            a = n.sourceMainWrappers;
          t.props.sources,
            (r[e] = document.createElement("div")),
            (r[e].className = "".concat(s, "invalid-file-wrapper ").concat(l)),
            (r[e].innerHTML = "Invalid source"),
            i[e].classList.add(g),
            i[e].appendChild(r[e]),
            a[e].removeChild(a[e].firstChild);
        }
        function $(t) {
          var e = t.collections,
            n = e.sourceLoadHandlers,
            r = e.sourcesRenderFunctions,
            s = t.core.sourceDisplayFacade,
            i = t.resolve;
          this.runActionsForSourceTypeAndIndex = function (e, a) {
            var o;
            switch (("invalid" !== e && (n[a] = i(k, [a])), e)) {
              case "image":
                o = P;
                break;
              case "video":
                o = M;
                break;
              case "youtube":
                o = O;
                break;
              case "custom":
                o = A;
                break;
              default:
                o = j;
            }
            (r[a] = function () {
              return o(t, a);
            }),
              s.displaySourcesWhichShouldBeDisplayed();
          };
        }
        function D() {
          var t,
            e,
            n,
            r = function (t) {
              var e = document.createElement("a");
              return (e.href = t), "www.youtube.com" === e.hostname;
            },
            s = function (t) {
              return t.slice(0, t.indexOf("/"));
            };
          function i() {
            if (4 !== n.readyState) {
              if (2 === n.readyState) {
                var t;
                switch (s(n.getResponseHeader("content-type"))) {
                  case "image":
                    t = "image";
                    break;
                  case "video":
                    t = "video";
                    break;
                  default:
                    t = "invalid";
                }
                (n.onreadystatechange = null), n.abort(), e(t);
              }
            } else e("invalid");
          }
          (this.setUrlToCheck = function (e) {
            t = e;
          }),
            (this.getSourceType = function (s) {
              if (r(t)) return s("youtube");
              (e = s),
                ((n = new XMLHttpRequest()).onreadystatechange = i),
                n.open("GET", t, !0),
                n.send();
            });
        }
        function I(t, e, n) {
          var r = t.props,
            s = r.types,
            i = r.type,
            a = r.sources,
            o = t.resolve;
          (this.getTypeSetByClientForIndex = function (t) {
            var e;
            return s && s[t] ? (e = s[t]) : i && (e = i), e;
          }),
            (this.retrieveTypeWithXhrForIndex = function (t) {
              var r = o(D);
              r.setUrlToCheck(a[t]),
                r.getSourceType(function (r) {
                  e.handleReceivedSourceTypeForUrl(r, a[t]),
                    n.runActionsForSourceTypeAndIndex(r, t);
                });
            });
        }
        function L(t, e) {
          var n = t.componentsServices.hideSourceLoaderIfNotYetCollection,
            r = t.elements,
            s = r.sourceWrappersContainer,
            i = r.sourceMainWrappers;
          (i[e] = document.createElement("div")),
            (i[e].className = "".concat(p, " ").concat(o, " ").concat(l)),
            (i[e].innerHTML =
              '<div class="fslightbox-loader"><div></div><div></div><div></div><div></div></div>');
          var a = i[e].firstChild;
          (n[e] = function () {
            i[e].contains(a) && i[e].removeChild(a);
          }),
            s.appendChild(i[e]),
            (function (t, e) {
              var n = t.elements,
                r = n.sourceMainWrappers,
                s = n.sourceAnimationWrappers;
              (s[e] = document.createElement("div")), r[e].appendChild(s[e]);
            })(t, e);
        }
        function V(t, e, n, r) {
          var i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          i.setAttributeNS(null, "width", e),
            i.setAttributeNS(null, "height", e),
            i.setAttributeNS(null, "viewBox", n);
          var a = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          return (
            a.setAttributeNS(null, "class", "".concat(s, "svg-path")),
            a.setAttributeNS(null, "d", r),
            i.appendChild(a),
            t.appendChild(i),
            i
          );
        }
        function N(t, e) {
          var n = document.createElement("div");
          return (
            (n.className = "".concat(s, "toolbar-button ").concat(l)),
            (n.title = e),
            t.appendChild(n),
            n
          );
        }
        function H(t) {
          var e = t.props.sources,
            n = t.elements.container,
            r = document.createElement("div");
          (r.className = "".concat(s, "nav")),
            n.appendChild(r),
            (function (t, e) {
              var n = document.createElement("div");
              (n.className = "".concat(s, "toolbar")),
                e.appendChild(n),
                (function (t, e) {
                  var n = t.componentsServices,
                    r = t.core.fullscreenToggler,
                    s = t.data,
                    i =
                      "M4.5 11H3v4h4v-1.5H4.5V11zM3 7h1.5V4.5H7V3H3v4zm10.5 6.5H11V15h4v-4h-1.5v2.5zM11 3v1.5h2.5V7H15V3h-4z",
                    a = N(e);
                  a.title = "Enter fullscreen";
                  var o = V(a, "20px", "0 0 18 18", i);
                  (n.enterFullscreen = function () {
                    (s.isFullscreenOpen = !0),
                      (a.title = "Exit fullscreen"),
                      o.setAttributeNS(null, "width", "24px"),
                      o.setAttributeNS(null, "height", "24px"),
                      o.setAttributeNS(null, "viewBox", "0 0 950 1024"),
                      o.firstChild.setAttributeNS(
                        null,
                        "d",
                        "M682 342h128v84h-212v-212h84v128zM598 810v-212h212v84h-128v128h-84zM342 342v-128h84v212h-212v-84h128zM214 682v-84h212v212h-84v-128h-128z"
                      );
                  }),
                    (n.exitFullscreen = function () {
                      (s.isFullscreenOpen = !1),
                        (a.title = "Enter fullscreen"),
                        o.setAttributeNS(null, "width", "20px"),
                        o.setAttributeNS(null, "height", "20px"),
                        o.setAttributeNS(null, "viewBox", "0 0 18 18"),
                        o.firstChild.setAttributeNS(null, "d", i);
                    }),
                    (a.onclick = function () {
                      s.isFullscreenOpen
                        ? r.exitFullscreen()
                        : r.enterFullscreen();
                    });
                })(t, n),
                (function (t, e) {
                  var n = N(e, "Close");
                  (n.onclick = t.core.lightboxCloser.closeLightbox),
                    V(
                      n,
                      "20px",
                      "0 0 24 24",
                      "M 4.7070312 3.2929688 L 3.2929688 4.7070312 L 10.585938 12 L 3.2929688 19.292969 L 4.7070312 20.707031 L 12 13.414062 L 19.292969 20.707031 L 20.707031 19.292969 L 13.414062 12 L 20.707031 4.7070312 L 19.292969 3.2929688 L 12 10.585938 L 4.7070312 3.2929688 z"
                    );
                })(t, n);
            })(t, r),
            e.length > 1 &&
              (function (t, e) {
                var n = t.componentsServices,
                  r = t.props.sources,
                  i = (t.stageIndexes, document.createElement("div"));
                i.className = "".concat(s, "slide-number-container");
                var a = document.createElement("div");
                a.className = l;
                var o = document.createElement("span");
                n.setSlideNumber = function (t) {
                  return (o.innerHTML = t);
                };
                var c = document.createElement("span");
                c.className = "".concat(s, "slash");
                var u = document.createElement("div");
                (u.innerHTML = r.length),
                  i.appendChild(a),
                  a.appendChild(o),
                  a.appendChild(c),
                  a.appendChild(u),
                  e.appendChild(i),
                  setTimeout(function () {
                    a.offsetWidth > 55 &&
                      (i.style.justifyContent = "flex-start");
                  });
              })(t, r);
        }
        function R(t, e) {
          var n = this,
            r = t.elements.sourceMainWrappers,
            s = t.props,
            i = 0;
          (this.byValue = function (t) {
            return (i = t), n;
          }),
            (this.negative = function () {
              a(-o());
            }),
            (this.zero = function () {
              a(0);
            }),
            (this.positive = function () {
              a(o());
            });
          var a = function (t) {
              (r[e].style.transform = "translateX(".concat(t + i, "px)")),
                (i = 0);
            },
            o = function () {
              return (1 + s.slideDistance) * innerWidth;
            };
        }
        function z(t, e, n, r) {
          var s = t.elements.container,
            i = n.charAt(0).toUpperCase() + n.slice(1),
            a = document.createElement("div");
          (a.className = "".concat(f, " ").concat(f, "-").concat(n)),
            (a.title = "".concat(i, " slide")),
            (a.onclick = e),
            (function (t, e) {
              var n = document.createElement("div");
              (n.className = "".concat(d, " ").concat(l)),
                V(n, "20px", "0 0 20 20", e),
                t.appendChild(n);
            })(a, r),
            s.appendChild(a);
        }
        function q(t, e) {
          var n = t.classList;
          n.contains(e) && n.remove(e);
        }
        function B(t) {
          var e = this,
            n = t.core,
            r = n.eventsDispatcher,
            s = n.fullscreenToggler,
            i = n.globalEventsController,
            a = n.scrollbarRecompensor,
            o = t.data,
            l = t.elements,
            u = t.props,
            p = t.sourcePointerProps;
          (this.isLightboxFadingOut = !1),
            (this.runActions = function () {
              (e.isLightboxFadingOut = !0),
                l.container.classList.add(v),
                i.removeListeners(),
                u.exitFullscreenOnClose &&
                  o.isFullscreenOpen &&
                  s.exitFullscreen(),
                setTimeout(function () {
                  (e.isLightboxFadingOut = !1),
                    (p.isPointering = !1),
                    l.container.classList.remove(v),
                    document.documentElement.classList.remove(c),
                    a.removeRecompense(),
                    document.body.removeChild(l.container),
                    r.dispatch("onClose");
                }, 270);
            });
        }
        function F(t) {
          var e = t.core,
            n = e.lightboxCloser,
            r = e.fullscreenToggler,
            s = e.slideChangeFacade;
          this.listener = function (t) {
            switch (t.key) {
              case "Escape":
                n.closeLightbox();
                break;
              case "ArrowLeft":
                s.changeToPrevious();
                break;
              case "ArrowRight":
                s.changeToNext();
                break;
              case "F11":
                t.preventDefault(), r.enterFullscreen();
            }
          };
        }
        function U(t) {
          var e = t.props.sources,
            n = t.resolve,
            r = t.sourcePointerProps,
            s = n(Object);
          1 === e.length
            ? (this.listener = function () {
                r.swipedX = 1;
              })
            : (this.listener = function (t) {
                r.isPointering && s.runActionsForEvent(t);
              });
        }

        function Y(t, e) {
          t.contains(e) && t.removeChild(e);
        }
        function X(t) {
          var e = t.core.lightboxCloser,
            n = t.elements,
            r = t.resolve,
            s = t.sourcePointerProps,
            i = r(Object);
          (this.runNoSwipeActions = function () {
            Y(n.container, n.slideSwipingHoverer),
              s.isSourceDownEventTarget || e.closeLightbox(),
              (s.isPointering = !1);
          }),
            (this.runActions = function () {
              s.swipedX > 0
                ? i.runPositiveSwipedXActions()
                : i.runNegativeSwipedXActions(),
                Y(n.container, n.slideSwipingHoverer),
                n.container.classList.remove(a),
                (s.isPointering = !1);
            });
        }
        function K(t) {
          var e = t.resolve,
            n = t.sourcePointerProps,
            r = e(X);
          this.listener = function () {
            n.isPointering &&
              (n.swipedX ? r.runActions() : r.runNoSwipeActions());
          };
        }
        function Q(t) {
          var e, n, r;
          (n = (e = t).core.classFacade),
            (r = e.elements),
            (n.removeFromEachElementClassIfContains = function (t, e) {
              for (var n = 0; n < r[t].length; n++) q(r[t][n], e);
            }),
            (function (t) {
              var e = t.core.eventsDispatcher,
                n = t.props;
              e.dispatch = function (t) {
                n[t] && n[t]();
              };
            })(t),
            (function (t) {
              var e = t.componentsServices,
                n = t.core.fullscreenToggler;
              (n.enterFullscreen = function () {
                e.enterFullscreen();
                var t = document.documentElement;
                t.requestFullscreen
                  ? t.requestFullscreen()
                  : t.mozRequestFullScreen
                  ? t.mozRequestFullScreen()
                  : t.webkitRequestFullscreen
                  ? t.webkitRequestFullscreen()
                  : t.msRequestFullscreen && t.msRequestFullscreen();
              }),
                (n.exitFullscreen = function () {
                  e.exitFullscreen(),
                    document.exitFullscreen
                      ? document.exitFullscreen()
                      : document.mozCancelFullScreen
                      ? document.mozCancelFullScreen()
                      : document.webkitExitFullscreen
                      ? document.webkitExitFullscreen()
                      : document.msExitFullscreen &&
                        document.msExitFullscreen();
                });
            })(t),
            (function (t) {
              var e = t.core,
                n = e.globalEventsController,
                r = e.windowResizeActioner,
                s = t.resolve,
                i = s(F),
                a = s(U),
                o = s(K);
              (n.attachListeners = function () {
                document.addEventListener("pointermove", a.listener),
                  document.addEventListener("pointerup", o.listener),
                  addEventListener("resize", r.runActions),
                  document.addEventListener("keydown", i.listener);
              }),
                (n.removeListeners = function () {
                  document.removeEventListener("pointermove", a.listener),
                    document.removeEventListener("pointerup", o.listener),
                    removeEventListener("resize", r.runActions),
                    document.removeEventListener("keydown", i.listener);
                });
            })(t),
            (function (t) {
              var e = t.core.lightboxCloser,
                n = (0, t.resolve)(B);
              e.closeLightbox = function () {
                n.isLightboxFadingOut || n.runActions();
              };
            })(t),
            Z(t),
            (function (t) {
              var e = t.data,
                n = t.core.scrollbarRecompensor;
              function r() {
                document.body.offsetHeight > innerHeight &&
                  (document.body.style.marginRight = e.scrollbarWidth + "px");
              }
              (n.addRecompense = function () {
                "complete" === document.readyState
                  ? r()
                  : addEventListener("load", function () {
                      r(), (n.addRecompense = r);
                    });
              }),
                (n.removeRecompense = function () {
                  document.body.style.removeProperty("margin-right");
                });
            })(t),
            (function (t) {
              var e = t.core,
                n = e.slideChangeFacade,
                r = e.slideIndexChanger,
                s = e.stageManager;
              t.props.sources.length > 1
                ? ((n.changeToPrevious = function () {
                    r.jumpTo(s.getPreviousSlideIndex());
                  }),
                  (n.changeToNext = function () {
                    r.jumpTo(s.getNextSlideIndex());
                  }))
                : ((n.changeToPrevious = function () {}),
                  (n.changeToNext = function () {}));
            })(t),
            (function (t) {
              var e,
                n,
                r = t.collections.sourceMainWrappersTransformers,
                s = t.componentsServices,
                i = t.core,
                a = i.classFacade,
                o = i.slideIndexChanger,
                l = i.sourceDisplayFacade,
                c = i.stageManager,
                p = t.elements.sourceAnimationWrappers,
                d = t.stageIndexes,
                f =
                  ((e = function () {
                    a.removeFromEachElementClassIfContains(
                      "sourceAnimationWrappers",
                      m
                    );
                  }),
                  (n = []),
                  function () {
                    n.push(!0),
                      setTimeout(function () {
                        n.pop(), n.length || e();
                      }, 300);
                  });
              (o.changeTo = function (t) {
                (d.current = t),
                  c.updateStageIndexes(),
                  s.setSlideNumber(t + 1),
                  l.displaySourcesWhichShouldBeDisplayed();
              }),
                (o.jumpTo = function (t) {
                  var e = d.current;
                  o.changeTo(t),
                    a.removeFromEachElementClassIfContains(
                      "sourceMainWrappers",
                      u
                    ),
                    q(p[e], g),
                    q(p[e], h),
                    p[e].classList.add(m),
                    q(p[t], g),
                    q(p[t], m),
                    p[t].classList.add(h),
                    f(),
                    r[t].zero(),
                    setTimeout(function () {
                      e !== d.current && r[e].negative();
                    }, 270);
                });
            })(t),
            (function (t) {
              var e = t.core,
                n = e.classFacade,
                r = e.sourcesPointerDown,
                s = t.elements.sources,
                i = t.sourcePointerProps,
                a = t.stageIndexes;
              r.listener = function (t) {
                "VIDEO" !== t.target.tagName && t.preventDefault(),
                  (i.isPointering = !0),
                  (i.downScreenX = t.screenX),
                  (i.swipedX = 0);
                var e = s[a.current];
                e && e.contains(t.target)
                  ? (i.isSourceDownEventTarget = !0)
                  : (i.isSourceDownEventTarget = !1),
                  n.removeFromEachElementClassIfContains(
                    "sourceMainWrappers",
                    u
                  );
              };
            })(t),
            (function (t) {
              var e = t.collections.sourcesRenderFunctions,
                n = t.core.sourceDisplayFacade,
                r = t.props,
                s = t.stageIndexes;
              function i(t) {
                e[t] && (e[t](), delete e[t]);
              }
              n.displaySourcesWhichShouldBeDisplayed = function () {
                if (r.loadOnlyCurrentSource) i(s.current);
                else for (var t in s) i(s[t]);
              };
            })(t),
            (function (t) {
              var e = t.stageIndexes,
                n = t.core.stageManager,
                r = t.props.sources.length - 1;
              (n.getPreviousSlideIndex = function () {
                return 0 === e.current ? r : e.current - 1;
              }),
                (n.getNextSlideIndex = function () {
                  return e.current === r ? 0 : e.current + 1;
                }),
                (n.updateStageIndexes =
                  0 === r
                    ? function () {}
                    : 1 === r
                    ? function () {
                        0 === e.current
                          ? ((e.next = 1), delete e.previous)
                          : ((e.previous = 0), delete e.next);
                      }
                    : function () {
                        (e.previous = n.getPreviousSlideIndex()),
                          (e.next = n.getNextSlideIndex());
                      }),
                (n.isSourceInStage =
                  r <= 2
                    ? function () {
                        return !0;
                      }
                    : function (t) {
                        var n = e.current;
                        if ((0 === n && t === r) || (n === r && 0 === t))
                          return !0;
                        var s = n - t;
                        return -1 === s || 0 === s || 1 === s;
                      });
            })(t),
            (function (t) {
              var e = t.collections,
                n = e.sourceMainWrappersTransformers,
                r = e.sourceSizers,
                s = t.core.windowResizeActioner,
                i = t.data,
                a = t.elements.sourceMainWrappers,
                o = t.props,
                l = t.stageIndexes;
              s.runActions = function () {
                innerWidth < 992
                  ? (i.maxSourceWidth = innerWidth)
                  : (i.maxSourceWidth = 0.9 * innerWidth),
                  (i.maxSourceHeight = 0.9 * innerHeight);
                for (var t = 0; t < o.sources.length; t++)
                  q(a[t], u),
                    t !== l.current && n[t].negative(),
                    r[t] && r[t].adjustSize();
              };
            })(t);
        }
        function J(t) {
          var e = t.core.eventsDispatcher,
            n = t.data,
            r = t.elements,
            i = t.props.sources;
          (n.isInitialized = !0),
            (n.scrollbarWidth = (function (t) {
              var e = t.props.disableLocalStorage;
              if (!e) {
                var n = localStorage.getItem("fslightbox-scrollbar-width");
                if (n) return n;
              }
              var r = (function () {
                  var t = document.createElement("div"),
                    e = t.style;
                  return (
                    (e.visibility = "hidden"),
                    (e.width = "100px"),
                    (e.msOverflowStyle = "scrollbar"),
                    (e.overflow = "scroll"),
                    t
                  );
                })(),
                s = (function () {
                  var t = document.createElement("div");
                  return (t.style.width = "100%"), t;
                })();
              document.body.appendChild(r);
              var i = r.offsetWidth;
              r.appendChild(s);
              var a = s.offsetWidth;
              document.body.removeChild(r);
              var o = i - a;
              return (
                e ||
                  localStorage.setItem(
                    "fslightbox-scrollbar-width",
                    o.toString()
                  ),
                o
              );
            })(t)),
            (function (t) {
              for (
                var e = t.collections.sourceMainWrappersTransformers,
                  n = t.props.sources,
                  r = t.resolve,
                  s = 0;
                s < n.length;
                s++
              )
                e[s] = r(R, [s]);
            })(t),
            Q(t),
            (r.container = document.createElement("div")),
            (r.container.className = ""
              .concat(s, "container ")
              .concat(o, " ")
              .concat(g)),
            (function (t) {
              var e = t.elements;
              (e.slideSwipingHoverer = document.createElement("div")),
                (e.slideSwipingHoverer.className = ""
                  .concat(s, "slide-swiping-hoverer ")
                  .concat(o, " ")
                  .concat(p));
            })(t),
            H(t),
            (function (t) {
              var e = t.core.sourcesPointerDown,
                n = t.elements,
                r = t.props.sources,
                s = document.createElement("div");
              (s.className = "".concat(p, " ").concat(o)),
                n.container.appendChild(s),
                s.addEventListener("pointerdown", e.listener),
                (n.sourceWrappersContainer = s);
              for (var i = 0; i < r.length; i++) L(t, i);
            })(t),
            i.length > 1 &&
              (function (t) {
                var e = t.core.slideChangeFacade;
                z(
                  t,
                  e.changeToPrevious,
                  "previous",
                  "M18.271,9.212H3.615l4.184-4.184c0.306-0.306,0.306-0.801,0-1.107c-0.306-0.306-0.801-0.306-1.107,0L1.21,9.403C1.194,9.417,1.174,9.421,1.158,9.437c-0.181,0.181-0.242,0.425-0.209,0.66c0.005,0.038,0.012,0.071,0.022,0.109c0.028,0.098,0.075,0.188,0.142,0.271c0.021,0.026,0.021,0.061,0.045,0.085c0.015,0.016,0.034,0.02,0.05,0.033l5.484,5.483c0.306,0.307,0.801,0.307,1.107,0c0.306-0.305,0.306-0.801,0-1.105l-4.184-4.185h14.656c0.436,0,0.788-0.353,0.788-0.788S18.707,9.212,18.271,9.212z"
                ),
                  z(
                    t,
                    e.changeToNext,
                    "next",
                    "M1.729,9.212h14.656l-4.184-4.184c-0.307-0.306-0.307-0.801,0-1.107c0.305-0.306,0.801-0.306,1.106,0l5.481,5.482c0.018,0.014,0.037,0.019,0.053,0.034c0.181,0.181,0.242,0.425,0.209,0.66c-0.004,0.038-0.012,0.071-0.021,0.109c-0.028,0.098-0.075,0.188-0.143,0.271c-0.021,0.026-0.021,0.061-0.045,0.085c-0.015,0.016-0.034,0.02-0.051,0.033l-5.483,5.483c-0.306,0.307-0.802,0.307-1.106,0c-0.307-0.305-0.307-0.801,0-1.105l4.184-4.185H1.729c-0.436,0-0.788-0.353-0.788-0.788S1.293,9.212,1.729,9.212z"
                  );
              })(t),
            (function (t) {
              for (
                var e = t.props.sources,
                  n = t.resolve,
                  r = n(S),
                  s = n($),
                  i = n(I, [r, s]),
                  a = 0;
                a < e.length;
                a++
              )
                if ("string" == typeof e[a]) {
                  var o = i.getTypeSetByClientForIndex(a);
                  if (o) s.runActionsForSourceTypeAndIndex(o, a);
                  else {
                    var l = r.getSourceTypeFromLocalStorageByUrl(e[a]);
                    l
                      ? s.runActionsForSourceTypeAndIndex(l, a)
                      : i.retrieveTypeWithXhrForIndex(a);
                  }
                } else s.runActionsForSourceTypeAndIndex("custom", a);
            })(t),
            e.dispatch("onInit");
        }
        function Z(t) {
          var e = t.collections.sourceMainWrappersTransformers,
            n = t.componentsServices,
            r = t.core,
            s = r.eventsDispatcher,
            i = r.lightboxOpener,
            a = r.globalEventsController,
            o = r.scrollbarRecompensor,
            l = r.sourceDisplayFacade,
            u = r.stageManager,
            p = r.windowResizeActioner,
            d = t.data,
            f = t.elements,
            h = t.stageIndexes;
          i.open = function () {
            var r =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 0;
            (h.current = r),
              d.isInitialized ? s.dispatch("onShow") : J(t),
              u.updateStageIndexes(),
              l.displaySourcesWhichShouldBeDisplayed(),
              n.setSlideNumber(r + 1),
              document.body.appendChild(f.container),
              document.documentElement.classList.add(c),
              o.addRecompense(),
              a.attachListeners(),
              p.runActions(),
              e[h.current].zero(),
              s.dispatch("onOpen");
          };
        }
        function tt() {
          var implementation = et()
            ? Reflect.construct
            : function (t, e, n) {
                var r = [null];
                r.push.apply(r, e);
                var s = new (Function.bind.apply(t, r))();
                return n && nt(s, n.prototype), s;
              };

          return implementation.apply(null, arguments);
        }

        function et() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return (
              Date.prototype.toString.call(
                Reflect.construct(Date, [], function () {})
              ),
              !0
            );
          } catch (t) {
            return !1;
          }
        }
        function nt(t, e) {
          return Object.setPrototypeOf
            ? Object.setPrototypeOf(t, e)
            : setPrototypeOfFallback(t, e);
        }

        function setPrototypeOfFallback(obj, proto) {
          obj.__proto__ = proto;
          return obj;
        }

        function rt(t) {
          return (
            (function (t) {
              if (Array.isArray(t)) return st(t);
            })(t) ||
            (function (t) {
              if ("undefined" != typeof Symbol && Symbol.iterator in Object(t))
                return Array.from(t);
            })(t) ||
            (function (t, e) {
              if (t) {
                if ("string" == typeof t) return st(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return (
                  "Object" === n && t.constructor && (n = t.constructor.name),
                  "Map" === n || "Set" === n
                    ? Array.from(t)
                    : "Arguments" === n ||
                      /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                    ? st(t, e)
                    : void 0
                );
              }
            })(t) ||
            (function () {
              throw new TypeError(
                "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
              );
            })()
          );
        }
        function st(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
          return r;
        }
        function it() {
          var fsLightboxInstances;
          for (
            var t = document.getElementsByTagName("a"),
              e = function (e) {
                if (!t[e].hasAttribute("data-fslightbox")) return "continue";
                var n = t[e].getAttribute("data-fslightbox"),
                  r = t[e].getAttribute("href");
                fsLightboxInstances[n];
                var s = null;
                "#" === r.charAt(0)
                  ? (s = document
                      .getElementById(r.substring(1))
                      .cloneNode(!0)).removeAttribute("id")
                  : (s = r),
                  fsLightboxInstances[n].props.sources.push(s),
                  fsLightboxInstances[n].elements.a.push(t[e]);
                var i = fsLightboxInstances[n].props.sources.length - 1;
                (t[e].onclick = function (t) {
                  t.preventDefault(), fsLightboxInstances[n].open(i);
                }),
                  p("types", "data-type"),
                  p("videosPosters", "data-video-poster"),
                  p("customClasses", "data-class"),
                  p("customClasses", "data-custom-class");
                for (
                  var a = [
                      "href",
                      "data-fslightbox",
                      "data-type",
                      "data-video-poster",
                      "data-class",
                      "data-custom-class",
                    ],
                    o = t[e].attributes,
                    l = fsLightboxInstances[n].props.customAttributes,
                    c = 0;
                  c < o.length;
                  c++
                )
                  if (
                    -1 === a.indexOf(o[c].name) &&
                    "data-" === o[c].name.substr(0, 5)
                  ) {
                    l[i] || (l[i] = {});
                    var u = o[c].name.substr(5);
                    l[i][u] = o[c].value;
                  }
                function p(r, s) {
                  t[e].hasAttribute(s) &&
                    (fsLightboxInstances[n].props[r][i] = t[e].getAttribute(s));
                }
              },
              n = 0;
            n < t.length;
            n++
          )
            e(n);
          var r = Object.keys(fsLightboxInstances);
          window.fsLightbox = fsLightboxInstances[r[r.length - 1]];
        }
        "object" ===
          ("undefined" == typeof document ? "undefined" : "undefined") &&
          (((r = document.createElement("style")).className = i),
          r.appendChild(
            document.createTextNode(
              ".fslightbox-absoluted{position:absolute;top:0;left:0}.fslightbox-fade-in{animation:fslightbox-fade-in .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out{animation:fslightbox-fade-out .3s ease}.fslightbox-fade-in-strong{animation:fslightbox-fade-in-strong .3s cubic-bezier(0,0,.7,1)}.fslightbox-fade-out-strong{animation:fslightbox-fade-out-strong .3s ease}@keyframes fslightbox-fade-in{from{opacity:.65}to{opacity:1}}@keyframes fslightbox-fade-out{from{opacity:.35}to{opacity:0}}@keyframes fslightbox-fade-in-strong{from{opacity:.3}to{opacity:1}}@keyframes fslightbox-fade-out-strong{from{opacity:1}to{opacity:0}}.fslightbox-cursor-grabbing{cursor:grabbing}.fslightbox-full-dimension{width:100%;height:100%}.fslightbox-open{overflow:hidden;height:100%}.fslightbox-flex-centered{display:flex;justify-content:center;align-items:center}.fslightbox-opacity-0{opacity:0!important}.fslightbox-opacity-1{opacity:1!important}.fslightbox-scrollbarfix{padding-right:17px}.fslightbox-transform-transition{transition:transform .3s}.fslightbox-container{font-family:Arial,sans-serif;position:fixed;top:0;left:0;background:linear-gradient(rgba(30,30,30,.9),#000 1810%);touch-action:pinch-zoom;z-index:1000000000;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.fslightbox-container *{box-sizing:border-box}.fslightbox-svg-path{transition:fill .15s ease;fill:#ddd}.fslightbox-nav{height:45px;width:100%;position:absolute;top:0;left:0}.fslightbox-slide-number-container{display:flex;justify-content:center;align-items:center;position:relative;height:100%;font-size:15px;color:#d7d7d7;z-index:0;max-width:55px;text-align:left}.fslightbox-slide-number-container .fslightbox-flex-centered{height:100%}.fslightbox-slash{display:block;margin:0 5px;width:1px;height:12px;transform:rotate(15deg);background:#fff}.fslightbox-toolbar{position:absolute;z-index:3;right:0;top:0;height:100%;display:flex;background:rgba(35,35,35,.65)}.fslightbox-toolbar-button{height:100%;width:45px;cursor:pointer}.fslightbox-toolbar-button:hover .fslightbox-svg-path{fill:#fff}.fslightbox-slide-btn-container{display:flex;align-items:center;padding:12px 12px 12px 6px;position:absolute;top:50%;cursor:pointer;z-index:3;transform:translateY(-50%)}@media (min-width:476px){.fslightbox-slide-btn-container{padding:22px 22px 22px 6px}}@media (min-width:768px){.fslightbox-slide-btn-container{padding:30px 30px 30px 6px}}.fslightbox-slide-btn-container:hover .fslightbox-svg-path{fill:#f1f1f1}.fslightbox-slide-btn{padding:9px;font-size:26px;background:rgba(35,35,35,.65)}@media (min-width:768px){.fslightbox-slide-btn{padding:10px}}@media (min-width:1600px){.fslightbox-slide-btn{padding:11px}}.fslightbox-slide-btn-container-previous{left:0}@media (max-width:475.99px){.fslightbox-slide-btn-container-previous{padding-left:3px}}.fslightbox-slide-btn-container-next{right:0;padding-left:12px;padding-right:3px}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-left:22px}}@media (min-width:768px){.fslightbox-slide-btn-container-next{padding-left:30px}}@media (min-width:476px){.fslightbox-slide-btn-container-next{padding-right:6px}}.fslightbox-down-event-detector{position:absolute;z-index:1}.fslightbox-slide-swiping-hoverer{z-index:4}.fslightbox-invalid-file-wrapper{font-size:22px;color:#eaebeb;margin:auto}.fslightbox-video{object-fit:cover}.fslightbox-youtube-iframe{border:0}.fslightbox-loader{display:block;margin:auto;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:67px;height:67px}.fslightbox-loader div{box-sizing:border-box;display:block;position:absolute;width:54px;height:54px;margin:6px;border:5px solid;border-color:#999 transparent transparent transparent;border-radius:50%;animation:fslightbox-loader 1.2s cubic-bezier(.5,0,.5,1) infinite}.fslightbox-loader div:nth-child(1){animation-delay:-.45s}.fslightbox-loader div:nth-child(2){animation-delay:-.3s}.fslightbox-loader div:nth-child(3){animation-delay:-.15s}@keyframes fslightbox-loader{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.fslightbox-source{position:relative;z-index:2;opacity:0}"
            )
          ),
          document.head.appendChild(r)),
          (window.FsLightbox = function () {
            var t = this;
            (this.props = {
              sources: [],
              customAttributes: [],
              customClasses: [],
              types: [],
              videosPosters: [],
              slideDistance: 0.3,
            }),
              (this.data = {
                isInitialized: !1,
                isFullscreenOpen: !1,
                maxSourceWidth: 0,
                maxSourceHeight: 0,
                scrollbarWidth: 0,
              }),
              (this.sourcePointerProps = {
                downScreenX: null,
                isPointering: !1,
                isSourceDownEventTarget: !1,
                swipedX: 0,
              }),
              (this.stageIndexes = {}),
              (this.elements = {
                a: [],
                container: null,
                slideSwipingHoverer: null,
                sourceWrappersContainer: null,
                sources: [],
                sourceMainWrappers: [],
                sourceAnimationWrappers: [],
              }),
              (this.componentsServices = {
                enterFullscreen: null,
                exitFullscreen: null,
                hideSourceLoaderIfNotYetCollection: [],
                setSlideNumber: function () {},
              }),
              (this.resolve = function (e) {
                var n =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : [];
                return n.unshift(t), tt(e, rt(n));
              }),
              (this.collections = {
                sourceMainWrappersTransformers: [],
                sourceLoadHandlers: [],
                sourcesRenderFunctions: [],
                sourceSizers: [],
              }),
              (this.core = {
                classFacade: {},
                eventsDispatcher: {},
                fullscreenToggler: {},
                globalEventsController: {},
                lightboxCloser: {},
                lightboxOpener: {},
                lightboxUpdater: {},
                scrollbarRecompensor: {},
                slideChangeFacade: {},
                slideIndexChanger: {},
                sourcesPointerDown: {},
                sourceDisplayFacade: {},
                stageManager: {},
                windowResizeActioner: {},
              }),
              Z(this),
              (this.open = function (e) {
                return t.core.lightboxOpener.open(e);
              }),
              (this.close = function () {
                return t.core.lightboxCloser.closeLightbox();
              });
          }),
          (window.fsLightboxInstances = {}),
          it(),
          (window.refreshFsLightbox = function () {
            for (var t in window.fsLightboxInstances) {
              var e = window.fsLightboxInstances[t].props;
              (window.fsLightboxInstances[t].props = e),
                (window.fsLightboxInstances[t].props.sources = []),
                (window.fsLightboxInstances[t].elements.a = []);
            }
            it();
          });
      },
    ]);
  }),
  function (t, e) {
    "object" == typeof exports && "object" == typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define([], e)
      : "object" == typeof exports
      ? (exports.HSFileAttach = e())
      : (t.HSFileAttach = e());
  },
  (function () {
    var t = {
        "./src/add-async.js": function (t) {
          t.exports = function (t) {
            return function e(n, r, s) {
              var i = n.splice(0, 50);
              (s = (s = s || []).concat(t.add(i))),
                n.length > 0
                  ? setTimeout(function () {
                      e(n, r, s);
                    }, 1)
                  : (t.update(), r(s));
            };
          };
        },
        "./src/filter.js": function (t) {
          t.exports = function (t) {
            return (
              (t.handlers.filterStart = t.handlers.filterStart || []),
              (t.handlers.filterComplete = t.handlers.filterComplete || []),
              function (e) {
                if (
                  (t.trigger("filterStart"),
                  (t.i = 1),
                  t.reset.filter(),
                  void 0 === e)
                )
                  t.filtered = !1;
                else {
                  t.filtered = !0;
                  for (var n = t.items, r = 0, s = n.length; r < s; r++) {
                    var i = n[r];
                    e(i) ? (i.filtered = !0) : (i.filtered = !1);
                  }
                }
                return t.update(), t.trigger("filterComplete"), t.visibleItems;
              }
            );
          };
        },
        "./src/fuzzy-search.js": function (t, e, n) {
          n("./src/utils/classes.js");
          var r = n("./src/utils/events.js"),
            s = n("./src/utils/extend.js"),
            i = n("./src/utils/to-string.js"),
            a = n("./src/utils/get-by-class.js"),
            o = n("./src/utils/fuzzy.js");
          t.exports = function (t, e) {
            e = s(
              {
                location: 0,
                distance: 100,
                threshold: 0.4,
                multiSearch: !0,
                searchClass: "fuzzy-search",
              },
              (e = e || {})
            );
            var n = {
              search: function (r, s) {
                for (
                  var i = e.multiSearch
                      ? r.replace(/ +$/, "").split(/ +/)
                      : [r],
                    a = 0,
                    o = t.items.length;
                  a < o;
                  a++
                )
                  n.item(t.items[a], s, i);
              },
              item: function (t, e, r) {
                for (var s = !0, i = 0; i < r.length; i++) {
                  for (var a = !1, o = 0, l = e.length; o < l; o++)
                    n.values(t.values(), e[o], r[i]) && (a = !0);
                  a || (s = !1);
                }
                t.found = s;
              },
              values: function (t, n, r) {
                if (Object.prototype.hasOwnProperty.call(t, n)) {
                  var s = i(t[n]).toLowerCase();
                  if (o(s, r, e)) return !0;
                }
                return !1;
              },
            };
            return (
              r.bind(
                a(t.listContainer, e.searchClass),
                "keyup",
                t.utils.events.debounce(function (e) {
                  var r = e.target || e.srcElement;
                  t.search(r.value, n.search);
                }, t.searchDelay)
              ),
              function (e, r) {
                t.search(e, r, n.search);
              }
            );
          };
        },
        "./src/index.js": function (t, e, n) {
          var r = n("./node_modules/string-natural-compare/natural-compare.js"),
            s = n("./src/utils/get-by-class.js"),
            i = n("./src/utils/extend.js"),
            a = n("./src/utils/index-of.js"),
            o = n("./src/utils/events.js"),
            l = n("./src/utils/to-string.js"),
            c = n("./src/utils/classes.js"),
            u = n("./src/utils/get-attribute.js"),
            p = n("./src/utils/to-array.js");
          t.exports = function (t, e, d) {
            var f,
              h = this,
              m = n("./src/item.js")(h),
              g = n("./src/add-async.js")(h),
              v = n("./src/pagination.js")(h);
            (f = {
              start: function () {
                (h.listClass = "list"),
                  (h.searchClass = "search"),
                  (h.sortClass = "sort"),
                  (h.page = 1e4),
                  (h.i = 1),
                  (h.items = []),
                  (h.visibleItems = []),
                  (h.matchingItems = []),
                  (h.searched = !1),
                  (h.filtered = !1),
                  (h.searchColumns = void 0),
                  (h.searchDelay = 0),
                  (h.handlers = { updated: [] }),
                  (h.valueNames = []),
                  (h.utils = {
                    getByClass: s,
                    extend: i,
                    indexOf: a,
                    events: o,
                    toString: l,
                    naturalSort: r,
                    classes: c,
                    getAttribute: u,
                    toArray: p,
                  }),
                  h.utils.extend(h, e),
                  (h.listContainer =
                    "string" == typeof t ? document.getElementById(t) : t),
                  h.listContainer &&
                    ((h.list = s(h.listContainer, h.listClass, !0)),
                    (h.parse = n("./src/parse.js")(h)),
                    (h.templater = n("./src/templater.js")(h)),
                    (h.search = n("./src/search.js")(h)),
                    (h.filter = n("./src/filter.js")(h)),
                    (h.sort = n("./src/sort.js")(h)),
                    (h.fuzzySearch = n("./src/fuzzy-search.js")(
                      h,
                      e.fuzzySearch
                    )),
                    this.handlers(),
                    this.items(),
                    this.pagination(),
                    h.update());
              },
              handlers: function () {
                for (var t in h.handlers)
                  h[t] &&
                    Object.prototype.hasOwnProperty.call(h, t) &&
                    h.on(t, h[t]);
              },
              items: function () {
                h.parse(h.list), void 0 !== d && h.add(d);
              },
              pagination: function () {
                if (void 0 !== e.pagination) {
                  !0 === e.pagination && (e.pagination = [{}]),
                    void 0 === e.pagination[0] &&
                      (e.pagination = [e.pagination]);
                  for (var t = 0, n = e.pagination.length; t < n; t++)
                    v(e.pagination[t]);
                }
              },
            }),
              (this.reIndex = function () {
                (h.items = []),
                  (h.visibleItems = []),
                  (h.matchingItems = []),
                  (h.searched = !1),
                  (h.filtered = !1),
                  h.parse(h.list);
              }),
              (this.toJSON = function () {
                for (var t = [], e = 0, n = h.items.length; e < n; e++)
                  t.push(h.items[e].values());
                return t;
              }),
              (this.add = function (t, e) {
                if (0 !== t.length) {
                  if (!e) {
                    var n = [],
                      r = !1;
                    void 0 === t[0] && (t = [t]);
                    for (var s = 0, i = t.length; s < i; s++) {
                      var a;
                      (r = h.items.length > h.page),
                        (a = new m(t[s], void 0, r)),
                        h.items.push(a),
                        n.push(a);
                    }
                    return h.update(), n;
                  }
                  g(t.slice(0), e);
                }
              }),
              (this.show = function (t, e) {
                return (this.i = t), (this.page = e), h.update(), h;
              }),
              (this.remove = function (t, e, n) {
                for (var r = 0, s = 0, i = h.items.length; s < i; s++)
                  h.items[s].values()[t] == e &&
                    (h.templater.remove(h.items[s], n),
                    h.items.splice(s, 1),
                    i--,
                    s--,
                    r++);
                return h.update(), r;
              }),
              (this.get = function (t, e) {
                for (var n = [], r = 0, s = h.items.length; r < s; r++) {
                  var i = h.items[r];
                  i.values()[t] == e && n.push(i);
                }
                return n;
              }),
              (this.size = function () {
                return h.items.length;
              }),
              (this.clear = function () {
                return h.templater.clear(), (h.items = []), h;
              }),
              (this.on = function (t, e) {
                return h.handlers[t].push(e), h;
              }),
              (this.off = function (t, e) {
                var n = h.handlers[t],
                  r = a(n, e);
                return r > -1 && n.splice(r, 1), h;
              }),
              (this.trigger = function (t) {
                for (var e = h.handlers[t].length; e--; ) h.handlers[t][e](h);
                return h;
              }),
              (this.reset = {
                filter: function () {
                  for (var t = h.items, e = t.length; e--; ) t[e].filtered = !1;
                  return h;
                },
                search: function () {
                  for (var t = h.items, e = t.length; e--; ) t[e].found = !1;
                  return h;
                },
              }),
              (this.update = function () {
                var t = h.items,
                  e = t.length;
                (h.visibleItems = []),
                  (h.matchingItems = []),
                  h.templater.clear();
                for (var n = 0; n < e; n++)
                  t[n].matching() &&
                  h.matchingItems.length + 1 >= h.i &&
                  h.visibleItems.length < h.page
                    ? (t[n].show(),
                      h.visibleItems.push(t[n]),
                      h.matchingItems.push(t[n]))
                    : t[n].matching()
                    ? (h.matchingItems.push(t[n]), t[n].hide())
                    : t[n].hide();
                return h.trigger("updated"), h;
              }),
              f.start();
          };
        },
        "./src/item.js": function (t) {
          t.exports = function (t) {
            return function (e, n, r) {
              var s = this;
              (this._values = {}),
                (this.found = !1),
                (this.filtered = !1),
                (this.values = function (e, n) {
                  if (void 0 === e) return s._values;
                  for (var r in e) s._values[r] = e[r];
                  !0 !== n && t.templater.set(s, s.values());
                }),
                (this.show = function () {
                  t.templater.show(s);
                }),
                (this.hide = function () {
                  t.templater.hide(s);
                }),
                (this.matching = function () {
                  return (
                    (t.filtered && t.searched && s.found && s.filtered) ||
                    (t.filtered && !t.searched && s.filtered) ||
                    (!t.filtered && t.searched && s.found) ||
                    (!t.filtered && !t.searched)
                  );
                }),
                (this.visible = function () {
                  return !(!s.elm || s.elm.parentNode != t.list);
                }),
                (function (e, n, r) {
                  if (void 0 === n) r ? s.values(e, r) : s.values(e);
                  else {
                    s.elm = n;
                    var i = t.templater.get(s, e);
                    s.values(i);
                  }
                })(e, n, r);
            };
          };
        },
        "./src/pagination.js": function (t, e, n) {
          var r = n("./src/utils/classes.js"),
            s = n("./src/utils/events.js"),
            i = n("./src/index.js");
          t.exports = function (t) {
            var e = !1,
              n = function (n, s) {
                if (t.page < 1)
                  return (
                    (t.listContainer.style.display = "none"), void (e = !0)
                  );
                e && (t.listContainer.style.display = "block");
                var i,
                  o = t.matchingItems.length,
                  l = t.i,
                  c = t.page,
                  u = Math.ceil(o / c),
                  p = Math.ceil(l / c),
                  d = s.innerWindow || 2,
                  f = s.left || s.outerWindow || 0,
                  h = s.right || s.outerWindow || 0;
                (h = u - h), n.clear();
                for (var m = 1; m <= u; m++) {
                  var g = p === m ? "active" : "";
                  a.number(m, f, h, p, d)
                    ? ((i = n.add({ page: m, dotted: !1 })[0]),
                      g && r(i.elm).add(g),
                      i.elm.firstChild.setAttribute("data-i", m),
                      i.elm.firstChild.setAttribute("data-page", c))
                    : a.dotted(n, m, f, h, p, d, n.size()) &&
                      ((i = n.add({ page: "...", dotted: !0 })[0]),
                      r(i.elm).add("disabled"));
                }
              },
              a = {
                number: function (t, e, n, r, s) {
                  return (
                    this.left(t, e) ||
                    this.right(t, n) ||
                    this.innerWindow(t, r, s)
                  );
                },
                left: function (t, e) {
                  return t <= e;
                },
                right: function (t, e) {
                  return t > e;
                },
                innerWindow: function (t, e, n) {
                  return t >= e - n && t <= e + n;
                },
                dotted: function (t, e, n, r, s, i, a) {
                  return (
                    this.dottedLeft(t, e, n, r, s, i) ||
                    this.dottedRight(t, e, n, r, s, i, a)
                  );
                },
                dottedLeft: function (t, e, n, r, s, i) {
                  return (
                    e == n + 1 &&
                    !this.innerWindow(e, s, i) &&
                    !this.right(e, r)
                  );
                },
                dottedRight: function (t, e, n, r, s, i, a) {
                  return (
                    !t.items[a - 1].values().dotted &&
                    e == r &&
                    !this.innerWindow(e, s, i) &&
                    !this.right(e, r)
                  );
                },
              };
            return function (e) {
              var r = new i(t.listContainer.id, {
                listClass: e.paginationClass || "pagination",
                item: e.item || "<li><a class='page' href='#'></a></li>",
                valueNames: ["page", "dotted"],
                searchClass: "pagination-search-that-is-not-supposed-to-exist",
                sortClass: "pagination-sort-that-is-not-supposed-to-exist",
              });
              s.bind(r.listContainer, "click", function (e) {
                var n = e.target || e.srcElement,
                  r = t.utils.getAttribute(n, "data-page"),
                  s = t.utils.getAttribute(n, "data-i");
                s && t.show((s - 1) * r + 1, r);
              }),
                t.on("updated", function () {
                  n(r, e);
                }),
                n(r, e);
            };
          };
        },
        "./src/parse.js": function (t, e, n) {
          t.exports = function (t) {
            var e = n("./src/item.js")(t),
              r = function (n, r) {
                for (var s = 0, i = n.length; s < i; s++)
                  t.items.push(new e(r, n[s]));
              },
              s = function e(n, s) {
                var i = n.splice(0, 50);
                r(i, s),
                  n.length > 0
                    ? setTimeout(function () {
                        e(n, s);
                      }, 1)
                    : (t.update(), t.trigger("parseComplete"));
              };
            return (
              (t.handlers.parseComplete = t.handlers.parseComplete || []),
              function () {
                var e = (function (t) {
                    for (
                      var e = t.childNodes, n = [], r = 0, s = e.length;
                      r < s;
                      r++
                    )
                      void 0 === e[r].data && n.push(e[r]);
                    return n;
                  })(t.list),
                  n = t.valueNames;
                t.indexAsync ? s(e, n) : r(e, n);
              }
            );
          };
        },
        "./src/search.js": function (t) {
          t.exports = function (t) {
            var e,
              n,
              r,
              s = {
                resetList: function () {
                  (t.i = 1), t.templater.clear(), (r = void 0);
                },
                setOptions: function (t) {
                  2 == t.length && t[1] instanceof Array
                    ? (e = t[1])
                    : 2 == t.length && "function" == typeof t[1]
                    ? ((e = void 0), (r = t[1]))
                    : 3 == t.length
                    ? ((e = t[1]), (r = t[2]))
                    : (e = void 0);
                },
                setColumns: function () {
                  0 !== t.items.length &&
                    void 0 === e &&
                    (e =
                      void 0 === t.searchColumns
                        ? s.toArray(t.items[0].values())
                        : t.searchColumns);
                },
                setSearchString: function (e) {
                  (e = (e = t.utils.toString(e).toLowerCase()).replace(
                    /[-[\]{}()*+?.,\\^$|#]/g,
                    "\\$&"
                  )),
                    (n = e);
                },
                toArray: function (t) {
                  var e = [];
                  for (var n in t) e.push(n);
                  return e;
                },
              },
              i = function () {
                for (
                  var r, s = [], i = n;
                  null !== (r = i.match(/"([^"]+)"/));

                )
                  s.push(r[1]),
                    (i =
                      i.substring(0, r.index) +
                      i.substring(r.index + r[0].length));
                (i = i.trim()).length && (s = s.concat(i.split(/\s+/)));
                for (var a = 0, o = t.items.length; a < o; a++) {
                  var l = t.items[a];
                  if (((l.found = !1), s.length)) {
                    for (var c = 0, u = s.length; c < u; c++) {
                      for (var p = !1, d = 0, f = e.length; d < f; d++) {
                        var h = l.values(),
                          m = e[d];
                        if (
                          Object.prototype.hasOwnProperty.call(h, m) &&
                          void 0 !== h[m] &&
                          null !== h[m] &&
                          -1 !==
                            ("string" != typeof h[m] ? h[m].toString() : h[m])
                              .toLowerCase()
                              .indexOf(s[c])
                        ) {
                          p = !0;
                          break;
                        }
                      }
                      if (!p) break;
                    }
                    l.found = p;
                  }
                }
              },
              a = function () {
                t.reset.search(), (t.searched = !1);
              },
              o = function (o) {
                return (
                  t.trigger("searchStart"),
                  s.resetList(),
                  s.setSearchString(o),
                  s.setOptions(arguments),
                  s.setColumns(),
                  "" === n ? a() : ((t.searched = !0), r ? r(n, e) : i()),
                  t.update(),
                  t.trigger("searchComplete"),
                  t.visibleItems
                );
              };
            return (
              (t.handlers.searchStart = t.handlers.searchStart || []),
              (t.handlers.searchComplete = t.handlers.searchComplete || []),
              t.utils.events.bind(
                t.utils.getByClass(t.listContainer, t.searchClass),
                "keyup",
                t.utils.events.debounce(function (e) {
                  var n = e.target || e.srcElement;
                  ("" === n.value && !t.searched) || o(n.value);
                }, t.searchDelay)
              ),
              t.utils.events.bind(
                t.utils.getByClass(t.listContainer, t.searchClass),
                "input",
                function (t) {
                  "" === (t.target || t.srcElement).value && o("");
                }
              ),
              o
            );
          };
        },
        "./src/sort.js": function (t) {
          t.exports = function (t) {
            var e = {
                els: void 0,
                clear: function () {
                  for (var n = 0, r = e.els.length; n < r; n++)
                    t.utils.classes(e.els[n]).remove("asc"),
                      t.utils.classes(e.els[n]).remove("desc");
                },
                getOrder: function (e) {
                  var n = t.utils.getAttribute(e, "data-order");
                  return "asc" == n || "desc" == n
                    ? n
                    : t.utils.classes(e).has("desc")
                    ? "asc"
                    : t.utils.classes(e).has("asc")
                    ? "desc"
                    : "asc";
                },
                getInSensitive: function (e, n) {
                  var r = t.utils.getAttribute(e, "data-insensitive");
                  n.insensitive = "false" !== r;
                },
                setOrder: function (n) {
                  for (var r = 0, s = e.els.length; r < s; r++) {
                    var i = e.els[r];
                    if (t.utils.getAttribute(i, "data-sort") === n.valueName) {
                      var a = t.utils.getAttribute(i, "data-order");
                      "asc" == a || "desc" == a
                        ? a == n.order && t.utils.classes(i).add(n.order)
                        : t.utils.classes(i).add(n.order);
                    }
                  }
                },
              },
              n = function () {
                t.trigger("sortStart");
                var n = {},
                  r =
                    arguments[0].currentTarget ||
                    arguments[0].srcElement ||
                    void 0;
                r
                  ? ((n.valueName = t.utils.getAttribute(r, "data-sort")),
                    e.getInSensitive(r, n),
                    (n.order = e.getOrder(r)))
                  : (((n = arguments[1] || n).valueName = arguments[0]),
                    (n.order = n.order || "asc"),
                    (n.insensitive =
                      void 0 === n.insensitive || n.insensitive)),
                  e.clear(),
                  e.setOrder(n);
                var s,
                  i = n.sortFunction || t.sortFunction || null,
                  a = "desc" === n.order ? -1 : 1;
                (s = i
                  ? function (t, e) {
                      return i(t, e, n) * a;
                    }
                  : function (e, r) {
                      var s = t.utils.naturalSort;
                      return (
                        (s.alphabet = t.alphabet || n.alphabet || void 0),
                        !s.alphabet &&
                          n.insensitive &&
                          (s = t.utils.naturalSort.caseInsensitive),
                        s(e.values()[n.valueName], r.values()[n.valueName]) * a
                      );
                    }),
                  t.items.sort(s),
                  t.update(),
                  t.trigger("sortComplete");
              };
            return (
              (t.handlers.sortStart = t.handlers.sortStart || []),
              (t.handlers.sortComplete = t.handlers.sortComplete || []),
              (e.els = t.utils.getByClass(t.listContainer, t.sortClass)),
              t.utils.events.bind(e.els, "click", n),
              t.on("searchStart", e.clear),
              t.on("filterStart", e.clear),
              n
            );
          };
        },
        "./src/templater.js": function (t) {
          var e = function (t) {
            var e,
              n = this,
              r = function (t) {
                if ("string" == typeof t) {
                  if (/<tr[\s>]/g.exec(t)) {
                    var e = document.createElement("tbody");
                    return (e.innerHTML = t), e.firstElementChild;
                  }
                  if (-1 !== t.indexOf("<")) {
                    var n = document.createElement("div");
                    return (n.innerHTML = t), n.firstElementChild;
                  }
                }
              },
              s = function (e, n, r) {
                var s = void 0,
                  i = (function (e) {
                    for (var n = 0, r = t.valueNames.length; n < r; n++) {
                      var s = t.valueNames[n];
                      if (s.data) {
                        for (var i = s.data, a = 0, o = i.length; a < o; a++)
                          if (i[a] === e) return { data: e };
                      } else {
                        if (s.attr && s.name && s.name == e) return s;
                        if (s === e) return e;
                      }
                    }
                  })(n);
                i &&
                  (i.data
                    ? e.elm.setAttribute("data-" + i.data, r)
                    : i.attr && i.name
                    ? (s = t.utils.getByClass(e.elm, i.name, !0)) &&
                      s.setAttribute(i.attr, r)
                    : (s = t.utils.getByClass(e.elm, i, !0)) &&
                      (s.innerHTML = r));
              };
            (this.get = function (e, r) {
              n.create(e);
              for (var s = {}, i = 0, a = r.length; i < a; i++) {
                var o = void 0,
                  l = r[i];
                if (l.data)
                  for (var c = 0, u = l.data.length; c < u; c++)
                    s[l.data[c]] = t.utils.getAttribute(
                      e.elm,
                      "data-" + l.data[c]
                    );
                else
                  l.attr && l.name
                    ? ((o = t.utils.getByClass(e.elm, l.name, !0)),
                      (s[l.name] = o ? t.utils.getAttribute(o, l.attr) : ""))
                    : ((o = t.utils.getByClass(e.elm, l, !0)),
                      (s[l] = o ? o.innerHTML : ""));
              }
              return s;
            }),
              (this.set = function (t, e) {
                if (!n.create(t))
                  for (var r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && s(t, r, e[r]);
              }),
              (this.create = function (t) {
                return (
                  void 0 === t.elm &&
                  ((t.elm = e(t.values())), n.set(t, t.values()), !0)
                );
              }),
              (this.remove = function (e) {
                e.elm.parentNode === t.list && t.list.removeChild(e.elm);
              }),
              (this.show = function (e) {
                n.create(e), t.list.appendChild(e.elm);
              }),
              (this.hide = function (e) {
                void 0 !== e.elm &&
                  e.elm.parentNode === t.list &&
                  t.list.removeChild(e.elm);
              }),
              (this.clear = function () {
                if (t.list.hasChildNodes())
                  for (; t.list.childNodes.length >= 1; )
                    t.list.removeChild(t.list.firstChild);
              }),
              (function () {
                var n;
                if ("function" != typeof t.item) {
                  if (
                    !(n =
                      "string" == typeof t.item
                        ? -1 === t.item.indexOf("<")
                          ? document.getElementById(t.item)
                          : r(t.item)
                        : (function () {
                            for (
                              var e = t.list.childNodes, n = 0, r = e.length;
                              n < r;
                              n++
                            )
                              if (void 0 === e[n].data)
                                return e[n].cloneNode(!0);
                          })())
                  )
                    throw new Error(
                      "The list needs to have at least one item on init otherwise you'll have to add a template."
                    );
                  (n = (function (e, n) {
                    var r = e.cloneNode(!0);
                    r.removeAttribute("id");
                    for (var s = 0, i = n.length; s < i; s++) {
                      var a = void 0,
                        o = n[s];
                      if (o.data)
                        for (var l = 0, c = o.data.length; l < c; l++)
                          r.setAttribute("data-" + o.data[l], "");
                      else
                        o.attr && o.name
                          ? (a = t.utils.getByClass(r, o.name, !0)) &&
                            a.setAttribute(o.attr, "")
                          : (a = t.utils.getByClass(r, o, !0)) &&
                            (a.innerHTML = "");
                    }
                    return r;
                  })(n, t.valueNames)),
                    (e = function () {
                      return n.cloneNode(!0);
                    });
                } else
                  e = function (e) {
                    var n = t.item(e);
                    return r(n);
                  };
              })();
          };
          t.exports = function (t) {
            return new e(t);
          };
        },
        "./src/utils/classes.js": function (t, e, n) {
          var r = n("./src/utils/index-of.js"),
            s = /\s+/;
          function i(t) {
            if (!t || !t.nodeType)
              throw new Error("A DOM element reference is required");
            (this.el = t), (this.list = t.classList);
          }
          Object.prototype.toString,
            (t.exports = function (t) {
              return new i(t);
            }),
            (i.prototype.add = function (t) {
              if (this.list) return this.list.add(t), this;
              var e = this.array();
              return (
                ~r(e, t) || e.push(t), (this.el.className = e.join(" ")), this
              );
            }),
            (i.prototype.remove = function (t) {
              if (this.list) return this.list.remove(t), this;
              var e = this.array(),
                n = r(e, t);
              return (
                ~n && e.splice(n, 1), (this.el.className = e.join(" ")), this
              );
            }),
            (i.prototype.toggle = function (t, e) {
              return this.list
                ? (void 0 !== e
                    ? e !== this.list.toggle(t, e) && this.list.toggle(t)
                    : this.list.toggle(t),
                  this)
                : (void 0 !== e
                    ? e
                      ? this.add(t)
                      : this.remove(t)
                    : this.has(t)
                    ? this.remove(t)
                    : this.add(t),
                  this);
            }),
            (i.prototype.array = function () {
              var t = (this.el.getAttribute("class") || "")
                .replace(/^\s+|\s+$/g, "")
                .split(s);
              return "" === t[0] && t.shift(), t;
            }),
            (i.prototype.has = i.prototype.contains =
              function (t) {
                return this.list
                  ? this.list.contains(t)
                  : !!~r(this.array(), t);
              });
        },
        "./src/utils/events.js": function (t, e, n) {
          var r = window.addEventListener ? "addEventListener" : "attachEvent",
            s = window.removeEventListener
              ? "removeEventListener"
              : "detachEvent",
            i = "addEventListener" !== r ? "on" : "",
            a = n("./src/utils/to-array.js");
          (e.bind = function (t, e, n, s) {
            for (var o = 0, l = (t = a(t)).length; o < l; o++)
              t[o][r](i + e, n, s || !1);
          }),
            (e.unbind = function (t, e, n, r) {
              for (var o = 0, l = (t = a(t)).length; o < l; o++)
                t[o][s](i + e, n, r || !1);
            }),
            (e.debounce = function (t, e, n) {
              var r;
              return e
                ? function () {
                    var s = this,
                      i = arguments,
                      a = function () {
                        (r = null), n || t.apply(s, i);
                      },
                      o = n && !r;
                    clearTimeout(r), (r = setTimeout(a, e)), o && t.apply(s, i);
                  }
                : t;
            });
        },
        "./src/utils/extend.js": function (t) {
          t.exports = function (t) {
            for (
              var e, n = Array.prototype.slice.call(arguments, 1), r = 0;
              (e = n[r]);
              r++
            )
              if (e) for (var s in e) t[s] = e[s];
            return t;
          };
        },
        "./src/utils/fuzzy.js": function (t) {
          t.exports = function (t, e, n) {
            var r = n.location || 0,
              s = n.distance || 100,
              i = n.threshold || 0.4;
            if (e === t) return !0;
            if (e.length > 32) return !1;
            var a = r,
              o = (function () {
                var t,
                  n = {};
                for (t = 0; t < e.length; t++) n[e.charAt(t)] = 0;
                for (t = 0; t < e.length; t++)
                  n[e.charAt(t)] |= 1 << (e.length - t - 1);
                return n;
              })();
            function l(t, n) {
              var r = t / e.length,
                i = Math.abs(a - n);
              return s ? r + i / s : i ? 1 : r;
            }
            var c = i,
              u = t.indexOf(e, a);
            -1 != u &&
              ((c = Math.min(l(0, u), c)),
              -1 != (u = t.lastIndexOf(e, a + e.length)) &&
                (c = Math.min(l(0, u), c)));
            var p,
              d,
              f = 1 << (e.length - 1);
            u = -1;
            for (var h, m = e.length + t.length, g = 0; g < e.length; g++) {
              for (p = 0, d = m; p < d; )
                l(g, a + d) <= c ? (p = d) : (m = d),
                  (d = Math.floor((m - p) / 2 + p));
              m = d;
              var v = Math.max(1, a - d + 1),
                y = Math.min(a + d, t.length) + e.length,
                b = Array(y + 2);
              b[y + 1] = (1 << g) - 1;
              for (var _ = y; _ >= v; _--) {
                var w = o[t.charAt(_ - 1)];
                if (
                  ((b[_] =
                    0 === g
                      ? ((b[_ + 1] << 1) | 1) & w
                      : (((b[_ + 1] << 1) | 1) & w) |
                        ((h[_ + 1] | h[_]) << 1) |
                        1 |
                        h[_ + 1]),
                  b[_] & f)
                ) {
                  var S = l(g, _ - 1);
                  if (S <= c) {
                    if (((c = S), !((u = _ - 1) > a))) break;
                    v = Math.max(1, 2 * a - u);
                  }
                }
              }
              if (l(g + 1, a) > c) break;
              h = b;
            }
            return !(u < 0);
          };
        },
        "./src/utils/get-attribute.js": function (t) {
          t.exports = function (t, e) {
            var n = (t.getAttribute && t.getAttribute(e)) || null;
            if (!n)
              for (var r = t.attributes, s = r.length, i = 0; i < s; i++)
                void 0 !== r[i] && r[i].nodeName === e && (n = r[i].nodeValue);
            return n;
          };
        },
        "./src/utils/get-by-class.js": function (t) {
          t.exports = function (t, e, n, r) {
            return ((r = r || {}).test && r.getElementsByClassName) ||
              (!r.test && document.getElementsByClassName)
              ? (function (t, e, n) {
                  return n
                    ? t.getElementsByClassName(e)[0]
                    : t.getElementsByClassName(e);
                })(t, e, n)
              : (r.test && r.querySelector) ||
                (!r.test && document.querySelector)
              ? (function (t, e, n) {
                  return (
                    (e = "." + e),
                    n ? t.querySelector(e) : t.querySelectorAll(e)
                  );
                })(t, e, n)
              : (function (t, e, n) {
                  for (
                    var r = [],
                      s = t.getElementsByTagName("*"),
                      i = s.length,
                      a = new RegExp("(^|\\s)" + e + "(\\s|$)"),
                      o = 0,
                      l = 0;
                    o < i;
                    o++
                  )
                    if (a.test(s[o].className)) {
                      if (n) return s[o];
                      (r[l] = s[o]), l++;
                    }
                  return r;
                })(t, e, n);
          };
        },
        "./src/utils/index-of.js": function (t) {
          var e = [].indexOf;
          t.exports = function (t, n) {
            if (e) return t.indexOf(n);
            for (var r = 0, s = t.length; r < s; ++r) if (t[r] === n) return r;
            return -1;
          };
        },
        "./src/utils/to-array.js": function (t) {
          t.exports = function (t) {
            if (void 0 === t) return [];
            if (null === t) return [null];
            if (t === window) return [window];
            if ("string" == typeof t) return [t];
            if (
              (function (t) {
                return "[object Array]" === Object.prototype.toString.call(t);
              })(t)
            )
              return t;
            if ("number" != typeof t.length) return [t];
            if ("function" == typeof t && t instanceof Function) return [t];
            for (var e = [], n = 0, r = t.length; n < r; n++)
              (Object.prototype.hasOwnProperty.call(t, n) || n in t) &&
                e.push(t[n]);
            return e.length ? e : [];
          };
        },
        "./src/utils/to-string.js": function (t) {
          t.exports = function (t) {
            return (t =
              null === (t = void 0 === t ? "" : t) ? "" : t).toString();
          };
        },
        "./node_modules/string-natural-compare/natural-compare.js": function (
          t
        ) {
          "use strict";
          var e,
            n,
            r = 0;
          function s(t) {
            return t >= 48 && t <= 57;
          }
          function i(t, e) {
            for (
              var i = (t += "").length, a = (e += "").length, o = 0, l = 0;
              o < i && l < a;

            ) {
              var c = t.charCodeAt(o),
                u = e.charCodeAt(l);
              if (s(c)) {
                if (!s(u)) return c - u;
                for (var p = o, d = l; 48 === c && ++p < i; )
                  c = t.charCodeAt(p);
                for (; 48 === u && ++d < a; ) u = e.charCodeAt(d);
                for (var f = p, h = d; f < i && s(t.charCodeAt(f)); ) ++f;
                for (; h < a && s(e.charCodeAt(h)); ) ++h;
                var m = f - p - h + d;
                if (m) return m;
                for (; p < f; )
                  if ((m = t.charCodeAt(p++) - e.charCodeAt(d++))) return m;
                (o = f), (l = h);
              } else {
                if (c !== u)
                  return c < r && u < r && -1 !== n[c] && -1 !== n[u]
                    ? n[c] - n[u]
                    : c - u;
                ++o, ++l;
              }
            }
            return o >= i && l < a && i >= a
              ? -1
              : l >= a && o < i && a >= i
              ? 1
              : i - a;
          }
          (i.caseInsensitive = i.i =
            function (t, e) {
              return i(("" + t).toLowerCase(), ("" + e).toLowerCase());
            }),
            Object.defineProperties(i, {
              alphabet: {
                get: function () {
                  return e;
                },
                set: function (t) {
                  n = [];
                  var s = 0;
                  if ((e = t)) for (; s < e.length; s++) n[e.charCodeAt(s)] = s;
                  for (r = n.length, s = 0; s < r; s++)
                    void 0 === n[s] && (n[s] = -1);
                },
              },
            }),
            (t.exports = i);
        },
      },
      e = {};
    return (function n(r) {
      if (e[r]) return e[r].exports;
      var s = (e[r] = { exports: {} });
      return t[r](s, s.exports, n), s.exports;
    })("./src/index.js");
  })();
var _self =
    "undefined" != typeof window
      ? window
      : "undefined" != typeof WorkerGlobalScope
      ? self
      : {},
  Prism = (function () {
    var t = /\blang(?:uage)?-(\w+)\b/i,
      e = 0,
      n = (_self.Prism = {
        manual: _self.Prism && _self.Prism.manual,
        disableWorkerMessageHandler:
          _self.Prism && _self.Prism.disableWorkerMessageHandler,
        util: {
          encode: function (t) {
            return t instanceof r
              ? new r(t.type, n.util.encode(t.content), t.alias)
              : "Array" === n.util.type(t)
              ? t.map(n.util.encode)
              : t
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/\u00a0/g, " ");
          },
          type: function (t) {
            return Object.prototype.toString
              .call(t)
              .match(/\[object (\w+)\]/)[1];
          },
          objId: function (t) {
            return (
              t.__id || Object.defineProperty(t, "__id", { value: ++e }), t.__id
            );
          },
          clone: function (t, e) {
            var r = n.util.type(t);
            switch (((e = e || {}), r)) {
              case "Object":
                if (e[n.util.objId(t)]) return e[n.util.objId(t)];
                var s = {};
                for (var i in ((e[n.util.objId(t)] = s), t))
                  Object.prototype.hasOwnProperty.call(t, n) &&
                    (s[i] = n.util.clone(t[i], e));
                return s;
              case "Array":
                if (e[n.util.objId(t)]) return e[n.util.objId(t)];
                s = [];
                return (
                  (e[n.util.objId(t)] = s),
                  t.forEach(function (t, r) {
                    s[r] = n.util.clone(t, e);
                  }),
                  s
                );
            }
            return t;
          },
        },
        languages: {
          extend: function (t, e) {
            var r = n.util.clone(n.languages[t]);
            for (var s in e) r[s] = e[s];
            return r;
          },
          insertBefore: function (t, e, r, s) {
            var i = (s = s || n.languages)[t];
            if (2 == arguments.length) {
              for (var a in (r = arguments[1]))
                Object.prototype.hasOwnProperty.call(r, a) && (i[a] = r[a]);
              return i;
            }
            var o = {};
            for (var l in i)
              if (Object.prototype.hasOwnProperty.call(i, l)) {
                if (l == e)
                  for (a in r)
                    Object.prototype.hasOwnProperty.call(r, a) && (o[a] = r[a]);
                o[l] = i[l];
              }
            return (
              n.languages.DFS(n.languages, function (e, n) {
                n === s[t] && e != t && (this[e] = o);
              }),
              (s[t] = o)
            );
          },
          DFS: function (t, e, r, s) {
            for (var i in ((s = s || {}), t))
              Object.prototype.hasOwnProperty.call(t, n) &&
                (e.call(t, i, t[i], r || i),
                "Object" !== n.util.type(t[i]) || s[n.util.objId(t[i])]
                  ? "Array" !== n.util.type(t[i]) ||
                    s[n.util.objId(t[i])] ||
                    ((s[n.util.objId(t[i])] = !0),
                    n.languages.DFS(t[i], e, i, s))
                  : ((s[n.util.objId(t[i])] = !0),
                    n.languages.DFS(t[i], e, null, s)));
          },
        },
        plugins: {},
        highlightAll: function (t, e) {
          n.highlightAllUnder(document, t, e);
        },
        highlightAllUnder: function (t, e, r) {
          var s = {
            callback: r,
            selector:
              'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
          };
          n.hooks.run("before-highlightall", s);
          for (
            var i, a = s.elements || t.querySelectorAll(s.selector), o = 0;
            (i = a[o++]);

          )
            n.highlightElement(i, !0 === e, s.callback);
        },
        highlightElement: function (e, r, s) {
          for (var i, a, o = e; o && !t.test(o.className); ) o = o.parentNode;
          o &&
            ((i = (o.className.match(t) || ["", ""])[1].toLowerCase()),
            (a = n.languages[i])),
            (e.className =
              e.className.replace(t, "").replace(/\s+/g, " ") +
              " language-" +
              i),
            e.parentNode &&
              ((o = e.parentNode),
              /pre/i.test(o.nodeName) &&
                (o.className =
                  o.className.replace(t, "").replace(/\s+/g, " ") +
                  " language-" +
                  i));
          var l = { element: e, language: i, grammar: a, code: e.textContent };
          if ((n.hooks.run("before-sanity-check", l), !l.code || !l.grammar))
            return (
              l.code &&
                (n.hooks.run("before-highlight", l),
                (l.element.textContent = l.code),
                n.hooks.run("after-highlight", l)),
              void n.hooks.run("complete", l)
            );
          if ((n.hooks.run("before-highlight", l), r && _self.Worker)) {
            var c = new Worker(n.filename);
            (c.onmessage = function (t) {
              (l.highlightedCode = t.data),
                n.hooks.run("before-insert", l),
                (l.element.innerHTML = l.highlightedCode),
                s && s.call(l.element),
                n.hooks.run("after-highlight", l),
                n.hooks.run("complete", l);
            }),
              c.postMessage(
                JSON.stringify({
                  language: l.language,
                  code: l.code,
                  immediateClose: !0,
                })
              );
          } else
            (l.highlightedCode = n.highlight(l.code, l.grammar, l.language)),
              n.hooks.run("before-insert", l),
              (l.element.innerHTML = l.highlightedCode),
              s && s.call(e),
              n.hooks.run("after-highlight", l),
              n.hooks.run("complete", l);
        },
        highlight: function (t, e, s) {
          var i = { code: t, grammar: e, language: s };
          return (
            n.hooks.run("before-tokenize", i),
            (i.tokens = n.tokenize(i.code, i.grammar)),
            n.hooks.run("after-tokenize", i),
            r.stringify(n.util.encode(i.tokens), i.language)
          );
        },
        matchGrammar: function (t, e, r, s, i, a, o) {
          var l = n.Token;
          for (var c in r)
            if (Object.prototype.hasOwnProperty.call(r, c) && r[c]) {
              if (c == o) return;
              var u = r[c];
              u = "Array" === n.util.type(u) ? u : [u];
              for (var p = 0; p < u.length; ++p) {
                var d = u[p],
                  f = d.inside,
                  h = !!d.lookbehind,
                  m = !!d.greedy,
                  g = 0,
                  v = d.alias;
                if (m && !d.pattern.global) {
                  var y = d.pattern.toString().match(/[imuy]*$/)[0];
                  d.pattern = RegExp(d.pattern.source, y + "g");
                }
                d = d.pattern || d;
                for (var b = s, _ = i; b < e.length; _ += e[b].length, ++b) {
                  var w = e[b];
                  if (e.length > t.length) return;
                  if (!(w instanceof l)) {
                    if (m && b != e.length - 1) {
                      if (((d.lastIndex = _), !(T = d.exec(t)))) break;
                      for (
                        var S = T.index + (h ? T[1].length : 0),
                          C = T.index + T[0].length,
                          x = b,
                          k = _,
                          E = e.length;
                        E > x && (C > k || (!e[x].type && !e[x - 1].greedy));
                        ++x
                      )
                        S >= (k += e[x].length) && (++b, (_ = k));
                      if (e[b] instanceof l) continue;
                      (P = x - b), (w = t.slice(_, k)), (T.index -= _);
                    } else {
                      d.lastIndex = 0;
                      var T = d.exec(w),
                        P = 1;
                    }
                    if (T) {
                      h && (g = T[1] ? T[1].length : 0);
                      C = (S = T.index + g) + (T = T[0].slice(g)).length;
                      var M = w.slice(0, S),
                        O = w.slice(C),
                        A = [b, P];
                      M && (++b, (_ += M.length), A.push(M));
                      var j = new l(c, f ? n.tokenize(T, f) : T, v, T, m);
                      if (
                        (A.push(j),
                        O && A.push(O),
                        Array.prototype.splice.apply(e, A),
                        1 != P && n.matchGrammar(t, e, r, b, _, !0, c),
                        a)
                      )
                        break;
                    } else if (a) break;
                  }
                }
              }
            }
        },
        tokenize: function (t, e) {
          var r = [t],
            s = e.rest;
          if (s) {
            for (var i in s) e[i] = s[i];
            delete e.rest;
          }
          return n.matchGrammar(t, r, e, 0, 0, !1), r;
        },
        hooks: {
          all: {},
          add: function (t, e) {
            var r = n.hooks.all;
            (r[t] = r[t] || []), r[t].push(e);
          },
          run: function (t, e) {
            var r = n.hooks.all[t];
            if (r && r.length) for (var s, i = 0; (s = r[i++]); ) s(e);
          },
        },
      }),
      r = (n.Token = function (t, e, n, r, s) {
        (this.type = t),
          (this.content = e),
          (this.alias = n),
          (this.length = 0 | (r || "").length),
          (this.greedy = !!s);
      });
    if (
      ((r.stringify = function (t, e, s) {
        if ("string" == typeof t) return t;
        if ("Array" === n.util.type(t))
          return t
            .map(function (n) {
              return r.stringify(n, e, t);
            })
            .join("");
        var i = {
          type: t.type,
          content: r.stringify(t.content, e, s),
          tag: "span",
          classes: ["token", t.type],
          attributes: {},
          language: e,
          parent: s,
        };
        if (t.alias) {
          var a = "Array" === n.util.type(t.alias) ? t.alias : [t.alias];
          Array.prototype.push.apply(i.classes, a);
        }
        n.hooks.run("wrap", i);
        var o = Object.keys(i.attributes)
          .map(function (t) {
            return (
              t + '="' + (i.attributes[t] || "").replace(/"/g, "&quot;") + '"'
            );
          })
          .join(" ");
        return (
          "<" +
          i.tag +
          ' class="' +
          i.classes.join(" ") +
          '"' +
          (o ? " " + o : "") +
          ">" +
          i.content +
          "</" +
          i.tag +
          ">"
        );
      }),
      !_self.document)
    )
      return _self.addEventListener
        ? (n.disableWorkerMessageHandler ||
            _self.addEventListener(
              "message",
              function (t) {
                var e = JSON.parse(t.data),
                  r = e.language,
                  s = e.code,
                  i = e.immediateClose;
                _self.postMessage(n.highlight(s, n.languages[r], r)),
                  i && _self.close();
              },
              !1
            ),
          _self.Prism)
        : _self.Prism;
    var s =
      document.currentScript ||
      [].slice.call(document.getElementsByTagName("script")).pop();
    return (
      s &&
        ((n.filename = s.src),
        n.manual ||
          s.hasAttribute("data-manual") ||
          ("loading" !== document.readyState
            ? window.requestAnimationFrame
              ? window.requestAnimationFrame(n.highlightAll)
              : window.setTimeout(n.highlightAll, 16)
            : document.addEventListener("DOMContentLoaded", n.highlightAll))),
      _self.Prism
    );
  })();
void 0 !== module && module.exports && (module.exports = Prism),
  "undefined" != typeof global && (global.Prism = Prism),
  (Prism.languages.markup = {
    comment: /<!--[\s\S]*?-->/,
    prolog: /<\?[\s\S]+?\?>/,
    doctype: /<!DOCTYPE[\s\S]+?>/i,
    cdata: /<!\[CDATA\[[\s\S]*?]]>/i,
    tag: {
      pattern:
        /<?(?!\d)[^\s>=$<%]+(?:\s+[^\s>=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*?>/i,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<?[^\s>]+/i,
          inside: { punctuation: /^<?/, namespace: /^[^\s>:]+:/ },
        },
        "attr-value": {
          pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
          inside: {
            punctuation: [/^=/, { pattern: /(^|[^\\])["']/, lookbehind: !0 }],
          },
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>]+/,
          inside: { namespace: /^[^\s>:]+:/ },
        },
      },
    },
    entity: /&#?[\da-z]{1,8};/i,
  }),
  (Prism.languages.markup.tag.inside["attr-value"].inside.entity =
    Prism.languages.markup.entity),
  Prism.hooks.add("wrap", function (t) {
    "entity" === t.type &&
      (t.attributes.title = t.content.replace(/&amp;/, "&"));
  }),
  (Prism.languages.xml = Prism.languages.markup),
  (Prism.languages.html = Prism.languages.markup),
  (Prism.languages.mathml = Prism.languages.markup),
  (Prism.languages.svg = Prism.languages.markup),
  (Prism.languages.css = {
    comment: /\/\*[\s\S]*?\*\//,
    atrule: {
      pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
      inside: { rule: /@[\w-]+/ },
    },
    url: /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
    selector: /[^{}\s][^{};]*?(?=\s*\{)/,
    string: {
      pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0,
    },
    property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
    important: /\B!important\b/i,
    function: /[-a-z0-9]+(?=\()/i,
    punctuation: /[(){};:]/,
  }),
  (Prism.languages.css.atrule.inside.rest = Prism.languages.css),
  Prism.languages.markup &&
    (Prism.languages.insertBefore("markup", "tag", {
      style: {
        pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
        lookbehind: !0,
        inside: Prism.languages.css,
        alias: "language-css",
        greedy: !0,
      },
    }),
    Prism.languages.insertBefore(
      "inside",
      "attr-value",
      {
        "style-attr": {
          pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
          inside: {
            "attr-name": {
              pattern: /^\s*style/i,
              inside: Prism.languages.markup.tag.inside,
            },
            punctuation: /^\s*=\s*['"]|['"]\s*$/,
            "attr-value": { pattern: /.+/i, inside: Prism.languages.css },
          },
          alias: "language-css",
        },
      },
      Prism.languages.markup.tag
    )),
  (Prism.languages.clike = {
    comment: [
      { pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 },
      { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0,
    },
    "class-name": {
      pattern:
        /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
      lookbehind: !0,
      inside: { punctuation: /[.\\]/ },
    },
    keyword:
      /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
    boolean: /\b(?:true|false)\b/,
    function: /[a-z0-9_]+(?=\()/i,
    number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
    punctuation: /[{}[\];(),.:]/,
  }),
  (Prism.languages.javascript = Prism.languages.extend("clike", {
    keyword:
      /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
    number:
      /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    function: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
    operator:
      /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/,
  })),
  Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern:
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)([^\]\r\n]+]|\\.|[^\\\r\n])+[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
      lookbehind: !0,
      greedy: !0,
    },
    "function-variable": {
      pattern:
        /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
      alias: "function",
    },
    constant: /\b[A-Z][A-Z\d_]*\b/,
  }),
  Prism.languages.insertBefore("javascript", "string", {
    "template-string": {
      pattern: /`(?:\\s\S]|[^\\`])*`/,
      greedy: !0,
      inside: {
        interpolation: {
          pattern: /\$\{[^}]+\}/,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation",
            },
            rest: Prism.languages.javascript,
          },
        },
        string: /[\s\S]+/,
      },
    },
  }),
  Prism.languages.markup &&
    Prism.languages.insertBefore("markup", "tag", {
      script: {
        pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
        lookbehind: !0,
        inside: Prism.languages.javascript,
        alias: "language-javascript",
        greedy: !0,
      },
    }),
  (Prism.languages.js = Prism.languages.javascript),
  (Prism.languages.css.selector = {
    pattern: /[^{}\s][^{}]*(?=\s*\{)/,
    inside: {
      "pseudo-element":
        /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
      "pseudo-class": /:[-\w]+(?:\(.*\))?/,
      class: /\.[-:.\w]+/,
      id: /#[-:.\w]+/,
      attribute: /\[[^\]]+\]/,
    },
  }),
  Prism.languages.insertBefore("css", "function", {
    hexcode: /#[\da-f]{3,8}/i,
    entity: /\\[\da-f]{1,8}/i,
    number: /[\d%.]+/,
  }),
  (Prism.languages.git = {
    comment: /^#.*/m,
    deleted: /^[-–].*/m,
    inserted: /^\+.*/m,
    string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m,
    command: { pattern: /^.*\$ git .*$/m, inside: { parameter: /\s--?\w+/m } },
    coord: /^@@.*@@$/m,
    commit_sha1: /^commit \w{40}$/m,
  }),
  (Prism.languages.icon = {
    comment: /#.*/,
    string: {
      pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
      greedy: !0,
    },
    number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
    "builtin-keyword": {
      pattern:
        /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
      alias: "variable",
    },
    directive: { pattern: /\$\w+/, alias: "builtin" },
    keyword:
      /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
    function: /(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
    operator:
      /[+-]:(?!=)|(?:[?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
    punctuation: /[\](){},;]/,
  }),
  (Prism.languages.json = {
    property: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
    string: { pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, greedy: !0 },
    number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
    punctuation: /[{}[\]);,]/,
    operator: /:/g,
    boolean: /\b(?:true|false)\b/i,
    null: /\bnull\b/i,
  }),
  (Prism.languages.jsonp = Prism.languages.json),
  (function (t) {
    (t.languages.sass = t.languages.extend("css", {
      comment: {
        pattern: /^([ \t]*)[*].*(?:(?:\r?\n|\r)\1[ \t]+.+)*/m,
        lookbehind: !0,
      },
    })),
      t.languages.insertBefore("sass", "atrule", {
        "atrule-line": {
          pattern: /^(?:[ \t]*)[@+=].+/m,
          inside: { atrule: /(?:@[\w-]+|[+=])/m },
        },
      }),
      delete t.languages.sass.atrule;
    var e = /\$[-\w]+|#\{\$[-\w]+\}/,
      n = [
        /[+*%]|[=!]=|<=?|>=?|\b(?:and|or|not)\b/,
        { pattern: /(\s+)-(?=\s)/, lookbehind: !0 },
      ];
    t.languages.insertBefore("sass", "property", {
      "variable-line": {
        pattern: /^[ \t]*\$.+/m,
        inside: { punctuation: /:/, variable: e, operator: n },
      },
      "property-line": {
        pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s]+.*)/m,
        inside: {
          property: [
            /[^:\s]+(?=\s*:)/,
            { pattern: /(:)[^:\s]+/, lookbehind: !0 },
          ],
          punctuation: /:/,
          variable: e,
          operator: n,
          important: t.languages.sass.important,
        },
      },
    }),
      delete t.languages.sass.property,
      delete t.languages.sass.important,
      delete t.languages.sass.selector,
      t.languages.insertBefore("sass", "punctuation", {
        selector: {
          pattern:
            /([ \t]*)\S(?:,?[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,?[^,\r\n]+)*)*/,
          lookbehind: !0,
        },
      });
  })(Prism),
  (Prism.languages.scss = Prism.languages.extend("css", {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: !0,
    },
    atrule: {
      pattern: /@[\w-]+(?:\([^()]+\)|[^(])*?(?=\s+[{;])/,
      inside: { rule: /@[\w-]+/ },
    },
    url: /(?:[-a-z]+-)*url(?=\()/i,
    selector: {
      pattern:
        /(?=\S)[^@;{}()]?(?:[^@;{}()]|&|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}]+[:{][^}]+))/m,
      inside: {
        parent: { pattern: /&/, alias: "important" },
        placeholder: /%[-\w]+/,
        variable: /\$[-\w]+|#\{\$[-\w]+\}/,
      },
    },
  })),
  Prism.languages.insertBefore("scss", "atrule", {
    keyword: [
      /@(?:if|else(?: if)?|for|each|while|import|extend|debug|warn|mixin|include|function|return|content)/i,
      { pattern: /( +)(?:from|through)(?= )/, lookbehind: !0 },
    ],
  }),
  (Prism.languages.scss.property = {
    pattern: /(?:[\w-]|\$[-\w]+|#\{\$[-\w]+\})+(?=\s*:)/i,
    inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ },
  }),
  Prism.languages.insertBefore("scss", "important", {
    variable: /\$[-\w]+|#\{\$[-\w]+\}/,
  }),
  Prism.languages.insertBefore("scss", "function", {
    placeholder: { pattern: /%[-\w]+/, alias: "selector" },
    statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" },
    boolean: /\b(?:true|false)\b/,
    null: /\bnull\b/,
    operator: {
      pattern: /(\s)(?:[-+*%]|[=!]=|<=?|>=?|and|or|not)(?=\s)/,
      lookbehind: !0,
    },
  }),
  (Prism.languages.scss.atrule.inside.rest = Prism.languages.scss),
  (function () {
    if ("undefined" != typeof self && self.Prism && self.document) {
      var t = [],
        e = {},
        n = function () {};
      Prism.plugins.toolbar = {};
      var r = (Prism.plugins.toolbar.registerButton = function (n, r) {
          var s;
          (s =
            "function" == typeof r
              ? r
              : function (t) {
                  var e;
                  return (
                    "function" == typeof r.onClick
                      ? (((e = document.createElement("button")).type =
                          "button"),
                        e.addEventListener("click", function () {
                          r.onClick.call(this, t);
                        }))
                      : "string" == typeof r.url
                      ? ((e = document.createElement("a")).href = r.url)
                      : (e = document.createElement("span")),
                    (e.textContent = r.text),
                    e
                  );
                }),
            t.push((e[n] = s));
        }),
        s = (Prism.plugins.toolbar.hook = function (r) {
          var s = r.element.parentNode;
          if (
            s &&
            /pre/i.test(s.nodeName) &&
            !s.parentNode.classList.contains("code-toolbar")
          ) {
            var i = document.createElement("div");
            i.classList.add("code-toolbar"),
              s.parentNode.insertBefore(i, s),
              i.appendChild(s);
            var a = document.createElement("div");
            a.classList.add("toolbar"),
              document.body.hasAttribute("data-toolbar-order") &&
                (t = document.body
                  .getAttribute("data-toolbar-order")
                  .split(",")
                  .map(function (t) {
                    return e[t] || n;
                  })),
              t.forEach(function (t) {
                var e = t(r);
                if (e) {
                  var n = document.createElement("div");
                  n.classList.add("toolbar-item"),
                    n.appendChild(e),
                    a.appendChild(n);
                }
              }),
              i.appendChild(a);
          }
        });
      r("label", function (t) {
        var e = t.element.parentNode;
        if (e && /pre/i.test(e.nodeName) && e.hasAttribute("data-label")) {
          var n,
            r,
            s = e.getAttribute("data-label");
          try {
            r = document.querySelector("template#" + s);
          } catch (t) {
            console.log(t);
          }
          return (
            r
              ? (n = r.content)
              : (e.hasAttribute("data-url")
                  ? ((n = document.createElement("a")).href =
                      e.getAttribute("data-url"))
                  : (n = document.createElement("span")),
                (n.textContent = s)),
            n
          );
        }
      }),
        Prism.hooks.add("complete", s);
    }
  })(),
  (function () {
    function t(t) {
      this.defaults = r({}, t);
    }
    function e(t) {
      return t.replace(/-(\w)/g, function (t, e) {
        return e.toUpperCase();
      });
    }
    function n(t) {
      for (var e = 0, n = 0; n < t.length; ++n)
        t.charCodeAt(n) == "\t".charCodeAt(0) && (e += 3);
      return t.length + e;
    }
    var r =
      Object.assign ||
      function (t, e) {
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return t;
      };
    (t.prototype = {
      setDefaults: function (t) {
        this.defaults = r(this.defaults, t);
      },
      normalize: function (t, n) {
        for (var s in (n = r(this.defaults, n))) {
          var i = e(s);
          "normalize" !== s &&
            "setDefaults" !== i &&
            n[s] &&
            this[i] &&
            (t = this[i].call(this, t, n[s]));
        }
        return t;
      },
      leftTrim: function (t) {
        return t.replace(/^\s+/, "");
      },
      rightTrim: function (t) {
        return t.replace(/\s+$/, "");
      },
      tabsToSpaces: function (t, e) {
        return (e = 0 | e || 4), t.replace(/\t/g, new Array(++e).join(" "));
      },
      spacesToTabs: function (t, e) {
        return (
          (e = 0 | e || 4), t.replace(new RegExp(" {" + e + "}", "g"), "\t")
        );
      },
      removeTrailing: function (t) {
        return t.replace(/\s*?$/gm, "");
      },
      removeInitialLineFeed: function (t) {
        return t.replace(/^(?:\r?\n|\r)/, "");
      },
      removeIndent: function (t) {
        var e = t.match(/^[^\S\n\r]*(?=\S)/gm);
        return e && e[0].length
          ? (e.sort(function (t, e) {
              return t.length - e.length;
            }),
            e[0].length ? t.replace(new RegExp("^" + e[0], "gm"), "") : t)
          : t;
      },
      indent: function (t, e) {
        return t.replace(
          /^[^\S\n\r]*(?=\S)/gm,
          new Array(++e).join("\t") + "$&"
        );
      },
      breakLines: function (t, e) {
        e = !0 === e ? 80 : 0 | e || 80;
        for (var r = t.split("\n"), s = 0; s < r.length; ++s)
          if (!(n(r[s]) <= e)) {
            for (
              var i = r[s].split(/(\s+)/g), a = 0, o = 0;
              o < i.length;
              ++o
            ) {
              var l = n(i[o]);
              (a += l) > e && ((i[o] = "\n" + i[o]), (a = l));
            }
            r[s] = i.join("");
          }
        return r.join("\n");
      },
    }),
      void 0 !== module && module.exports && (module.exports = t),
      void 0 !== Prism &&
        ((Prism.plugins.NormalizeWhitespace = new t({
          "remove-trailing": !0,
          "remove-indent": !0,
          "left-trim": !0,
          "right-trim": !0,
        })),
        Prism.hooks.add("before-sanity-check", function (t) {
          var e = Prism.plugins.NormalizeWhitespace;
          if (!t.settings || !1 !== t.settings["whitespace-normalization"]) {
            if ((!t.element || !t.element.parentNode) && t.code)
              return void (t.code = e.normalize(t.code, t.settings));
            var n = t.element.parentNode,
              r = /\bno-whitespace-normalization\b/;
            if (
              t.code &&
              n &&
              "pre" === n.nodeName.toLowerCase() &&
              !r.test(n.className) &&
              !r.test(t.element.className)
            ) {
              for (
                var s = n.childNodes, i = "", a = "", o = !1, l = 0;
                l < s.length;
                ++l
              ) {
                var c = s[l];
                c == t.element
                  ? (o = !0)
                  : "#text" === c.nodeName &&
                    (o ? (a += c.nodeValue) : (i += c.nodeValue),
                    n.removeChild(c),
                    --l);
              }
              if (t.element.children.length && Prism.plugins.KeepMarkup) {
                var u = i + t.element.innerHTML + a;
                (t.element.innerHTML = e.normalize(u, t.settings)),
                  (t.code = t.element.textContent);
              } else
                (t.code = i + t.code + a),
                  (t.code = e.normalize(t.code, t.settings));
            }
          }
        }));
  })(),
  (function () {
    if ("undefined" != typeof self && self.Prism && self.document) {
      if (!Prism.plugins.toolbar)
        return void console.warn(
          "Copy to Clipboard plugin loaded before Toolbar plugin."
        );
      var t = window.ClipboardJS || void 0;
      t || "function" != typeof require || (t = require("clipboard"));
      var e = [];
      if (!t) {
        var n = document.createElement("script"),
          r = document.querySelector("head");
        (n.onload = function () {
          if ((t = window.ClipboardJS)) for (; e.length; ) e.pop()();
        }),
          (n.src =
            "https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"),
          r.appendChild(n);
      }
      Prism.plugins.toolbar.registerButton("copy-to-clipboard", function (n) {
        function r() {
          var e = new t(i, {
            text: function () {
              return n.code;
            },
          });
          e.on("success", function () {
            (i.textContent = "Copied!"), s();
          }),
            e.on("error", function () {
              (i.textContent = "Press Ctrl+C to copy"), s();
            });
        }
        function s() {
          setTimeout(function () {
            i.textContent = "Copy";
          }, 5e3);
        }
        var i = document.createElement("a");
        return (i.textContent = "Copy"), t ? r() : e.push(r), i;
      });
    }
  })(),
  function (t, e) {
    "object" == typeof exports && "object" == typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define([], e)
      : "object" == typeof exports
      ? (exports.HSShowAnimation = e())
      : (t.HSShowAnimation = e());
  };
